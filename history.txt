 2/1: import torch
 2/2: torch.cuda.is_available()
 3/1: runfile('/home/whaleshark/.config/spyder-py3/temp.py', wdir='/home/whaleshark/.config/spyder-py3')
 5/1: runfile('/home/whaleshark/.config/spyder-py3/temp.py', wdir='/home/whaleshark/.config/spyder-py3')
 5/2: runfile('/home/whaleshark/.config/spyder-py3/temp.py', wdir='/home/whaleshark/.config/spyder-py3')
 7/1: runfile('/home/whaleshark/.config/spyder-py3/temp.py', wdir='/home/whaleshark/.config/spyder-py3')
 7/2: runfile('/home/whaleshark/.config/spyder-py3/temp.py', wdir='/home/whaleshark/.config/spyder-py3')
 7/3: runfile('/home/whaleshark/.config/spyder-py3/temp.py', wdir='/home/whaleshark/.config/spyder-py3')
 7/4: runfile('/home/whaleshark/.config/spyder-py3/temp.py', wdir='/home/whaleshark/.config/spyder-py3')
 7/5: runfile('/home/whaleshark/.config/spyder-py3/temp.py', wdir='/home/whaleshark/.config/spyder-py3')
 7/6: runfile('/home/whaleshark/.config/spyder-py3/temp.py', wdir='/home/whaleshark/.config/spyder-py3')
 7/7: runfile('/home/whaleshark/.config/spyder-py3/temp.py', wdir='/home/whaleshark/.config/spyder-py3')
 7/8: runfile('/home/whaleshark/.config/spyder-py3/temp.py', wdir='/home/whaleshark/.config/spyder-py3')
 7/9: runfile('/home/whaleshark/.config/spyder-py3/temp.py', wdir='/home/whaleshark/.config/spyder-py3')
7/10: runfile('/home/whaleshark/.config/spyder-py3/temp.py', wdir='/home/whaleshark/.config/spyder-py3')
12/1: runfile('/home/whaleshark/Documents/git/whale-shark/train.py', wdir='/home/whaleshark/Documents/git/whale-shark')
12/2: runfile('/home/whaleshark/Documents/git/whale-shark/create_dataloader.py', wdir='/home/whaleshark/Documents/git/whale-shark')
12/3: runfile('/home/whaleshark/Documents/git/whale-shark/create_dataloader.py', wdir='/home/whaleshark/Documents/git/whale-shark')
12/4: runfile('/home/whaleshark/Documents/git/whale-shark/train.py', wdir='/home/whaleshark/Documents/git/whale-shark')
18/1: runfile('/home/whaleshark/Documents/git/whale-shark/features.py', wdir='/home/whaleshark/Documents/git/whale-shark')
18/2: runfile('/home/whaleshark/Documents/git/whale-shark/create_dataloader.py', wdir='/home/whaleshark/Documents/git/whale-shark')
18/3: processed_data.columns
18/4: processed_data.head()
18/5: runfile('/home/whaleshark/Documents/git/whale-shark/create_dataloader.py', wdir='/home/whaleshark/Documents/git/whale-shark')
18/6: runfile('/home/whaleshark/Documents/git/whale-shark/features.py', wdir='/home/whaleshark/Documents/git/whale-shark')
18/7: runfile('/home/whaleshark/Documents/git/whale-shark/create_dataloader.py', wdir='/home/whaleshark/Documents/git/whale-shark')
18/8: runfile('/home/whaleshark/Documents/git/whale-shark/features.py', wdir='/home/whaleshark/Documents/git/whale-shark')
18/9: runfile('/home/whaleshark/Documents/git/whale-shark/features.py', wdir='/home/whaleshark/Documents/git/whale-shark')
18/10: runfile('/home/whaleshark/Documents/git/whale-shark/create_dataloader.py', wdir='/home/whaleshark/Documents/git/whale-shark')
18/11: runfile('/home/whaleshark/Documents/git/whale-shark/features.py', wdir='/home/whaleshark/Documents/git/whale-shark')
18/12: runfile('/home/whaleshark/Documents/git/whale-shark/create_dataloader.py', wdir='/home/whaleshark/Documents/git/whale-shark')
18/13: runfile('/home/whaleshark/Documents/git/whale-shark/create_dataloader.py', wdir='/home/whaleshark/Documents/git/whale-shark')
18/14: runfile('/home/whaleshark/Documents/git/whale-shark/create_dataloader.py', wdir='/home/whaleshark/Documents/git/whale-shark')
18/15: runfile('/home/whaleshark/Documents/git/whale-shark/train.py', wdir='/home/whaleshark/Documents/git/whale-shark')
18/16: runfile('/home/whaleshark/Documents/git/whale-shark/train.py', wdir='/home/whaleshark/Documents/git/whale-shark')
18/17: runfile('/home/whaleshark/Documents/git/whale-shark/train.py', wdir='/home/whaleshark/Documents/git/whale-shark')
20/1: runfile('/home/whaleshark/Documents/git/whale-shark/train.py', wdir='/home/whaleshark/Documents/git/whale-shark')
20/2: runfile('/home/whaleshark/Documents/git/whale-shark/train.py', wdir='/home/whaleshark/Documents/git/whale-shark')
20/3: runfile('/home/whaleshark/Documents/git/whale-shark/train.py', wdir='/home/whaleshark/Documents/git/whale-shark')
22/1: runfile('/home/whaleshark/Documents/git/whale-shark/create_dataloader.py', wdir='/home/whaleshark/Documents/git/whale-shark')
20/4: runfile('/home/whaleshark/Documents/git/whale-shark/train.py', wdir='/home/whaleshark/Documents/git/whale-shark')
22/2: runfile('/home/whaleshark/Documents/git/whale-shark/create_dataloader.py', wdir='/home/whaleshark/Documents/git/whale-shark')
20/5: runfile('/home/whaleshark/Documents/git/whale-shark/train.py', wdir='/home/whaleshark/Documents/git/whale-shark')
20/6: runfile('/home/whaleshark/Documents/git/whale-shark/create_dataloader.py', wdir='/home/whaleshark/Documents/git/whale-shark')
20/7: runfile('/home/whaleshark/Documents/git/whale-shark/train.py', wdir='/home/whaleshark/Documents/git/whale-shark')
20/8: runfile('/home/whaleshark/Documents/git/whale-shark/train.py', wdir='/home/whaleshark/Documents/git/whale-shark')
20/9: runfile('/home/whaleshark/Documents/git/whale-shark/train.py', wdir='/home/whaleshark/Documents/git/whale-shark')
20/10: runfile('/home/whaleshark/Documents/git/whale-shark/train.py', wdir='/home/whaleshark/Documents/git/whale-shark')
20/11: filtered_df
20/12: runfile('/home/whaleshark/Documents/git/whale-shark/features.py', wdir='/home/whaleshark/Documents/git/whale-shark')
20/13: filtered_df['Next_Candle_Color'].unique()
20/14: z = filtered_df[filtered_df['Next_Candle_Color'] == 0]
20/15: x = filtered_df[filtered_df['Next_Candle_Color'] == 1]
20/16: len(z) / len(filtered_df)
20/17: len(x) / len(filtered_df)
24/1:
from pipeline.coinbase_fetcher import CoinbaseDataFetcher
from pipeline.features import FeatureEngineer
from pipeline.create_dataloader import DataLoaderCreator
from pipeline.train import ModelTrainer
24/2: import whaleshark
24/3: import whale-shark
24/4: import 'whale-shark'
24/5: import pipeline
24/6:
import sys
sys.path.append(' ')
from pipeline.coinbase_fetcher import CoinbaseDataFetcher
from pipeline.features import FeatureEngineer
from pipeline.create_dataloader import DataLoaderCreator
from pipeline.train import ModelTrainer
24/7:
import sys
sys.path.append('../')
from pipeline.coinbase_fetcher import CoinbaseDataFetcher
from pipeline.features import FeatureEngineer
from pipeline.create_dataloader import DataLoaderCreator
from pipeline.train import ModelTrainer
24/8: import pipeline
24/9:
import sys
sys.path.append('../')
from pipeline.coinbase_fetcher import CoinbaseDataFetcher
from pipeline.features import FeatureEngineer
from pipeline.create_dataloader import DataLoaderCreator
from pipeline.train import ModelTrainer
from datetime import datetime, timedelta
24/10:
# First lets pull the data
fetcher = CoinbaseDataFetcher(api_key, api_secret)
pair = 'BTC-USD'
years = 10
start_time = datetime.utcnow() - timedelta(days=365 * years)  # Start from one year ago
end_time = datetime.utcnow()
granularity = 3600 #300 # 5-minute intervals # 900  # 15-minute intervals

# The filename where the CSV will be saved
filename = '10_year_long_historical_data.csv'

# Fetch and save data as CSV
data = fetcher.get_data_as_csv(pair, start_time, end_time, granularity, filename)
24/11:
# First lets pull the data
fetcher = CoinbaseDataFetcher('', '')
pair = 'BTC-USD'
years = 10
start_time = datetime.utcnow() - timedelta(days=365 * years)  # Start from one year ago
end_time = datetime.utcnow()
granularity = 3600 #300 # 5-minute intervals # 900  # 15-minute intervals

# The filename where the CSV will be saved
filename = '10_year_long_historical_data.csv'

# Fetch and save data as CSV
data = fetcher.get_data_as_csv(pair, start_time, end_time, granularity, filename)
24/12:
# Now lets shape those features
file = 'data/BTC/USD/BTC_USD_60min_20131202-20231130.csv' # or a DataFrame
engineer = FeatureEngineer(file)
processed_data = engineer.get_processed_data(True)

filtered_df = engineer.select_features_based_on_correlation(label='Next_Candle_Color')
print(filtered_df.columns)
24/13:
# Now lets shape those features
file = '../data/BTC/USD/BTC_USD_60min_20131202-20231130.csv' # or a DataFrame
engineer = FeatureEngineer(file)
processed_data = engineer.get_processed_data(True)

filtered_df = engineer.select_features_based_on_correlation(label='Next_Candle_Color')
print(filtered_df.columns)
24/14:
# Now lets shape those features
file = '../data/BTC/USD/BTC_USD_60min_20131202-20231130.csv' # or a DataFrame
engineer = FeatureEngineer(file)
processed_data = engineer.get_processed_data(True)

filtered_df = engineer.select_features_based_on_correlation(label='Next_Candle_Color')
print(filtered_df.columns)
24/15:
# Now we can create a Dataloader
runner = DataLoaderCreator('../data/filtered_engineered_data.csv',
                               batch_size=2064)

loaders = runner.create_dataloaders()

train_data = torch.load('../data/train_loader.pth')
test_data = torch.load('../data/test_loader.pth')

for inputs, labels in train_data:
    print(inputs.shape, labels.shape)  # Just for checking
    break
24/16:
import sys
sys.path.append('../')
from pipeline.coinbase_fetcher import CoinbaseDataFetcher
from pipeline.features import FeatureEngineer
from pipeline.create_dataloader import DataLoaderCreator
from pipeline.train import ModelTrainer
from datetime import datetime, timedelta
import torch
24/17:
# Now we can create a Dataloader
runner = DataLoaderCreator('../data/filtered_engineered_data.csv',
                               batch_size=2064)

loaders = runner.create_dataloaders()

train_data = torch.load('../data/train_loader.pth')
test_data = torch.load('../data/test_loader.pth')

for inputs, labels in train_data:
    print(inputs.shape, labels.shape)  # Just for checking
    break
24/18:
import sys
sys.path.append('../')
from pipeline.coinbase_fetcher import CoinbaseDataFetcher
from pipeline.features import FeatureEngineer
from pipeline.create_dataloader import DataLoaderCreator
from pipeline.train import ModelTrainer
from pieline.simple_model import SimpleNN, EnhancedNN, resnet18

from datetime import datetime, timedelta
import torch
24/19:
import sys
sys.path.append('../')
from pipeline.coinbase_fetcher import CoinbaseDataFetcher
from pipeline.features import FeatureEngineer
from pipeline.create_dataloader import DataLoaderCreator
from pipeline.train import ModelTrainer
from pipeline.simple_model import SimpleNN, EnhancedNN, resnet18

from datetime import datetime, timedelta
import torch
24/20:
import sys
sys.path.append('../')
from pipeline.coinbase_fetcher import CoinbaseDataFetcher
from pipeline.features import FeatureEngineer
from pipeline.create_dataloader import DataLoaderCreator
from pipeline.train import ModelTrainer
from models.simple_model import SimpleNN, EnhancedNN, resnet18

from datetime import datetime, timedelta
import torch
24/21:
import sys
sys.path.append('../')
from pipeline.coinbase_fetcher import CoinbaseDataFetcher
from pipeline.features import FeatureEngineer
from pipeline.create_dataloader import DataLoaderCreator
from pipeline.train import ModelTrainer
from models.simple_model import SimpleNN, EnhancedNN, resnet18

from datetime import datetime, timedelta
import torch
24/22:
# First lets pull the data
fetcher = CoinbaseDataFetcher('', '')
pair = 'BTC-USD'
years = 10
start_time = datetime.utcnow() - timedelta(days=365 * years)  # Start from one year ago
end_time = datetime.utcnow()
granularity = 3600 #300 # 5-minute intervals # 900  # 15-minute intervals

# The filename where the CSV will be saved
filename = '10_year_long_historical_data.csv'

# Fetch and save data as CSV
data = fetcher.get_data_as_csv(pair, start_time, end_time, granularity, filename)
24/23:
# Now lets shape those features
file = '../data/BTC/USD/BTC_USD_60min_20131202-20231130.csv' # or a DataFrame
engineer = FeatureEngineer(file)
processed_data = engineer.get_processed_data(True)

filtered_df = engineer.select_features_based_on_correlation(label='Next_Candle_Color')
print(filtered_df.columns)
24/24:
# Now we can create a Dataloader
runner = DataLoaderCreator('../data/filtered_engineered_data.csv',
                               batch_size=2064)

loaders = runner.create_dataloaders()

train_data = torch.load('../data/train_loader.pth')
test_data = torch.load('../data/test_loader.pth')

for inputs, labels in train_data:
    print(inputs.shape, labels.shape)  # Just for checking
    break
24/25:
# Now we can train the model! 
model = EnhancedNN(n_features=17)
trainer = ModelTrainer(model, 'data')
trainer.train()
test_loss, test_accuracy = trainer.evaluate_model(trainer.test_loader)
print('the Model achieved {} in testing accuracy'.format(test_accuracy))

trainer.get_time()
24/26:
# First lets pull the data
fetcher = CoinbaseDataFetcher('', '')
pair = 'BTC-USD'
years = 10
start_time = datetime.utcnow() - timedelta(days=365 * years)  # Start from one year ago
end_time = datetime.utcnow()
granularity = 3600 #300 # 5-minute intervals # 900  # 15-minute intervals

# The filename where the CSV will be saved
filename = '10_year_long_historical_data.csv'

# Fetch and save data as CSV
data = fetcher.get_data_as_csv(pair, start_time, end_time, granularity, filename)
print('Number of samples: {}'.format(len(data)))
25/1:
import sys
sys.path.append('../')
from pipeline.coinbase_fetcher import CoinbaseDataFetcher
from pipeline.features import FeatureEngineer
from pipeline.create_dataloader import DataLoaderCreator
from pipeline.train import ModelTrainer
from models.simple_model import SimpleNN, EnhancedNN, resnet18

from datetime import datetime, timedelta
import torch
25/2:
import sys
sys.path.append('../')
from pipeline.coinbase_fetcher import CoinbaseDataFetcher
from pipeline.features import FeatureEngineer
from pipeline.create_dataloader import DataLoaderCreator
from pipeline.train import ModelTrainer
from models.simple_model import SimpleNN, EnhancedNN, resnet18

from datetime import datetime, timedelta
import torch
25/3:
# First lets pull the data
fetcher = CoinbaseDataFetcher('', '')
pair = 'BTC-USD'
years = 10
start_time = datetime.utcnow() - timedelta(days=365 * years)  # Start from one year ago
end_time = datetime.utcnow()
#300-> 5-minute, 900-> 15-minute, 3600-> 1 hour
granularity = 300 

# The filename where the CSV will be saved
filename = '10_year_long_historical_data.csv'

# Fetch and save data as CSV
data = fetcher.get_data_as_csv(pair, start_time, end_time, granularity, filename)
print('Number of samples: {}'.format(len(data)))
25/4:
import sys
sys.path.append('../')
from pipeline.coinbase_fetcher import CoinbaseDataFetcher
from pipeline.features import FeatureEngineer
from pipeline.create_dataloader import DataLoaderCreator
from pipeline.train import ModelTrainer
from models.simple_model import SimpleNN, EnhancedNN, resnet18

from datetime import datetime, timedelta
import torch
25/5:
# First lets pull the data
fetcher = CoinbaseDataFetcher('', '')
pair = 'BTC-USD'
years = 10
start_time = datetime.utcnow() - timedelta(days=365 * years)  # Start from one year ago
end_time = datetime.utcnow()
#300-> 5-minute, 900-> 15-minute, 3600-> 1 hour
granularity = 300 

# The filename where the CSV will be saved
filename = '10_year_long_historical_data.csv'

# Fetch and save data as CSV
data = fetcher.get_data_as_csv(pair, start_time, end_time, granularity, filename)
print('Number of samples: {}'.format(len(data)))
26/1:
import sys
sys.path.append('../')
from pipeline.coinbase_fetcher import CoinbaseDataFetcher
from pipeline.features import FeatureEngineer
from pipeline.create_dataloader import DataLoaderCreator
from pipeline.train import ModelTrainer
from models.simple_model import SimpleNN, EnhancedNN, resnet18

from datetime import datetime, timedelta
import torch
26/2:
# First lets pull the data
fetcher = CoinbaseDataFetcher('', '')
pair = 'BTC-USD'
years = 10
start_time = datetime.utcnow() - timedelta(days=365 * years)  # Start from one year ago
end_time = datetime.utcnow()
#300-> 5-minute, 900-> 15-minute, 3600-> 1 hour
granularity = 300 

# The filename where the CSV will be saved
filename = '10_year_long_historical_data.csv'

# Fetch and save data as CSV
data = fetcher.get_data_as_csv(pair, start_time, end_time, granularity, filename)
print('Number of samples: {}'.format(len(data)))
26/3:
import sys
sys.path.append('../')
from pipeline.coinbase_fetcher import CoinbaseDataFetcher
from pipeline.features import FeatureEngineer
from pipeline.create_dataloader import DataLoaderCreator
from pipeline.train import ModelTrainer
from models.simple_model import SimpleNN, EnhancedNN, resnet18

from datetime import datetime, timedelta
import torch
26/4:
import sys
sys.path.append('../')
from pipeline.coinbase_fetcher import CoinbaseDataFetcher
from pipeline.features import FeatureEngineer
from pipeline.create_dataloader import DataLoaderCreator
from pipeline.train import ModelTrainer
from models.simple_model import SimpleNN, EnhancedNN, resnet18

from datetime import datetime, timedelta
import torch
26/5:
# First lets pull the data
fetcher = CoinbaseDataFetcher('', '')
pair = 'BTC-USD'
years = 10
start_time = datetime.utcnow() - timedelta(days=365 * years)  # Start from one year ago
end_time = datetime.utcnow()
#300-> 5-minute, 900-> 15-minute, 3600-> 1 hour
granularity = 300 

# The filename where the CSV will be saved
filename = '10_year_long_historical_data.csv'

# Fetch and save data as CSV
data = fetcher.get_data_as_csv(pair, start_time, end_time, granularity, filename)
print('Number of samples: {}'.format(len(data)))
27/1:
import sys
sys.path.append('../')
from pipeline.coinbase_fetcher import CoinbaseDataFetcher
from pipeline.features import FeatureEngineer
from pipeline.create_dataloader import DataLoaderCreator
from pipeline.train import ModelTrainer
from models.simple_model import SimpleNN, EnhancedNN, resnet18

from datetime import datetime, timedelta
import torch
27/2:
# First lets pull the data
fetcher = CoinbaseDataFetcher('', '')
pair = 'BTC-USD'
years = 10
start_time = datetime.utcnow() - timedelta(days=365 * years)  # Start from one year ago
end_time = datetime.utcnow()
#300-> 5-minute, 900-> 15-minute, 3600-> 1 hour
granularity = 300 

# The filename where the CSV will be saved
filename = '10_year_long_historical_data.csv'

# Fetch and save data as CSV
data = fetcher.get_data_as_csv(pair, start_time, end_time, granularity, filename)
print('Number of samples: {}'.format(len(data)))
27/3:
import sys
sys.path.append('../')
from pipeline.coinbase_fetcher import CoinbaseDataFetcher
from pipeline.features import FeatureEngineer
from pipeline.create_dataloader import DataLoaderCreator
from pipeline.train import ModelTrainer
from models.simple_model import SimpleNN, EnhancedNN, resnet18

from datetime import datetime, timedelta
import torch
27/4:
# First lets pull the data
fetcher = CoinbaseDataFetcher('', '')
pair = 'BTC-USD'
years = 10
start_time = datetime.utcnow() - timedelta(days=365 * years)  # Start from one year ago
end_time = datetime.utcnow()
#300-> 5-minute, 900-> 15-minute, 3600-> 1 hour
granularity = 900 

# The filename where the CSV will be saved
filename = '10_year_long_historical_data.csv'

# Fetch and save data as CSV
data = fetcher.get_data_as_csv(pair, start_time, end_time, granularity, filename)
print('Number of samples: {}'.format(len(data)))
27/5:
import sys
sys.path.append('../')
from pipeline.coinbase_fetcher import CoinbaseDataFetcher
from pipeline.features import FeatureEngineer
from pipeline.create_dataloader import DataLoaderCreator
from pipeline.train import ModelTrainer
from models.simple_model import SimpleNN, EnhancedNN, resnet18

from datetime import datetime, timedelta
import torch
29/1:
import sys
sys.path.append('../')
from pipeline.coinbase_fetcher import CoinbaseDataFetcher
from pipeline.features import FeatureEngineer
from pipeline.create_dataloader import DataLoaderCreator
from pipeline.train import ModelTrainer
from models.simple_model import SimpleNN, EnhancedNN, resnet18

from datetime import datetime, timedelta
import torch
29/2:
# Now lets shape those features
file = '../data/BTC/USD/BTC_USD_5min_20131202-20231130.csv' # or a DataFrame
engineer = FeatureEngineer(file)
processed_data = engineer.get_processed_data(save=True) # we can turn save off if we plan to use filtered data

filtered_df = engineer.select_features_based_on_correlation(label='Next_Candle_Color')
print(filtered_df.columns)
29/3:
# Now lets shape those features
file = '../data/BTC/USD/BTC_USD_5min_20131203-20231201.csv # or a DataFrame
engineer = FeatureEngineer(file)
processed_data = engineer.get_processed_data(save=True) # we can turn save off if we plan to use filtered data

filtered_df = engineer.select_features_based_on_correlation(label='Next_Candle_Color')
print(filtered_df.columns)
29/4:
# Now lets shape those features
file = '../data/BTC/USD/BTC_USD_5min_20131203-20231201.csv' # or a DataFrame
engineer = FeatureEngineer(file)
processed_data = engineer.get_processed_data(save=True) # we can turn save off if we plan to use filtered data

filtered_df = engineer.select_features_based_on_correlation(label='Next_Candle_Color')
print(filtered_df.columns)
29/5:
# Now lets shape those features
file = '../data/BTC/USD/BTC_USD_5min_20131203-20231201.csv' # or a DataFrame
file = 'pipeline/data/BTC/USD/BTC_USD_5min_20131203-20231201.csv'
engineer = FeatureEngineer(file)
processed_data = engineer.get_processed_data(save=True) # we can turn save off if we plan to use filtered data

filtered_df = engineer.select_features_based_on_correlation(label='Next_Candle_Color')
print(filtered_df.columns)
29/6:
# Now lets shape those features
file = '../data/BTC/USD/BTC_USD_5min_20131203-20231201.csv' # or a DataFrame
file = '../pipeline/data/BTC/USD/BTC_USD_5min_20131203-20231201.csv'
engineer = FeatureEngineer(file)
processed_data = engineer.get_processed_data(save=True) # we can turn save off if we plan to use filtered data

filtered_df = engineer.select_features_based_on_correlation(label='Next_Candle_Color')
print(filtered_df.columns)
29/7:
# Now we can create a Dataloader
runner = DataLoaderCreator('../data/filtered_engineered_data.csv',
                               batch_size=2064)

loaders = runner.create_dataloaders(test_size=0.4,
                                    val_size=0.4,
                                    save_path='../data')

train_data = torch.load('../data/train_loader.pth')
test_data = torch.load('../data/test_loader.pth')

for inputs, labels in train_data:
    print(inputs.shape, labels.shape)  # Just for checking
    break
29/8:
# Now we can train the model! 
model = EnhancedNN(n_features=17)
trainer = ModelTrainer(model, '../data',
                       learning_rate=0.001, epochs=50)
trainer.train(accuracy_threshold=0.6)
test_loss, test_accuracy = trainer.evaluate_model(trainer.test_loader)
print('the Model achieved {} in testing accuracy'.format(test_accuracy))

trainer.get_time()
29/9:
# Now we can train the model! 
model = EnhancedNN(n_features=18)
trainer = ModelTrainer(model, '../data',
                       learning_rate=0.001, epochs=50)
trainer.train(accuracy_threshold=0.6)
test_loss, test_accuracy = trainer.evaluate_model(trainer.test_loader)
print('the Model achieved {} in testing accuracy'.format(test_accuracy))

trainer.get_time()
29/10:
# Now lets shape those features
file = '../data/BTC/USD/BTC_USD_5min_20131203-20231201.csv' # or a DataFrame
file = '../pipeline/data/BTC/USD/BTC_USD_5min_20131203-20231201.csv'
engineer = FeatureEngineer(file)
processed_data = engineer.get_processed_data(save=True) # we can turn save off if we plan to use filtered data

filtered_df = engineer.select_features_based_on_correlation(label='label')
print(filtered_df.columns)
29/11:
import sys
sys.path.append('../')
from pipeline.coinbase_fetcher import CoinbaseDataFetcher
from pipeline.features import FeatureEngineer
from pipeline.create_dataloader import DataLoaderCreator
from pipeline.train import ModelTrainer
from models.simple_model import SimpleNN, EnhancedNN, resnet18

from datetime import datetime, timedelta
import torch
29/12:
# Now lets shape those features
file = '../data/BTC/USD/BTC_USD_5min_20131203-20231201.csv' # or a DataFrame
file = '../pipeline/data/BTC/USD/BTC_USD_5min_20131203-20231201.csv'
engineer = FeatureEngineer(file)
processed_data = engineer.get_processed_data(save=True) # we can turn save off if we plan to use filtered data

filtered_df = engineer.select_features_based_on_correlation(label='label')
print(filtered_df.columns)
29/13:
# Now we can create a Dataloader
runner = DataLoaderCreator('../data/filtered_engineered_data.csv',
                               batch_size=2064)

loaders = runner.create_dataloaders(test_size=0.4,
                                    val_size=0.4, label='label'
                                    save_path='../data')

train_data = torch.load('../data/train_loader.pth')
test_data = torch.load('../data/test_loader.pth')

for inputs, labels in train_data:
    print(inputs.shape, labels.shape)  # Just for checking
    break
29/14:
import sys
sys.path.append('../')
from pipeline.coinbase_fetcher import CoinbaseDataFetcher
from pipeline.features import FeatureEngineer
from pipeline.create_dataloader import DataLoaderCreator
from pipeline.train import ModelTrainer
from models.simple_model import SimpleNN, EnhancedNN, resnet18

from datetime import datetime, timedelta
import torch
29/15:
# Now lets shape those features
file = '../data/BTC/USD/BTC_USD_5min_20131203-20231201.csv' # or a DataFrame
file = '../pipeline/data/BTC/USD/BTC_USD_5min_20131203-20231201.csv'
engineer = FeatureEngineer(file)
processed_data = engineer.get_processed_data(save=True) # we can turn save off if we plan to use filtered data

filtered_df = engineer.select_features_based_on_correlation(label='label')
print(filtered_df.columns)
29/16:
# Now we can create a Dataloader
runner = DataLoaderCreator('../data/filtered_engineered_data.csv',
                               batch_size=2064)

loaders = runner.create_dataloaders(test_size=0.4,
                                    val_size=0.4, label='label'
                                    save_path='../data')

train_data = torch.load('../data/train_loader.pth')
test_data = torch.load('../data/test_loader.pth')

for inputs, labels in train_data:
    print(inputs.shape, labels.shape)  # Just for checking
    break
29/17:
# Now we can create a Dataloader
runner = DataLoaderCreator('../data/filtered_engineered_data.csv',
                               batch_size=2064)

loaders = runner.create_dataloaders(test_size=0.4,
                                    val_size=0.4, label='label',
                                    save_path='../data')

train_data = torch.load('../data/train_loader.pth')
test_data = torch.load('../data/test_loader.pth')

for inputs, labels in train_data:
    print(inputs.shape, labels.shape)  # Just for checking
    break
31/1:
import sys
sys.path.append('../')
from pipeline.coinbase_fetcher import CoinbaseDataFetcher
from pipeline.features import FeatureEngineer
from pipeline.create_dataloader import DataLoaderCreator
from pipeline.train import ModelTrainer
from models.simple_model import SimpleNN, EnhancedNN, resnet18

from datetime import datetime, timedelta
import torch
31/2:
# DO we want new data?
fetch = False

# First lets pull the data
fetcher = CoinbaseDataFetcher('', '')
pair = 'BTC-USD'
years = 10
start_time = datetime.utcnow() - timedelta(days=365 * years)  # Start from one year ago
end_time = datetime.utcnow()
#300-> 5-minute, 900-> 15-minute, 3600-> 1 hour
granularity = 900 

# The filename where the CSV will be saved
filename = '10_year_long_historical_data.csv'

# Fetch and save data as CSV
if fetch:
    data = fetcher.get_data_as_csv(pair, start_time, end_time, granularity, filename)
    print('Number of samples: {}'.format(len(data)))
31/3:
# Now lets shape those features
file = '../data/BTC/USD/BTC_USD_5min_20131203-20231201.csv' # or a DataFrame
file = '../pipeline/data/BTC/USD/BTC_USD_5min_20131203-20231201.csv'
engineer = FeatureEngineer(file)
processed_data = engineer.get_processed_data(save=True) # we can turn save off if we plan to use filtered data

filtered_df = engineer.select_features_based_on_correlation(label='label')
print(filtered_df.columns)
31/4:
# Now we can create a Dataloader
runner = DataLoaderCreator('../data/filtered_engineered_data.csv',
                               batch_size=2064)

loaders = runner.create_dataloaders(test_size=0.4,
                                    val_size=0.4, label='label',
                                    save_path='../data')

train_data = torch.load('../data/train_loader.pth')
test_data = torch.load('../data/test_loader.pth')

for inputs, labels in train_data:
    print(inputs.shape, labels.shape)  # Just for checking
    break
33/1:
import sys
sys.path.append('../')
from pipeline.coinbase_fetcher import CoinbaseDataFetcher
from pipeline.features import FeatureEngineer
from pipeline.create_dataloader import DataLoaderCreator
from pipeline.train import ModelTrainer
from models.simple_model import SimpleNN, EnhancedNN, resnet18

from datetime import datetime, timedelta
import torch
33/2:
# DO we want new data?
fetch = False

# First lets pull the data
fetcher = CoinbaseDataFetcher('', '')
pair = 'BTC-USD'
years = 10
start_time = datetime.utcnow() - timedelta(days=365 * years)  # Start from one year ago
end_time = datetime.utcnow()
#300-> 5-minute, 900-> 15-minute, 3600-> 1 hour
granularity = 900 

# The filename where the CSV will be saved
filename = '10_year_long_historical_data.csv'

# Fetch and save data as CSV
if fetch:
    data = fetcher.get_data_as_csv(pair, start_time, end_time, granularity, filename)
    print('Number of samples: {}'.format(len(data)))
33/3:
# Now lets shape those features
file = '../data/BTC/USD/BTC_USD_5min_20131203-20231201.csv' # or a DataFrame
file = '../pipeline/data/BTC/USD/BTC_USD_5min_20131203-20231201.csv'
engineer = FeatureEngineer(file)
processed_data = engineer.get_processed_data(save=True) # we can turn save off if we plan to use filtered data

filtered_df = engineer.select_features_based_on_correlation(label='label')
print(filtered_df.columns)
33/4:
# Now we can create a Dataloader
runner = DataLoaderCreator('../data/filtered_engineered_data.csv',
                               batch_size=2064)

loaders = runner.create_dataloaders(test_size=0.4,
                                    val_size=0.4, label='label',
                                    save_path='../data')

train_data = torch.load('../data/train_loader.pth')
test_data = torch.load('../data/test_loader.pth')

for inputs, labels in train_data:
    print(inputs.shape, labels.shape)  # Just for checking
    break
33/5:
# Now we can train the model! 
model = EnhancedNN(n_features=len(filtered_df.columns))
trainer = ModelTrainer(model, '../data',
                       learning_rate=0.001, epochs=50)
trainer.train(accuracy_threshold=0.6)
test_loss, test_accuracy = trainer.evaluate_model(trainer.test_loader)
print('the Model achieved {} in testing accuracy'.format(test_accuracy))

trainer.get_time()
33/6:
# Now we can create a Dataloader
runner = DataLoaderCreator('../data/filtered_engineered_data.csv',
                               batch_size=1032)

loaders = runner.create_dataloaders(test_size=0.4,
                                    val_size=0.4, label='label',
                                    save_path='../data')

train_data = torch.load('../data/train_loader.pth')
test_data = torch.load('../data/test_loader.pth')

for inputs, labels in train_data:
    print(inputs.shape, labels.shape)  # Just for checking
    break
33/7:
# Now we can train the model! 
model = EnhancedNN(n_features=len(filtered_df.columns))
trainer = ModelTrainer(model, '../data',
                       learning_rate=0.001, epochs=50)
trainer.train(accuracy_threshold=0.6)
test_loss, test_accuracy = trainer.evaluate_model(trainer.test_loader)
print('the Model achieved {} in testing accuracy'.format(test_accuracy))

trainer.get_time()
33/8:
# Now we can train the model! 
model = SimpleNN(n_features=len(filtered_df.columns))
trainer = ModelTrainer(model, '../data',
                       learning_rate=0.001, epochs=50)
trainer.train(accuracy_threshold=0.6)
test_loss, test_accuracy = trainer.evaluate_model(trainer.test_loader)
print('the Model achieved {} in testing accuracy'.format(test_accuracy))

trainer.get_time()
33/9:
# Now lets shape those features
file = '../data/BTC/USD/BTC_USD_60min_20131202-20231130.csv' # or a DataFrame
#file = '../pipeline/data/BTC/USD/BTC_USD_5min_20131203-20231201.csv'
engineer = FeatureEngineer(file)
processed_data = engineer.get_processed_data(save=False) # we can turn save off if we plan to use filtered data

filtered_df = engineer.select_features_based_on_correlation(label='label')
print(filtered_df.columns)
33/10:
# Now we can create a Dataloader
runner = DataLoaderCreator('../data/filtered_engineered_data.csv',
                               batch_size=1032)

loaders = runner.create_dataloaders(test_size=0.4,
                                    val_size=0.4, label='label',
                                    save_path='../data')

train_data = torch.load('../data/train_loader.pth')
test_data = torch.load('../data/test_loader.pth')

for inputs, labels in train_data:
    print(inputs.shape, labels.shape)  # Just for checking
    break
33/11:
# Now we can train the model! 
model = SimpleNN(n_features=len(filtered_df.columns))
trainer = ModelTrainer(model, '../data',
                       learning_rate=0.001, epochs=50)
trainer.train(accuracy_threshold=0.6)
test_loss, test_accuracy = trainer.evaluate_model(trainer.test_loader)
print('the Model achieved {} in testing accuracy'.format(test_accuracy))

trainer.get_time()
35/1:
import sys
sys.path.append('../')
from pipeline.coinbase_fetcher import CoinbaseDataFetcher
from pipeline.features import FeatureEngineer
from pipeline.create_dataloader import DataLoaderCreator
from pipeline.train import ModelTrainer
from models.simple_model import SimpleNN, EnhancedNN, resnet18

from datetime import datetime, timedelta
import torch
35/2:
# DO we want new data?
fetch = False

# First lets pull the data
fetcher = CoinbaseDataFetcher('', '')
pair = 'BTC-USD'
years = 10
start_time = datetime.utcnow() - timedelta(days=365 * years)  # Start from one year ago
end_time = datetime.utcnow()
#300-> 5-minute, 900-> 15-minute, 3600-> 1 hour
granularity = 900 

# The filename where the CSV will be saved
filename = '10_year_long_historical_data.csv'

# Fetch and save data as CSV
if fetch:
    data = fetcher.get_data_as_csv(pair, start_time, end_time, granularity, filename)
    print('Number of samples: {}'.format(len(data)))
35/3:
# Now lets shape those features
file = '../data/BTC/USD/BTC_USD_60min_20131202-20231130.csv' # or a DataFrame
#file = '../pipeline/data/BTC/USD/BTC_USD_5min_20131203-20231201.csv'
engineer = FeatureEngineer(file)
processed_data = engineer.get_processed_data(save=False) # we can turn save off if we plan to use filtered data

filtered_df = engineer.select_features_based_on_correlation(label='label')
print(filtered_df.columns)
35/4:
# Now we can create a Dataloader
runner = DataLoaderCreator('../data/filtered_engineered_data.csv',
                               batch_size=1032)

loaders = runner.create_dataloaders(test_size=0.4,
                                    val_size=0.4, label='label',
                                    save_path='../data')

train_data = torch.load('../data/train_loader.pth')
test_data = torch.load('../data/test_loader.pth')

for inputs, labels in train_data:
    print(inputs.shape, labels.shape)  # Just for checking
    break
35/5:
# Now we can train the model! 
model = SimpleNN(n_features=len(filtered_df.columns))
trainer = ModelTrainer(model, '../data',
                       learning_rate=0.001, epochs=50)
trainer.train(accuracy_threshold=0.6)
test_loss, test_accuracy = trainer.evaluate_model(trainer.test_loader)
print('the Model achieved {} in testing accuracy'.format(test_accuracy))

trainer.get_time()
35/6:
# Now we can train the model! 
model = SimpleNN(n_features=17)
trainer = ModelTrainer(model, '../data',
                       learning_rate=0.001, epochs=50)
trainer.train(accuracy_threshold=0.6)
test_loss, test_accuracy = trainer.evaluate_model(trainer.test_loader)
print('the Model achieved {} in testing accuracy'.format(test_accuracy))

trainer.get_time()
35/7:
# Now we can train the model! 
model = SimpleNN(n_features=3)
trainer = ModelTrainer(model, '../data',
                       learning_rate=0.001, epochs=50)
trainer.train(accuracy_threshold=0.6)
test_loss, test_accuracy = trainer.evaluate_model(trainer.test_loader)
print('the Model achieved {} in testing accuracy'.format(test_accuracy))

trainer.get_time()
35/8:
# Now lets shape those features
file = '../data/BTC/USD/BTC_USD_60min_20131202-20231130.csv' # or a DataFrame
#file = '../pipeline/data/BTC/USD/BTC_USD_5min_20131203-20231201.csv'
engineer = FeatureEngineer(file)
processed_data = engineer.get_processed_data(save=True) # we can turn save off if we plan to use filtered data

filtered_df = engineer.select_features_based_on_correlation(label='label')
print(filtered_df.columns)
35/9:
# Now we can create a Dataloader
runner = DataLoaderCreator('../data/filtered_engineered_data.csv',
                               batch_size=1032)

loaders = runner.create_dataloaders(test_size=0.4,
                                    val_size=0.4, label='label',
                                    save_path='../data')

train_data = torch.load('../data/train_loader.pth')
test_data = torch.load('../data/test_loader.pth')

for inputs, labels in train_data:
    print(inputs.shape, labels.shape)  # Just for checking
    break
35/10:
# Now we can train the model! 
model = SimpleNN(n_features=3)
trainer = ModelTrainer(model, '../data',
                       learning_rate=0.001, epochs=50)
trainer.train(accuracy_threshold=0.6)
test_loss, test_accuracy = trainer.evaluate_model(trainer.test_loader)
print('the Model achieved {} in testing accuracy'.format(test_accuracy))

trainer.get_time()
35/11:
# Now we can train the model! 
model = SimpleNN(n_features=len(filtered_df.columns))
trainer = ModelTrainer(model, '../data',
                       learning_rate=0.001, epochs=50)
trainer.train(accuracy_threshold=0.6)
test_loss, test_accuracy = trainer.evaluate_model(trainer.test_loader)
print('the Model achieved {} in testing accuracy'.format(test_accuracy))

trainer.get_time()
35/12:
# Now lets shape those features
file = '../data/BTC/USD/BTC_USD_60min_20131202-20231130.csv' # or a DataFrame
#file = '../pipeline/data/BTC/USD/BTC_USD_5min_20131203-20231201.csv'
engineer = FeatureEngineer(file)
#processed_data = engineer.get_processed_data(save=True) # we can turn save off if we plan to use filtered data

filtered_df = engineer.select_features_based_on_correlation(label='label')
print(filtered_df.columns, len(filtered_df.columns)
36/1:
import sys
sys.path.append('../')
from pipeline.coinbase_fetcher import CoinbaseDataFetcher
from pipeline.features import FeatureEngineer
from pipeline.create_dataloader import DataLoaderCreator
from pipeline.train import ModelTrainer
from models.simple_model import SimpleNN, EnhancedNN, resnet18

from datetime import datetime, timedelta
import torch
36/2:
# DO we want new data?
fetch = False

# First lets pull the data
fetcher = CoinbaseDataFetcher('', '')
pair = 'BTC-USD'
years = 10
start_time = datetime.utcnow() - timedelta(days=365 * years)  # Start from one year ago
end_time = datetime.utcnow()
#300-> 5-minute, 900-> 15-minute, 3600-> 1 hour
granularity = 900 

# The filename where the CSV will be saved
filename = '10_year_long_historical_data.csv'

# Fetch and save data as CSV
if fetch:
    data = fetcher.get_data_as_csv(pair, start_time, end_time, granularity, filename)
    print('Number of samples: {}'.format(len(data)))
36/3:
# Now lets shape those features
file = '../data/BTC/USD/BTC_USD_60min_20131202-20231130.csv' # or a DataFrame
#file = '../pipeline/data/BTC/USD/BTC_USD_5min_20131203-20231201.csv'
engineer = FeatureEngineer(file)
#processed_data = engineer.get_processed_data(save=True) # we can turn save off if we plan to use filtered data

filtered_df = engineer.select_features_based_on_correlation(label='label')
print(filtered_df.columns, len(filtered_df.columns)
38/1:
import sys
sys.path.append('../')
from pipeline.coinbase_fetcher import CoinbaseDataFetcher
from pipeline.features import FeatureEngineer
from pipeline.create_dataloader import DataLoaderCreator
from pipeline.train import ModelTrainer
from models.simple_model import SimpleNN, EnhancedNN, resnet18

from datetime import datetime, timedelta
import torch
38/2:
# DO we want new data?
fetch = False

# First lets pull the data
fetcher = CoinbaseDataFetcher('', '')
pair = 'BTC-USD'
years = 10
start_time = datetime.utcnow() - timedelta(days=365 * years)  # Start from one year ago
end_time = datetime.utcnow()
#300-> 5-minute, 900-> 15-minute, 3600-> 1 hour
granularity = 900 

# The filename where the CSV will be saved
filename = '10_year_long_historical_data.csv'

# Fetch and save data as CSV
if fetch:
    data = fetcher.get_data_as_csv(pair, start_time, end_time, granularity, filename)
    print('Number of samples: {}'.format(len(data)))
38/3:
# Now lets shape those features
file = '../data/BTC/USD/BTC_USD_60min_20131202-20231130.csv' # or a DataFrame
#file = '../pipeline/data/BTC/USD/BTC_USD_5min_20131203-20231201.csv'
engineer = FeatureEngineer(file)
#processed_data = engineer.get_processed_data(save=True) # we can turn save off if we plan to use filtered data

filtered_df = engineer.select_features_based_on_correlation(label='label')
print(filtered_df.columns, len(filtered_df.columns)
38/4:
# Now lets shape those features
file = '../data/BTC/USD/BTC_USD_60min_20131202-20231130.csv' # or a DataFrame
#file = '../pipeline/data/BTC/USD/BTC_USD_5min_20131203-20231201.csv'
engineer = FeatureEngineer(file)
#processed_data = engineer.get_processed_data(save=True) # we can turn save off if we plan to use filtered data

filtered_df = engineer.select_features_based_on_correlation(label='label')
print(filtered_df.columns, len(filtered_df.columns))
38/5:
# Now lets shape those features
file = '../data/BTC/USD/BTC_USD_60min_20131202-20231130.csv' # or a DataFrame
#file = '../pipeline/data/BTC/USD/BTC_USD_5min_20131203-20231201.csv'
engineer = FeatureEngineer(file)
processed_data = engineer.get_processed_data(save=True) # we can turn save off if we plan to use filtered data

filtered_df = engineer.select_features_based_on_correlation(label='label')
print(filtered_df.columns, len(filtered_df.columns))
38/6:
# Now we can create a Dataloader
runner = DataLoaderCreator('../data/filtered_engineered_data.csv',
                               batch_size=1032)

loaders = runner.create_dataloaders(test_size=0.4,
                                    val_size=0.4, label='label',
                                    save_path='../data')

train_data = torch.load('../data/train_loader.pth')
test_data = torch.load('../data/test_loader.pth')

for inputs, labels in train_data:
    print(inputs.shape, labels.shape)  # Just for checking
    break
38/7:
# Now we can train the model! 
model = SimpleNN(n_features=len(filtered_df.columns))
trainer = ModelTrainer(model, '../data',
                       learning_rate=0.001, epochs=50)
trainer.train(accuracy_threshold=0.6)
test_loss, test_accuracy = trainer.evaluate_model(trainer.test_loader)
print('the Model achieved {} in testing accuracy'.format(test_accuracy))

trainer.get_time()
38/8:
# Now we can create a Dataloader
runner = DataLoaderCreator('../data/filtered_engineered_data.csv',
                               batch_size=1032)

loaders = runner.create_dataloaders(test_size=0.4,
                                    val_size=0.4, label='label',
                                    save_path='../data')

train_data = torch.load('../data/train_loader.pth')
test_data = torch.load('../data/test_loader.pth')

for inputs, labels in train_data:
    print(inputs.shape, labels.shape)  # Just for checking
    print(inputs, labels)
    break
38/9:
# Now we can create a Dataloader
runner = DataLoaderCreator('../data/filtered_engineered_data.csv',
                               batch_size=1032)

loaders = runner.create_dataloaders(test_size=0.4,
                                    val_size=0.4, label='label',
                                    save_path='../data')

train_data = torch.load('../data/train_loader.pth')
test_data = torch.load('../data/test_loader.pth')

for inputs, labels in train_data:
    print(inputs.shape, labels.shape)  # Just for checking
    break
38/10:
# Now we can train the model! 
model = SimpleNN(n_features=17
trainer = ModelTrainer(model, '../data',
                       learning_rate=0.001, epochs=50)
trainer.train(accuracy_threshold=0.6)
test_loss, test_accuracy = trainer.evaluate_model(trainer.test_loader)
print('the Model achieved {} in testing accuracy'.format(test_accuracy))

trainer.get_time()
38/11:
# Now we can train the model! 
model = SimpleNN(n_features=17)
trainer = ModelTrainer(model, '../data',
                       learning_rate=0.001, epochs=50)
trainer.train(accuracy_threshold=0.6)
test_loss, test_accuracy = trainer.evaluate_model(trainer.test_loader)
print('the Model achieved {} in testing accuracy'.format(test_accuracy))

trainer.get_time()
38/12: filtered_df.label.unique()
40/1:
import sys
sys.path.append('../')
from pipeline.coinbase_fetcher import CoinbaseDataFetcher
from pipeline.features import FeatureEngineer
from pipeline.create_dataloader import DataLoaderCreator
from pipeline.train import ModelTrainer
from models.simple_model import SimpleNN, EnhancedNN, resnet18

from datetime import datetime, timedelta
import torch
40/2:
# DO we want new data?
fetch = False

# First lets pull the data
fetcher = CoinbaseDataFetcher('', '')
pair = 'BTC-USD'
years = 10
start_time = datetime.utcnow() - timedelta(days=365 * years)  # Start from one year ago
end_time = datetime.utcnow()
#300-> 5-minute, 900-> 15-minute, 3600-> 1 hour
granularity = 900 

# The filename where the CSV will be saved
filename = '10_year_long_historical_data.csv'

# Fetch and save data as CSV
if fetch:
    data = fetcher.get_data_as_csv(pair, start_time, end_time, granularity, filename)
    print('Number of samples: {}'.format(len(data)))
40/3:
# Now lets shape those features
file = '../data/BTC/USD/BTC_USD_60min_20131202-20231130.csv' # or a DataFrame
#file = '../pipeline/data/BTC/USD/BTC_USD_5min_20131203-20231201.csv'
engineer = FeatureEngineer(file)
processed_data = engineer.get_processed_data(save=True) # we can turn save off if we plan to use filtered data

filtered_df = engineer.select_features_based_on_correlation(label='label')
print(filtered_df.columns, len(filtered_df.columns))
40/4:
# Now we can create a Dataloader
runner = DataLoaderCreator('../data/filtered_engineered_data.csv',
                               batch_size=1032)

loaders = runner.create_dataloaders(test_size=0.4,
                                    val_size=0.4, label='label',
                                    save_path='../data')

train_data = torch.load('../data/train_loader.pth')
test_data = torch.load('../data/test_loader.pth')

for inputs, labels in train_data:
    print(inputs.shape, labels.shape)  # Just for checking
    break
40/5:
# Now we can train the model! 
model = SimpleNN(n_features=17, len(filtered_df.label.unique()))
trainer = ModelTrainer(model, '../data',
                       learning_rate=0.001, epochs=50)
trainer.train(accuracy_threshold=0.6)
test_loss, test_accuracy = trainer.evaluate_model(trainer.test_loader)
print('the Model achieved {} in testing accuracy'.format(test_accuracy))

trainer.get_time()
40/6:
# Now we can train the model! 
model = SimpleNN(n_features=17, n_classes=len(filtered_df.label.unique()))
trainer = ModelTrainer(model, '../data',
                       learning_rate=0.001, epochs=50)
trainer.train(accuracy_threshold=0.6)
test_loss, test_accuracy = trainer.evaluate_model(trainer.test_loader)
print('the Model achieved {} in testing accuracy'.format(test_accuracy))

trainer.get_time()
42/1:
import sys
sys.path.append('../')
from pipeline.coinbase_fetcher import CoinbaseDataFetcher
from pipeline.features import FeatureEngineer
from pipeline.create_dataloader import DataLoaderCreator
from pipeline.train import ModelTrainer
from models.simple_model import SimpleNN, EnhancedNN, resnet18

from datetime import datetime, timedelta
import torch
42/2:
# DO we want new data?
fetch = False

# First lets pull the data
fetcher = CoinbaseDataFetcher('', '')
pair = 'BTC-USD'
years = 10
start_time = datetime.utcnow() - timedelta(days=365 * years)  # Start from one year ago
end_time = datetime.utcnow()
#300-> 5-minute, 900-> 15-minute, 3600-> 1 hour
granularity = 900 

# The filename where the CSV will be saved
filename = '10_year_long_historical_data.csv'

# Fetch and save data as CSV
if fetch:
    data = fetcher.get_data_as_csv(pair, start_time, end_time, granularity, filename)
    print('Number of samples: {}'.format(len(data)))
42/3:
# Now lets shape those features
file = '../data/BTC/USD/BTC_USD_60min_20131202-20231130.csv' # or a DataFrame
#file = '../pipeline/data/BTC/USD/BTC_USD_5min_20131203-20231201.csv'
engineer = FeatureEngineer(file)
processed_data = engineer.get_processed_data(save=True) # we can turn save off if we plan to use filtered data

filtered_df = engineer.select_features_based_on_correlation(label='label')
print(filtered_df.columns, len(filtered_df.columns))
42/4:
# Now we can create a Dataloader
runner = DataLoaderCreator('../data/filtered_engineered_data.csv',
                               batch_size=1032)

loaders = runner.create_dataloaders(test_size=0.4,
                                    val_size=0.4, label='label',
                                    save_path='../data')

train_data = torch.load('../data/train_loader.pth')
test_data = torch.load('../data/test_loader.pth')

for inputs, labels in train_data:
    print(inputs.shape, labels.shape)  # Just for checking
    break
42/5:
# Now we can train the model! 
model = SimpleNN(n_features=17, n_classes=len(filtered_df.label.unique()), device='cpu')
trainer = ModelTrainer(model, '../data',
                       learning_rate=0.001, epochs=50)
trainer.train(accuracy_threshold=0.6)
test_loss, test_accuracy = trainer.evaluate_model(trainer.test_loader)
print('the Model achieved {} in testing accuracy'.format(test_accuracy))

trainer.get_time()
42/6:
# Now we can train the model! 
model = SimpleNN(n_features=17, n_classes=len(filtered_df.label.unique()))
trainer = ModelTrainer(model, '../data',
                       learning_rate=0.001, epochs=50, device='cpu')
trainer.train(accuracy_threshold=0.6)
test_loss, test_accuracy = trainer.evaluate_model(trainer.test_loader)
print('the Model achieved {} in testing accuracy'.format(test_accuracy))

trainer.get_time()
44/1:
import sys
sys.path.append('../')
from pipeline.coinbase_fetcher import CoinbaseDataFetcher
from pipeline.features import FeatureEngineer
from pipeline.create_dataloader import DataLoaderCreator
from pipeline.train import ModelTrainer
from models.simple_model import SimpleNN, EnhancedNN, resnet18

from datetime import datetime, timedelta
import torch
44/2:
# DO we want new data?
fetch = False

# First lets pull the data
fetcher = CoinbaseDataFetcher('', '')
pair = 'BTC-USD'
years = 10
start_time = datetime.utcnow() - timedelta(days=365 * years)  # Start from one year ago
end_time = datetime.utcnow()
#300-> 5-minute, 900-> 15-minute, 3600-> 1 hour
granularity = 900 

# The filename where the CSV will be saved
filename = '10_year_long_historical_data.csv'

# Fetch and save data as CSV
if fetch:
    data = fetcher.get_data_as_csv(pair, start_time, end_time, granularity, filename)
    print('Number of samples: {}'.format(len(data)))
44/3:
# Now lets shape those features
file = '../data/BTC/USD/BTC_USD_60min_20131202-20231130.csv' # or a DataFrame
#file = '../pipeline/data/BTC/USD/BTC_USD_5min_20131203-20231201.csv'
engineer = FeatureEngineer(file)
processed_data = engineer.get_processed_data(save=True) # we can turn save off if we plan to use filtered data

filtered_df = engineer.select_features_based_on_correlation(label='label')
print(filtered_df.columns, len(filtered_df.columns))
44/4:
# Now we can create a Dataloader
runner = DataLoaderCreator('../data/filtered_engineered_data.csv',
                               batch_size=1032)

loaders = runner.create_dataloaders(test_size=0.4,
                                    val_size=0.4, label='label',
                                    save_path='../data')

train_data = torch.load('../data/train_loader.pth')
test_data = torch.load('../data/test_loader.pth')

for inputs, labels in train_data:
    print(inputs.shape, labels.shape)  # Just for checking
    break
44/5:
# Now we can train the model! 
model = SimpleNN(n_features=17, n_classes=len(filtered_df.label.unique()))
trainer = ModelTrainer(model, '../data',
                       learning_rate=0.001, epochs=50, device='cpu')
trainer.train(accuracy_threshold=0.6)
test_loss, test_accuracy = trainer.evaluate_model(trainer.test_loader)
print('the Model achieved {} in testing accuracy'.format(test_accuracy))

trainer.get_time()
46/1:
import sys
sys.path.append('../')
from pipeline.coinbase_fetcher import CoinbaseDataFetcher
from pipeline.features import FeatureEngineer
from pipeline.create_dataloader import DataLoaderCreator
from pipeline.train import ModelTrainer
from models.simple_model import SimpleNN, EnhancedNN, resnet18

from datetime import datetime, timedelta
import torch
46/2:
# DO we want new data?
fetch = False

# First lets pull the data
fetcher = CoinbaseDataFetcher('', '')
pair = 'BTC-USD'
years = 10
start_time = datetime.utcnow() - timedelta(days=365 * years)  # Start from one year ago
end_time = datetime.utcnow()
#300-> 5-minute, 900-> 15-minute, 3600-> 1 hour
granularity = 900 

# The filename where the CSV will be saved
filename = '10_year_long_historical_data.csv'

# Fetch and save data as CSV
if fetch:
    data = fetcher.get_data_as_csv(pair, start_time, end_time, granularity, filename)
    print('Number of samples: {}'.format(len(data)))
46/3:
# Now lets shape those features
file = '../data/BTC/USD/BTC_USD_60min_20131202-20231130.csv' # or a DataFrame
#file = '../pipeline/data/BTC/USD/BTC_USD_5min_20131203-20231201.csv'
engineer = FeatureEngineer(file)
processed_data = engineer.get_processed_data(save=True) # we can turn save off if we plan to use filtered data

filtered_df = engineer.select_features_based_on_correlation(label='label')
print(filtered_df.columns, len(filtered_df.columns))
46/4:
# Now we can create a Dataloader
runner = DataLoaderCreator('../data/filtered_engineered_data.csv',
                               batch_size=1032)

loaders = runner.create_dataloaders(test_size=0.4,
                                    val_size=0.4, label='label',
                                    save_path='../data')

train_data = torch.load('../data/train_loader.pth')
test_data = torch.load('../data/test_loader.pth')

for inputs, labels in train_data:
    print(inputs.shape, labels.shape)  # Just for checking
    break
46/5:
# Now we can train the model! 
model = SimpleNN(n_features=17, n_classes=len(filtered_df.label.unique()))
trainer = ModelTrainer(model, '../data',
                       learning_rate=0.001, epochs=50, device='cpu')
trainer.train(accuracy_threshold=0.6)
test_loss, test_accuracy = trainer.evaluate_model(trainer.test_loader)
print('the Model achieved {} in testing accuracy'.format(test_accuracy))

trainer.get_time()
47/1:
import sys
sys.path.append('../')
from pipeline.coinbase_fetcher import CoinbaseDataFetcher
from pipeline.features import FeatureEngineer
from pipeline.create_dataloader import DataLoaderCreator
from pipeline.train import ModelTrainer
from models.simple_model import SimpleNN, EnhancedNN, resnet18

from datetime import datetime, timedelta
import torch
47/2:
# DO we want new data?
fetch = False

# First lets pull the data
fetcher = CoinbaseDataFetcher('', '')
pair = 'BTC-USD'
years = 10
start_time = datetime.utcnow() - timedelta(days=365 * years)  # Start from one year ago
end_time = datetime.utcnow()
#300-> 5-minute, 900-> 15-minute, 3600-> 1 hour
granularity = 900 

# The filename where the CSV will be saved
filename = '10_year_long_historical_data.csv'

# Fetch and save data as CSV
if fetch:
    data = fetcher.get_data_as_csv(pair, start_time, end_time, granularity, filename)
    print('Number of samples: {}'.format(len(data)))
47/3:
# Now lets shape those features
file = '../data/BTC/USD/BTC_USD_60min_20131202-20231130.csv' # or a DataFrame
#file = '../pipeline/data/BTC/USD/BTC_USD_5min_20131203-20231201.csv'
engineer = FeatureEngineer(file)
processed_data = engineer.get_processed_data(save=True) # we can turn save off if we plan to use filtered data

filtered_df = engineer.select_features_based_on_correlation(label='label')
print(filtered_df.columns, len(filtered_df.columns))
47/4:
# Now we can create a Dataloader
runner = DataLoaderCreator('../data/filtered_engineered_data.csv',
                               batch_size=1032)

loaders = runner.create_dataloaders(test_size=0.4,
                                    val_size=0.4, label='label',
                                    save_path='../data')

train_data = torch.load('../data/train_loader.pth')
test_data = torch.load('../data/test_loader.pth')

for inputs, labels in train_data:
    print(inputs.shape, labels.shape)  # Just for checking
    break
47/5:
# Now we can train the model! 
model = SimpleNN(n_features=17, n_classes=len(filtered_df.label.unique()))
trainer = ModelTrainer(model, '../data',
                       learning_rate=0.001, epochs=50, device='cpu')
trainer.train(accuracy_threshold=0.6)
test_loss, test_accuracy = trainer.evaluate_model(trainer.test_loader)
print('the Model achieved {} in testing accuracy'.format(test_accuracy))

trainer.get_time()
49/1:
import sys
sys.path.append('../')
from pipeline.coinbase_fetcher import CoinbaseDataFetcher
from pipeline.features import FeatureEngineer
from pipeline.create_dataloader import DataLoaderCreator
from pipeline.train import ModelTrainer
from models.simple_model import SimpleNN, EnhancedNN, resnet18

from datetime import datetime, timedelta
import torch
50/1:
import sys
sys.path.append('../')
from pipeline.coinbase_fetcher import CoinbaseDataFetcher
from pipeline.features import FeatureEngineer
from pipeline.create_dataloader import DataLoaderCreator
from pipeline.train import ModelTrainer
from models.simple_model import SimpleNN, EnhancedNN, resnet18

from datetime import datetime, timedelta
import torch
52/1:
import sys
sys.path.append('../')
from pipeline.coinbase_fetcher import CoinbaseDataFetcher
from pipeline.features import FeatureEngineer
from pipeline.create_dataloader import DataLoaderCreator
from pipeline.train import ModelTrainer
from models.simple_model import SimpleNN, EnhancedNN, resnet18

from datetime import datetime, timedelta
import torch
52/2:
# DO we want new data?
fetch = False

# First lets pull the data
fetcher = CoinbaseDataFetcher('', '')
pair = 'BTC-USD'
years = 10
start_time = datetime.utcnow() - timedelta(days=365 * years)  # Start from one year ago
end_time = datetime.utcnow()
#300-> 5-minute, 900-> 15-minute, 3600-> 1 hour
granularity = 900 

# The filename where the CSV will be saved
filename = '10_year_long_historical_data.csv'

# Fetch and save data as CSV
if fetch:
    data = fetcher.get_data_as_csv(pair, start_time, end_time, granularity, filename)
    print('Number of samples: {}'.format(len(data)))
52/3:
# Now lets shape those features
file = '../data/BTC/USD/BTC_USD_60min_20131202-20231130.csv' # or a DataFrame
#file = '../pipeline/data/BTC/USD/BTC_USD_5min_20131203-20231201.csv'
engineer = FeatureEngineer(file)
processed_data = engineer.get_processed_data(save=True) # we can turn save off if we plan to use filtered data

filtered_df = engineer.select_features_based_on_correlation(label='label')
print(filtered_df.columns, len(filtered_df.columns))
52/4:
# Now we can create a Dataloader
runner = DataLoaderCreator('../data/filtered_engineered_data.csv',
                               batch_size=1032)

loaders = runner.create_dataloaders(test_size=0.4,
                                    val_size=0.4, label='label',
                                    save_path='../data')

train_data = torch.load('../data/train_loader.pth')
test_data = torch.load('../data/test_loader.pth')

for inputs, labels in train_data:
    print(inputs.shape, labels.shape)  # Just for checking
    break
52/5:
# Now we can train the model! 
model = SimpleNN(n_features=17, n_classes=len(filtered_df.label.unique()))
trainer = ModelTrainer(model, '../data',
                       learning_rate=0.001, epochs=50, device='cpu')
trainer.train(accuracy_threshold=0.6)
test_loss, test_accuracy = trainer.evaluate_model(trainer.test_loader)
print('the Model achieved {} in testing accuracy'.format(test_accuracy))

trainer.get_time()
54/1:
import sys
sys.path.append('../')
from pipeline.coinbase_fetcher import CoinbaseDataFetcher
from pipeline.features import FeatureEngineer
from pipeline.create_dataloader import DataLoaderCreator
from pipeline.train import ModelTrainer
from models.simple_model import SimpleNN, EnhancedNN, resnet18

from datetime import datetime, timedelta
import torch
54/2:
# DO we want new data?
fetch = False

# First lets pull the data
fetcher = CoinbaseDataFetcher('', '')
pair = 'BTC-USD'
years = 10
start_time = datetime.utcnow() - timedelta(days=365 * years)  # Start from one year ago
end_time = datetime.utcnow()
#300-> 5-minute, 900-> 15-minute, 3600-> 1 hour
granularity = 900 

# The filename where the CSV will be saved
filename = '10_year_long_historical_data.csv'

# Fetch and save data as CSV
if fetch:
    data = fetcher.get_data_as_csv(pair, start_time, end_time, granularity, filename)
    print('Number of samples: {}'.format(len(data)))
54/3:
# Now lets shape those features
file = '../data/BTC/USD/BTC_USD_60min_20131202-20231130.csv' # or a DataFrame
#file = '../pipeline/data/BTC/USD/BTC_USD_5min_20131203-20231201.csv'
engineer = FeatureEngineer(file)
processed_data = engineer.get_processed_data(save=True) # we can turn save off if we plan to use filtered data

filtered_df = engineer.select_features_based_on_correlation(label='label')
print(filtered_df.columns, len(filtered_df.columns))
54/4:
# Now we can create a Dataloader
runner = DataLoaderCreator('../data/filtered_engineered_data.csv',
                               batch_size=1032)

loaders = runner.create_dataloaders(test_size=0.4,
                                    val_size=0.4, label='label',
                                    save_path='../data')

train_data = torch.load('../data/train_loader.pth')
test_data = torch.load('../data/test_loader.pth')

for inputs, labels in train_data:
    print(inputs.shape, labels.shape)  # Just for checking
    break
54/5:
# Now we can train the model! 
model = SimpleNN(n_features=17, n_classes=len(filtered_df.label.unique()))
trainer = ModelTrainer(model, '../data',
                       learning_rate=0.001, epochs=50, device='cpu')
trainer.train(accuracy_threshold=0.6)
test_loss, test_accuracy = trainer.evaluate_model(trainer.test_loader)
print('the Model achieved {} in testing accuracy'.format(test_accuracy))

trainer.get_time()
56/1:
import sys
sys.path.append('../')
from pipeline.coinbase_fetcher import CoinbaseDataFetcher
from pipeline.features import FeatureEngineer
from pipeline.create_dataloader import DataLoaderCreator
from pipeline.train import ModelTrainer
from models.simple_model import SimpleNN, EnhancedNN, resnet18

from datetime import datetime, timedelta
import torch
56/2:
# DO we want new data?
fetch = False

# First lets pull the data
fetcher = CoinbaseDataFetcher('', '')
pair = 'BTC-USD'
years = 10
start_time = datetime.utcnow() - timedelta(days=365 * years)  # Start from one year ago
end_time = datetime.utcnow()
#300-> 5-minute, 900-> 15-minute, 3600-> 1 hour
granularity = 900 

# The filename where the CSV will be saved
filename = '10_year_long_historical_data.csv'

# Fetch and save data as CSV
if fetch:
    data = fetcher.get_data_as_csv(pair, start_time, end_time, granularity, filename)
    print('Number of samples: {}'.format(len(data)))
56/3:
# Now lets shape those features
file = '../data/BTC/USD/BTC_USD_60min_20131202-20231130.csv' # or a DataFrame
#file = '../pipeline/data/BTC/USD/BTC_USD_5min_20131203-20231201.csv'
engineer = FeatureEngineer(file)
processed_data = engineer.get_processed_data(save=True) # we can turn save off if we plan to use filtered data

filtered_df = engineer.select_features_based_on_correlation(label='label')
print(filtered_df.columns, len(filtered_df.columns))
56/4:
# Now we can create a Dataloader
runner = DataLoaderCreator('../data/filtered_engineered_data.csv',
                               batch_size=1032)

loaders = runner.create_dataloaders(test_size=0.4,
                                    val_size=0.4, label='label',
                                    save_path='../data')

train_data = torch.load('../data/train_loader.pth')
test_data = torch.load('../data/test_loader.pth')

for inputs, labels in train_data:
    print(inputs.shape, labels.shape)  # Just for checking
    break
56/5:
# Now we can train the model! 
model = SimpleNN(n_features=17, n_classes=len(filtered_df.label.unique()))
trainer = ModelTrainer(model, '../data',
                       learning_rate=0.001, epochs=50, device='cpu')
trainer.train(accuracy_threshold=0.6)
test_loss, test_accuracy = trainer.evaluate_model(trainer.test_loader)
print('the Model achieved {} in testing accuracy'.format(test_accuracy))

trainer.get_time()
56/6:
# Now we can train the model! 
model = SimpleNN(n_features=17, n_classes=len(filtered_df.label.unique()))
trainer = ModelTrainer(model, '../data',
                       learning_rate=0.001, epochs=50,) # device='cpu')
trainer.train(accuracy_threshold=0.6)
test_loss, test_accuracy = trainer.evaluate_model(trainer.test_loader)
print('the Model achieved {} in testing accuracy'.format(test_accuracy))

trainer.get_time()
56/7:
# Now we can train the model! 
model = SimpleNN(n_features=17, n_classes=len(filtered_df.label.unique()))
trainer = ModelTrainer(model, '../data',
                       learning_rate=0.001, epochs=50, device='cpu')
trainer.train(accuracy_threshold=0.6)
test_loss, test_accuracy = trainer.evaluate_model(trainer.test_loader)
print('the Model achieved {} in testing accuracy'.format(test_accuracy))

trainer.get_time()
58/1:
import sys
sys.path.append('../')
from pipeline.coinbase_fetcher import CoinbaseDataFetcher
from pipeline.features import FeatureEngineer
from pipeline.create_dataloader import DataLoaderCreator
from pipeline.train import ModelTrainer
from models.simple_model import SimpleNN, EnhancedNN, resnet18

from datetime import datetime, timedelta
import torch
58/2:
# DO we want new data?
fetch = False

# First lets pull the data
fetcher = CoinbaseDataFetcher('', '')
pair = 'BTC-USD'
years = 10
start_time = datetime.utcnow() - timedelta(days=365 * years)  # Start from one year ago
end_time = datetime.utcnow()
#300-> 5-minute, 900-> 15-minute, 3600-> 1 hour
granularity = 900 

# The filename where the CSV will be saved
filename = '10_year_long_historical_data.csv'

# Fetch and save data as CSV
if fetch:
    data = fetcher.get_data_as_csv(pair, start_time, end_time, granularity, filename)
    print('Number of samples: {}'.format(len(data)))
58/3:
# Now lets shape those features
file = '../data/BTC/USD/BTC_USD_60min_20131202-20231130.csv' # or a DataFrame
#file = '../pipeline/data/BTC/USD/BTC_USD_5min_20131203-20231201.csv'
engineer = FeatureEngineer(file)
processed_data = engineer.get_processed_data(save=True) # we can turn save off if we plan to use filtered data

filtered_df = engineer.select_features_based_on_correlation(label='label')
print(filtered_df.columns, len(filtered_df.columns))
58/4:
# Now we can create a Dataloader
runner = DataLoaderCreator('../data/filtered_engineered_data.csv',
                               batch_size=1032)

loaders = runner.create_dataloaders(test_size=0.4,
                                    val_size=0.4, label='label',
                                    save_path='../data')

train_data = torch.load('../data/train_loader.pth')
test_data = torch.load('../data/test_loader.pth')

for inputs, labels in train_data:
    print(inputs.shape, labels.shape)  # Just for checking
    break
58/5:
# Now we can train the model! 
model = SimpleNN(n_features=17, n_classes=len(filtered_df.label.unique()))
trainer = ModelTrainer(model, '../data',
                       learning_rate=0.001, epochs=50, device='cpu')
trainer.train(accuracy_threshold=0.6)
test_loss, test_accuracy = trainer.evaluate_model(trainer.test_loader)
print('the Model achieved {} in testing accuracy'.format(test_accuracy))

trainer.get_time()
59/1:
import sys
sys.path.append('../')
from pipeline.coinbase_fetcher import CoinbaseDataFetcher
from pipeline.features import FeatureEngineer
from pipeline.create_dataloader import DataLoaderCreator
from pipeline.train import ModelTrainer
from models.simple_model import SimpleNN, EnhancedNN, resnet18

from datetime import datetime, timedelta
import torch
59/2:
# DO we want new data?
fetch = False

# First lets pull the data
fetcher = CoinbaseDataFetcher('', '')
pair = 'BTC-USD'
years = 10
start_time = datetime.utcnow() - timedelta(days=365 * years)  # Start from one year ago
end_time = datetime.utcnow()
#300-> 5-minute, 900-> 15-minute, 3600-> 1 hour
granularity = 900 

# The filename where the CSV will be saved
filename = '10_year_long_historical_data.csv'

# Fetch and save data as CSV
if fetch:
    data = fetcher.get_data_as_csv(pair, start_time, end_time, granularity, filename)
    print('Number of samples: {}'.format(len(data)))
59/3:
# Now lets shape those features
file = '../data/BTC/USD/BTC_USD_60min_20131202-20231130.csv' # or a DataFrame
#file = '../pipeline/data/BTC/USD/BTC_USD_5min_20131203-20231201.csv'
engineer = FeatureEngineer(file)
processed_data = engineer.get_processed_data(save=True) # we can turn save off if we plan to use filtered data

filtered_df = engineer.select_features_based_on_correlation(label='label')
print(filtered_df.columns, len(filtered_df.columns))
59/4:
# Now we can create a Dataloader
runner = DataLoaderCreator('../data/filtered_engineered_data.csv',
                               batch_size=1032)

loaders = runner.create_dataloaders(test_size=0.4,
                                    val_size=0.4, label='label',
                                    save_path='../data')

train_data = torch.load('../data/train_loader.pth')
test_data = torch.load('../data/test_loader.pth')

for inputs, labels in train_data:
    print(inputs.shape, labels.shape)  # Just for checking
    break
59/5:
# Now we can train the model! 
model = SimpleNN(n_features=17, n_classes=len(filtered_df.label.unique()))
trainer = ModelTrainer(model, '../data',
                       learning_rate=0.001, epochs=50, device='cpu')
trainer.train(accuracy_threshold=0.6)
test_loss, test_accuracy = trainer.evaluate_model(trainer.test_loader)
print('the Model achieved {} in testing accuracy'.format(test_accuracy))

trainer.get_time()
59/6:
# Now we can train the model! 
model = SimpleNN(n_features=17, n_classes=len(filtered_df.label.unique()))
print('number of classes: {}'.format(len(filtered_df.label.unique())
trainer = ModelTrainer(model, '../data',
                       learning_rate=0.001, epochs=50, device='cpu')
trainer.train(accuracy_threshold=0.6)
test_loss, test_accuracy = trainer.evaluate_model(trainer.test_loader)
print('the Model achieved {} in testing accuracy'.format(test_accuracy))

trainer.get_time()
59/7:
# Now we can train the model! 
model = SimpleNN(n_features=17, n_classes=len(filtered_df.label.unique()))
print('number of classes: {}'.format(len(filtered_df.label.unique()))
trainer = ModelTrainer(model, '../data',
                       learning_rate=0.001, epochs=50, device='cpu')
trainer.train(accuracy_threshold=0.6)
test_loss, test_accuracy = trainer.evaluate_model(trainer.test_loader)
print('the Model achieved {} in testing accuracy'.format(test_accuracy))

trainer.get_time()
59/8:
# Now we can train the model! 
model = SimpleNN(n_features=17, n_classes=len(filtered_df.label.unique()))
print('number of classes: {}'.format(len(filtered_df.label.unique())))
trainer = ModelTrainer(model, '../data',
                       learning_rate=0.001, epochs=50, device='cpu')
trainer.train(accuracy_threshold=0.6)
test_loss, test_accuracy = trainer.evaluate_model(trainer.test_loader)
print('the Model achieved {} in testing accuracy'.format(test_accuracy))

trainer.get_time()
64/1:
import sys
sys.path.append('../')
from pipeline.coinbase_fetcher import CoinbaseDataFetcher
from pipeline.features import FeatureEngineer
from pipeline.create_dataloader import DataLoaderCreator
from pipeline.train import ModelTrainer
from models.simple_model import SimpleNN, EnhancedNN, resnet18

from datetime import datetime, timedelta
import torch
64/2:
# DO we want new data?
fetch = False

# First lets pull the data
fetcher = CoinbaseDataFetcher('', '')
pair = 'BTC-USD'
years = 10
start_time = datetime.utcnow() - timedelta(days=365 * years)  # Start from one year ago
end_time = datetime.utcnow()
#300-> 5-minute, 900-> 15-minute, 3600-> 1 hour
granularity = 900 

# The filename where the CSV will be saved
filename = '10_year_long_historical_data.csv'

# Fetch and save data as CSV
if fetch:
    data = fetcher.get_data_as_csv(pair, start_time, end_time, granularity, filename)
    print('Number of samples: {}'.format(len(data)))
64/3:
# Now lets shape those features
file = '../data/BTC/USD/BTC_USD_60min_20131202-20231130.csv' # or a DataFrame
#file = '../pipeline/data/BTC/USD/BTC_USD_5min_20131203-20231201.csv'
engineer = FeatureEngineer(file)
processed_data = engineer.get_processed_data(save=True) # we can turn save off if we plan to use filtered data

filtered_df = engineer.select_features_based_on_correlation(label='label')
print(filtered_df.columns, len(filtered_df.columns))
64/4:
# Now we can create a Dataloader
runner = DataLoaderCreator('../data/filtered_engineered_data.csv',
                               batch_size=1032)

loaders = runner.create_dataloaders(test_size=0.4,
                                    val_size=0.4, label='label',
                                    save_path='../data')

train_data = torch.load('../data/train_loader.pth')
test_data = torch.load('../data/test_loader.pth')

for inputs, labels in train_data:
    print(inputs.shape, labels.shape)  # Just for checking
    break
64/5:
# Now we can train the model! 
model = SimpleNN(n_features=17, n_classes=len(filtered_df.label.unique()))
print('number of classes: {}'.format(len(filtered_df.label.unique())))
trainer = ModelTrainer(model, '../data',
                       learning_rate=0.001, epochs=50, device='cpu')
trainer.train(accuracy_threshold=0.6)
test_loss, test_accuracy = trainer.evaluate_model(trainer.test_loader)
print('the Model achieved {} in testing accuracy'.format(test_accuracy))

trainer.get_time()
64/6:
# Now we can train the model! 
model = SimpleNN(n_features=17, n_classes=len(filtered_df.label.unique()))
print('number of classes: {}'.format(len(filtered_df.label.unique())))
trainer = ModelTrainer(model, '../data',
                       learning_rate=0.001, epochs=500, device='cpu')
trainer.train(accuracy_threshold=0.6)
test_loss, test_accuracy = trainer.evaluate_model(trainer.test_loader)
print('the Model achieved {} in testing accuracy'.format(test_accuracy))

trainer.get_time()
64/7:
# Now we can train the model! 
model = SimpleNN(n_features=17, n_classes=len(filtered_df.label.unique()))
print('number of classes: {}'.format(len(filtered_df.label.unique())))
trainer = ModelTrainer(model, '../data',
                       learning_rate=0.0001, epochs=500)
trainer.train(accuracy_threshold=0.6)
test_loss, test_accuracy = trainer.evaluate_model(trainer.test_loader)
print('the Model achieved {} in testing accuracy'.format(test_accuracy))

trainer.get_time()
64/8:
test_loss, test_accuracy = trainer.evaluate_model(trainer.test_loader)
print('the Model achieved {} in testing accuracy'.format(test_accuracy))

trainer.get_time()
65/1:
import sys
sys.path.append('../')
from pipeline.coinbase_fetcher import CoinbaseDataFetcher
from pipeline.features import FeatureEngineer
from pipeline.create_dataloader import DataLoaderCreator
from pipeline.train import ModelTrainer
from models.simple_model import SimpleNN, EnhancedNN, resnet18

from datetime import datetime, timedelta
import torch
65/2:
# DO we want new data?
fetch = False

# First lets pull the data
fetcher = CoinbaseDataFetcher('', '')
pair = 'BTC-USD'
years = 10
start_time = datetime.utcnow() - timedelta(days=365 * years)  # Start from one year ago
end_time = datetime.utcnow()
#300-> 5-minute, 900-> 15-minute, 3600-> 1 hour
granularity = 900 

# The filename where the CSV will be saved
filename = '10_year_long_historical_data.csv'

# Fetch and save data as CSV
if fetch:
    data = fetcher.get_data_as_csv(pair, start_time, end_time, granularity, filename)
    print('Number of samples: {}'.format(len(data)))
65/3:
# Now lets shape those features
file = '../data/BTC/USD/BTC_USD_60min_20131202-20231130.csv' # or a DataFrame
#file = '../pipeline/data/BTC/USD/BTC_USD_5min_20131203-20231201.csv'
engineer = FeatureEngineer(file)
processed_data = engineer.get_processed_data(save=True) # we can turn save off if we plan to use filtered data

filtered_df = engineer.select_features_based_on_correlation(label='label')
print(filtered_df.columns, len(filtered_df.columns))
65/4:
# Now we can create a Dataloader
runner = DataLoaderCreator('../data/filtered_engineered_data.csv',
                               batch_size=2048)

loaders = runner.create_dataloaders(test_size=0.4,
                                    val_size=0.4, label='label',
                                    save_path='../data')

train_data = torch.load('../data/train_loader.pth')
test_data = torch.load('../data/test_loader.pth')

for inputs, labels in train_data:
    print(inputs.shape, labels.shape)  # Just for checking
    break
65/5:
# Now we can train the model! 
model = EnhancedNN(n_features=17, n_classes=len(filtered_df.label.unique()))
print('number of classes: {}'.format(len(filtered_df.label.unique())))
trainer = ModelTrainer(model, '../data',
                       learning_rate=0.0001, epochs=100)
trainer.train(accuracy_threshold=0.6)
65/6:
test_loss, test_accuracy = trainer.evaluate_model(trainer.test_loader)
print('the Model achieved {} in testing accuracy'.format(test_accuracy))
trainer.get_time()
65/7:
c1 = filtered_df[filtered_df.label == 0]
c1 = filtered_df[filtered_df.label == 0]
65/8:
ls = []
for i in range(0, 5):
    temp = filtered_df[filtered_df.label == i]
    ls.append(temp)
    print('For the class {} we have {} number of rows or {}% of the entire dataset'.format(i, len(temp), len(temp)/len(filtered_df))
65/9:
ls = []
for i in range(0, 5):
    temp = filtered_df[filtered_df.label == i]
    ls.append(temp)
    print('For the class {} we have {} number of rows or {}% of the entire dataset'.format(i, len(temp), len(temp)/len(filtered_df)))
66/1:
import sys
sys.path.append('../')
from pipeline.coinbase_fetcher import CoinbaseDataFetcher
from pipeline.features import FeatureEngineer
from pipeline.create_dataloader import DataLoaderCreator
from pipeline.train import ModelTrainer
from models.simple_model import SimpleNN, EnhancedNN, resnet18

from datetime import datetime, timedelta
import torch
66/2:
# DO we want new data?
fetch = False

# First lets pull the data
fetcher = CoinbaseDataFetcher('', '')
pair = 'BTC-USD'
years = 10
start_time = datetime.utcnow() - timedelta(days=365 * years)  # Start from one year ago
end_time = datetime.utcnow()
#300-> 5-minute, 900-> 15-minute, 3600-> 1 hour
granularity = 900 

# The filename where the CSV will be saved
filename = '10_year_long_historical_data.csv'

# Fetch and save data as CSV
if fetch:
    data = fetcher.get_data_as_csv(pair, start_time, end_time, granularity, filename)
    print('Number of samples: {}'.format(len(data)))
66/3:
# Now lets shape those features
file = '../data/BTC/USD/BTC_USD_60min_20131202-20231130.csv' # or a DataFrame
#file = '../pipeline/data/BTC/USD/BTC_USD_5min_20131203-20231201.csv'
engineer = FeatureEngineer(file)
processed_data = engineer.get_processed_data(save=True) # we can turn save off if we plan to use filtered data

filtered_df = engineer.select_features_based_on_correlation(label='label')
print(filtered_df.columns, len(filtered_df.columns))
66/4:
ls = []
for i in range(0, 5):
    temp = filtered_df[filtered_df.label == i]
    ls.append(temp)
    print('For the class {} we have {} number of rows or {}% of the entire dataset'.format(i, len(temp), len(temp)/len(filtered_df)))
66/5:
# Now we can create a Dataloader
runner = DataLoaderCreator('../data/filtered_engineered_data.csv',
                               batch_size=2048)

loaders = runner.create_dataloaders(test_size=0.4,
                                    val_size=0.4, label='label',
                                    save_path='../data')

train_data = torch.load('../data/train_loader.pth')
test_data = torch.load('../data/test_loader.pth')

for inputs, labels in train_data:
    print(inputs.shape, labels.shape)  # Just for checking
    break
66/6:
# Now we can train the model! 
model = EnhancedNN(n_features=17, n_classes=len(filtered_df.label.unique()))
print('number of classes: {}'.format(len(filtered_df.label.unique())))
trainer = ModelTrainer(model, '../data',
                       learning_rate=0.0001, epochs=100)
trainer.train(accuracy_threshold=0.6)
66/7:
test_loss, test_accuracy = trainer.evaluate_model(trainer.test_loader)
print('the Model achieved {} in testing accuracy'.format(test_accuracy))
trainer.get_time()
66/8:
# Now we can train the model! 
model = EnhancedNN(n_features=len(filtered_df.columns), n_classes=len(filtered_df.label.unique()))
print('number of classes: {}'.format(len(filtered_df.label.unique())))
trainer = ModelTrainer(model, '../data',
                       learning_rate=0.0001, epochs=100)
trainer.train(accuracy_threshold=0.6)
trainer.get_time()
67/1:
import sys
sys.path.append('../')
from pipeline.coinbase_fetcher import CoinbaseDataFetcher
from pipeline.features import FeatureEngineer
from pipeline.create_dataloader import DataLoaderCreator
from pipeline.train import ModelTrainer
from models.simple_model import SimpleNN, EnhancedNN, resnet18

from datetime import datetime, timedelta
import torch
67/2:
# DO we want new data?
fetch = False

# First lets pull the data
fetcher = CoinbaseDataFetcher('', '')
pair = 'BTC-USD'
years = 10
start_time = datetime.utcnow() - timedelta(days=365 * years)  # Start from one year ago
end_time = datetime.utcnow()
#300-> 5-minute, 900-> 15-minute, 3600-> 1 hour
granularity = 900 

# The filename where the CSV will be saved
filename = '10_year_long_historical_data.csv'

# Fetch and save data as CSV
if fetch:
    data = fetcher.get_data_as_csv(pair, start_time, end_time, granularity, filename)
    print('Number of samples: {}'.format(len(data)))
67/3:
# Now lets shape those features
file = '../data/BTC/USD/BTC_USD_60min_20131202-20231130.csv' # or a DataFrame
#file = '../pipeline/data/BTC/USD/BTC_USD_5min_20131203-20231201.csv'
engineer = FeatureEngineer(file)
processed_data = engineer.get_processed_data(save=True) # we can turn save off if we plan to use filtered data

filtered_df = engineer.select_features_based_on_correlation(label='label')
print(filtered_df.columns, len(filtered_df.columns))
67/4:
ls = []
for i in range(0, 5):
    temp = filtered_df[filtered_df.label == i]
    ls.append(temp)
    print('For the class {} we have {} number of rows or {}% of the entire dataset'.format(i, len(temp), len(temp)/len(filtered_df)))
67/5:
# Now we can create a Dataloader
runner = DataLoaderCreator('../data/filtered_engineered_data.csv',
                               batch_size=2048)

loaders = runner.create_dataloaders(test_size=0.4,
                                    val_size=0.4, label='label',
                                    save_path='../data')

train_data = torch.load('../data/train_loader.pth')
test_data = torch.load('../data/test_loader.pth')

for inputs, labels in train_data:
    print(inputs.shape, labels.shape)  # Just for checking
    break
67/6:
# Now we can train the model! 
model = EnhancedNN(n_features=len(filtered_df.columns), n_classes=len(filtered_df.label.unique()))
print('number of classes: {}'.format(len(filtered_df.label.unique())))
trainer = ModelTrainer(model, '../data',
                       learning_rate=0.0001, epochs=100)
trainer.train(accuracy_threshold=0.6)
trainer.get_time()
67/7:
test_loss, test_accuracy = trainer.evaluate_model(trainer.test_loader)
print('the Model achieved {} in testing accuracy'.format(test_accuracy))
trainer.get_time()
67/8:
test_loss, test_accuracy = trainer.evaluate_model(trainer.test_loader)
print('the Model achieved {} in testing accuracy'.format(test_accuracy))
trainer.get_time()
67/9:
test_loss, test_accuracy = trainer.evaluate_model(trainer.test_loader)
print('the Model achieved {} in testing accuracy'.format(test_accuracy))
trainer.get_time()
67/10:
test_loss, test_accuracy = trainer.evaluate_model(trainer.test_loader)
print('the Model achieved {} in testing accuracy'.format(test_accuracy))
trainer.get_time()
67/11:
# Now we can create a Dataloader
runner = DataLoaderCreator('../data/filtered_engineered_data.csv',
                               batch_size=4125)

loaders = runner.create_dataloaders(test_size=0.2,
                                    val_size=0.2, label='label',
                                    save_path='../data')

train_data = torch.load('../data/train_loader.pth')
test_data = torch.load('../data/test_loader.pth')

for inputs, labels in train_data:
    print(inputs.shape, labels.shape)  # Just for checking
    break
67/12:
# Now we can train the model! 
model = EnhancedNN(n_features=len(filtered_df.columns), n_classes=len(filtered_df.label.unique()))
print('number of classes: {}'.format(len(filtered_df.label.unique())))
trainer = ModelTrainer(model, '../data',
                       learning_rate=0.0001, epochs=100)
trainer.train(accuracy_threshold=0.6)
trainer.get_time()
67/13:
# Now we can train the model! 
model = EnhancedNN(n_features=len(filtered_df.columns), n_classes=len(filtered_df.label.unique()))
print('number of classes: {}'.format(len(filtered_df.label.unique())))
trainer = ModelTrainer(model, '../data',
                       learning_rate=0.01, epochs=100)
trainer.train(accuracy_threshold=0.6)
trainer.get_time()
68/1:
import sys
sys.path.append('../')
from pipeline.coinbase_fetcher import CoinbaseDataFetcher
from pipeline.features import FeatureEngineer
from pipeline.create_dataloader import DataLoaderCreator
from pipeline.train import ModelTrainer
from models.simple_model import SimpleNN, EnhancedNN, resnet18

from datetime import datetime, timedelta
import torch
68/2:
# DO we want new data?
fetch = False

# First lets pull the data
fetcher = CoinbaseDataFetcher('', '')
pair = 'BTC-USD'
years = 10
start_time = datetime.utcnow() - timedelta(days=365 * years)  # Start from one year ago
end_time = datetime.utcnow()
#300-> 5-minute, 900-> 15-minute, 3600-> 1 hour
granularity = 900 

# The filename where the CSV will be saved
filename = '10_year_long_historical_data.csv'

# Fetch and save data as CSV
if fetch:
    data = fetcher.get_data_as_csv(pair, start_time, end_time, granularity, filename)
    print('Number of samples: {}'.format(len(data)))
68/3:
# Now lets shape those features
file = '../data/BTC/USD/BTC_USD_60min_20131202-20231130.csv' # or a DataFrame
#file = '../pipeline/data/BTC/USD/BTC_USD_5min_20131203-20231201.csv'
engineer = FeatureEngineer(file)
processed_data = engineer.get_processed_data(save=True) # we can turn save off if we plan to use filtered data

filtered_df = engineer.select_features_based_on_correlation(label='label')
print(filtered_df.columns, len(filtered_df.columns))
68/4: processed_data.head()
68/5: processed_data.columns
69/1:
import sys
sys.path.append('../')
from pipeline.coinbase_fetcher import CoinbaseDataFetcher
from pipeline.features import FeatureEngineer
from pipeline.create_dataloader import DataLoaderCreator
from pipeline.train import ModelTrainer
from models.simple_model import SimpleNN, EnhancedNN, resnet18

from datetime import datetime, timedelta
import torch
69/2:
# DO we want new data?
fetch = False

# First lets pull the data
fetcher = CoinbaseDataFetcher('', '')
pair = 'BTC-USD'
years = 10
start_time = datetime.utcnow() - timedelta(days=365 * years)  # Start from one year ago
end_time = datetime.utcnow()
#300-> 5-minute, 900-> 15-minute, 3600-> 1 hour
granularity = 900 

# The filename where the CSV will be saved
filename = '10_year_long_historical_data.csv'

# Fetch and save data as CSV
if fetch:
    data = fetcher.get_data_as_csv(pair, start_time, end_time, granularity, filename)
    print('Number of samples: {}'.format(len(data)))
69/3:
# Now lets shape those features
file = '../data/BTC/USD/BTC_USD_60min_20131202-20231130.csv' # or a DataFrame
#file = '../pipeline/data/BTC/USD/BTC_USD_5min_20131203-20231201.csv'
engineer = FeatureEngineer(file)
processed_data = engineer.get_processed_data(save=True) # we can turn save off if we plan to use filtered data

filtered_df = engineer.select_features_based_on_correlation(label='label')
print(filtered_df.columns, len(filtered_df.columns))
69/4: processed_data.columns
69/5:
ls = []
for i in range(0, 5):
    temp = filtered_df[filtered_df.label == i]
    ls.append(temp)
    print('For the class {} we have {} number of rows or {}% of the entire dataset'.format(i, len(temp), len(temp)/len(filtered_df)))
69/6:
# Now we can create a Dataloader
runner = DataLoaderCreator('../data/filtered_engineered_data.csv',
                               batch_size=4125)

loaders = runner.create_dataloaders(test_size=0.2,
                                    val_size=0.2, label='label',
                                    save_path='../data')

train_data = torch.load('../data/train_loader.pth')
test_data = torch.load('../data/test_loader.pth')

for inputs, labels in train_data:
    print(inputs.shape, labels.shape)  # Just for checking
    break
69/7:
# Now we can train the model! 
model = EnhancedNN(n_features=len(filtered_df.columns), n_classes=len(filtered_df.label.unique()))
print('number of classes: {}'.format(len(filtered_df.label.unique())))
trainer = ModelTrainer(model, '../data',
                       learning_rate=0.01, epochs=100)
trainer.train(accuracy_threshold=0.6)
trainer.get_time()
69/8: processed_data.head()
70/1:
import sys
sys.path.append('../')
from pipeline.coinbase_fetcher import CoinbaseDataFetcher
from pipeline.features import FeatureEngineer
from pipeline.create_dataloader import DataLoaderCreator
from pipeline.train import ModelTrainer
from models.simple_model import SimpleNN, EnhancedNN, resnet18

from datetime import datetime, timedelta
import torch
70/2:
# DO we want new data?
fetch = False

# First lets pull the data
fetcher = CoinbaseDataFetcher('', '')
pair = 'BTC-USD'
years = 10
start_time = datetime.utcnow() - timedelta(days=365 * years)  # Start from one year ago
end_time = datetime.utcnow()
#300-> 5-minute, 900-> 15-minute, 3600-> 1 hour
granularity = 900 

# The filename where the CSV will be saved
filename = '10_year_long_historical_data.csv'

# Fetch and save data as CSV
if fetch:
    data = fetcher.get_data_as_csv(pair, start_time, end_time, granularity, filename)
    print('Number of samples: {}'.format(len(data)))
70/3:
# Now lets shape those features
file = '../data/BTC/USD/BTC_USD_60min_20131202-20231130.csv' # or a DataFrame
#file = '../pipeline/data/BTC/USD/BTC_USD_5min_20131203-20231201.csv'
engineer = FeatureEngineer(file)
processed_data = engineer.get_processed_data(save=True) # we can turn save off if we plan to use filtered data

filtered_df = engineer.select_features_based_on_correlation(label='label')
print(filtered_df.columns, len(filtered_df.columns))
70/4: processed_data.head()
70/5: processed_data.columns
70/6:
ls = []
for i in range(0, 5):
    temp = filtered_df[filtered_df.label == i]
    ls.append(temp)
    print('For the class {} we have {} number of rows or {}% of the entire dataset'.format(i, len(temp), len(temp)/len(filtered_df)))
70/7:
# Now we can create a Dataloader
runner = DataLoaderCreator('../data/filtered_engineered_data.csv',
                               batch_size=4125)

loaders = runner.create_dataloaders(test_size=0.2,
                                    val_size=0.2, label='label',
                                    save_path='../data')

train_data = torch.load('../data/train_loader.pth')
test_data = torch.load('../data/test_loader.pth')

for inputs, labels in train_data:
    print(inputs.shape, labels.shape)  # Just for checking
    break
70/8:
# Now we can train the model! 
model = EnhancedNN(n_features=len(filtered_df.columns), n_classes=len(filtered_df.label.unique()))
print('number of classes: {}'.format(len(filtered_df.label.unique())))
trainer = ModelTrainer(model, '../data',
                       learning_rate=0.01, epochs=100)
trainer.train(accuracy_threshold=0.6)
trainer.get_time()
70/9:
# Now we can train the model! 
model = EnhancedNN(n_features=len(filtered_df.columns), n_classes=len(filtered_df.label.unique()))
print('number of classes: {}'.format(len(filtered_df.label.unique())))
trainer = ModelTrainer(model, '../data',
                       learning_rate=0.0001, epochs=100)
trainer.train(accuracy_threshold=0.6)
trainer.get_time()
70/10: processed_data.dropna()
70/11: processed_data.dropna().to_string()
70/12: processed_data.dropna().columns()
70/13: processed_data.dropna().columns
71/1:
import sys
sys.path.append('../')
from pipeline.coinbase_fetcher import CoinbaseDataFetcher
from pipeline.features import FeatureEngineer
from pipeline.create_dataloader import DataLoaderCreator
from pipeline.train import ModelTrainer
from models.simple_model import SimpleNN, EnhancedNN, resnet18

from datetime import datetime, timedelta
import torch
71/2:
# DO we want new data?
fetch = False

# First lets pull the data
fetcher = CoinbaseDataFetcher('', '')
pair = 'BTC-USD'
years = 10
start_time = datetime.utcnow() - timedelta(days=365 * years)  # Start from one year ago
end_time = datetime.utcnow()
#300-> 5-minute, 900-> 15-minute, 3600-> 1 hour
granularity = 900 

# The filename where the CSV will be saved
filename = '10_year_long_historical_data.csv'

# Fetch and save data as CSV
if fetch:
    data = fetcher.get_data_as_csv(pair, start_time, end_time, granularity, filename)
    print('Number of samples: {}'.format(len(data)))
71/3:
# Now lets shape those features
file = '../data/BTC/USD/BTC_USD_60min_20131202-20231130.csv' # or a DataFrame
#file = '../pipeline/data/BTC/USD/BTC_USD_5min_20131203-20231201.csv'
engineer = FeatureEngineer(file)
processed_data = engineer.get_processed_data(save=True) # we can turn save off if we plan to use filtered data

filtered_df = engineer.select_features_based_on_correlation(label='label')
print(filtered_df.columns, len(filtered_df.columns))
71/4: processed_data.columns
71/5: processed_data.dropna().columns
71/6:
ls = []
for i in range(0, 5):
    temp = filtered_df[filtered_df.label == i]
    ls.append(temp)
    print('For the class {} we have {} number of rows or {}% of the entire dataset'.format(i, len(temp), len(temp)/len(filtered_df)))
71/7:
# Now we can create a Dataloader
runner = DataLoaderCreator('../data/filtered_engineered_data.csv',
                               batch_size=4125)

loaders = runner.create_dataloaders(test_size=0.2,
                                    val_size=0.2, label='label',
                                    save_path='../data')

train_data = torch.load('../data/train_loader.pth')
test_data = torch.load('../data/test_loader.pth')

for inputs, labels in train_data:
    print(inputs.shape, labels.shape)  # Just for checking
    break
71/8:
# Now we can train the model! 
model = EnhancedNN(n_features=len(filtered_df.columns), n_classes=len(filtered_df.label.unique()))
print('number of classes: {}'.format(len(filtered_df.label.unique())))
trainer = ModelTrainer(model, '../data',
                       learning_rate=0.0001, epochs=100)
trainer.train(accuracy_threshold=0.6)
trainer.get_time()
71/9:
test_loss, test_accuracy = trainer.evaluate_model(trainer.test_loader)
print('the Model achieved {} in testing accuracy'.format(test_accuracy))
trainer.get_time()
72/1:
import sys
sys.path.append('../')
from pipeline.coinbase_fetcher import CoinbaseDataFetcher
from pipeline.features import FeatureEngineer
from pipeline.create_dataloader import DataLoaderCreator
from pipeline.train import ModelTrainer
from models.simple_model import SimpleNN, EnhancedNN, resnet18

from datetime import datetime, timedelta
import torch
72/2:
# DO we want new data?
fetch = False

# First lets pull the data
fetcher = CoinbaseDataFetcher('', '')
pair = 'BTC-USD'
years = 10
start_time = datetime.utcnow() - timedelta(days=365 * years)  # Start from one year ago
end_time = datetime.utcnow()
#300-> 5-minute, 900-> 15-minute, 3600-> 1 hour
granularity = 900 

# The filename where the CSV will be saved
filename = '10_year_long_historical_data.csv'

# Fetch and save data as CSV
if fetch:
    data = fetcher.get_data_as_csv(pair, start_time, end_time, granularity, filename)
    print('Number of samples: {}'.format(len(data)))
72/3:
# Now lets shape those features
file = '../data/BTC/USD/BTC_USD_60min_20131202-20231130.csv' # or a DataFrame
#file = '../pipeline/data/BTC/USD/BTC_USD_5min_20131203-20231201.csv'
engineer = FeatureEngineer(file)
processed_data = engineer.get_processed_data(save=True) # we can turn save off if we plan to use filtered data

filtered_df = engineer.select_features_based_on_correlation(label='label')
print(filtered_df.columns, len(filtered_df.columns))
72/4: processed_data.columns
72/5: processed_data.dropna().columns
72/6:
ls = []
for i in range(0, 5):
    temp = filtered_df[filtered_df.label == i]
    ls.append(temp)
    print('For the class {} we have {} number of rows or {}% of the entire dataset'.format(i, len(temp), len(temp)/len(filtered_df)))
72/7:
# Now we can create a Dataloader
runner = DataLoaderCreator('../data/filtered_engineered_data.csv',
                               batch_size=4125)

loaders = runner.create_dataloaders(test_size=0.2,
                                    val_size=0.2, label='label',
                                    save_path='../data')

train_data = torch.load('../data/train_loader.pth')
test_data = torch.load('../data/test_loader.pth')

for inputs, labels in train_data:
    print(inputs.shape, labels.shape)  # Just for checking
    break
72/8:
# Now we can train the model! 
model = EnhancedNN(n_features=len(filtered_df.columns), n_classes=len(filtered_df.label.unique()))
print('number of classes: {}'.format(len(filtered_df.label.unique())))
trainer = ModelTrainer(model, '../data',
                       learning_rate=0.0001, epochs=100)
trainer.train(accuracy_threshold=0.6)
trainer.get_time()
72/9:
test_loss, test_accuracy = trainer.evaluate_model(trainer.test_loader)
print('the Model achieved {} in testing accuracy'.format(test_accuracy))
trainer.get_time()
73/1:
import sys
sys.path.append('../')
from pipeline.coinbase_fetcher import CoinbaseDataFetcher
from pipeline.features import FeatureEngineer
from pipeline.create_dataloader import DataLoaderCreator
from pipeline.train import ModelTrainer
from models.simple_model import SimpleNN, EnhancedNN, resnet18

from datetime import datetime, timedelta
import torch
73/2:
# DO we want new data?
fetch = False

# First lets pull the data
fetcher = CoinbaseDataFetcher('', '')
pair = 'BTC-USD'
years = 10
start_time = datetime.utcnow() - timedelta(days=365 * years)  # Start from one year ago
end_time = datetime.utcnow()
#300-> 5-minute, 900-> 15-minute, 3600-> 1 hour
granularity = 900 

# The filename where the CSV will be saved
filename = '10_year_long_historical_data.csv'

# Fetch and save data as CSV
if fetch:
    data = fetcher.get_data_as_csv(pair, start_time, end_time, granularity, filename)
    print('Number of samples: {}'.format(len(data)))
73/3:
# Now lets shape those features
file = '../data/BTC/USD/BTC_USD_60min_20131202-20231130.csv' # or a DataFrame
#file = '../pipeline/data/BTC/USD/BTC_USD_5min_20131203-20231201.csv'
engineer = FeatureEngineer(file)
processed_data = engineer.get_processed_data(save=True) # we can turn save off if we plan to use filtered data

filtered_df = engineer.select_features_based_on_correlation(label='label')
print(filtered_df.columns, len(filtered_df.columns))
73/4: processed_data.columns
73/5: processed_data.dropna().columns
73/6:
ls = []
for i in range(0, 5):
    temp = filtered_df[filtered_df.label == i]
    ls.append(temp)
    print('For the class {} we have {} number of rows or {}% of the entire dataset'.format(i, len(temp), len(temp)/len(filtered_df)))
73/7:
# Now we can create a Dataloader
runner = DataLoaderCreator('../data/filtered_engineered_data.csv',
                               batch_size=4125)

loaders = runner.create_dataloaders(test_size=0.2,
                                    val_size=0.2, label='label',
                                    save_path='../data')

train_data = torch.load('../data/train_loader.pth')
test_data = torch.load('../data/test_loader.pth')

for inputs, labels in train_data:
    print(inputs.shape, labels.shape)  # Just for checking
    break
73/8:
# Now we can train the model! 
model = EnhancedNN(n_features=len(filtered_df.columns), n_classes=len(filtered_df.label.unique()))
print('number of classes: {}'.format(len(filtered_df.label.unique())))
trainer = ModelTrainer(model, '../data',
                       learning_rate=0.0001, epochs=100)
trainer.train(accuracy_threshold=0.6)
trainer.get_time()
74/1:
import sys
sys.path.append('../')
from pipeline.coinbase_fetcher import CoinbaseDataFetcher
from pipeline.features import FeatureEngineer
from pipeline.create_dataloader import DataLoaderCreator
from pipeline.train import ModelTrainer
from models.simple_model import SimpleNN, EnhancedNN, resnet18

from datetime import datetime, timedelta
import torch
74/2:
# DO we want new data?
fetch = False

# First lets pull the data
fetcher = CoinbaseDataFetcher('', '')
pair = 'BTC-USD'
years = 10
start_time = datetime.utcnow() - timedelta(days=365 * years)  # Start from one year ago
end_time = datetime.utcnow()
#300-> 5-minute, 900-> 15-minute, 3600-> 1 hour
granularity = 900 

# The filename where the CSV will be saved
filename = '10_year_long_historical_data.csv'

# Fetch and save data as CSV
if fetch:
    data = fetcher.get_data_as_csv(pair, start_time, end_time, granularity, filename)
    print('Number of samples: {}'.format(len(data)))
74/3:
# Now lets shape those features
file = '../data/BTC/USD/BTC_USD_60min_20131202-20231130.csv' # or a DataFrame
#file = '../pipeline/data/BTC/USD/BTC_USD_5min_20131203-20231201.csv'
engineer = FeatureEngineer(file)
processed_data = engineer.get_processed_data(save=True) # we can turn save off if we plan to use filtered data

filtered_df = engineer.select_features_based_on_correlation(label='label')
print(filtered_df.columns, len(filtered_df.columns))
74/4: processed_data.columns
74/5: processed_data.dropna().columns
74/6:
ls = []
for i in range(0, 5):
    temp = filtered_df[filtered_df.label == i]
    ls.append(temp)
    print('For the class {} we have {} number of rows or {}% of the entire dataset'.format(i, len(temp), len(temp)/len(filtered_df)))
74/7:
# Now we can create a Dataloader
runner = DataLoaderCreator('../data/filtered_engineered_data.csv',
                               batch_size=4125)

loaders = runner.create_dataloaders(test_size=0.2,
                                    val_size=0.2, label='label',
                                    save_path='../data')

train_data = torch.load('../data/train_loader.pth')
test_data = torch.load('../data/test_loader.pth')

for inputs, labels in train_data:
    print(inputs.shape, labels.shape)  # Just for checking
    break
74/8:
# Now we can train the model! 
model = EnhancedNN(n_features=len(filtered_df.columns), n_classes=len(filtered_df.label.unique()))
print('number of classes: {}'.format(len(filtered_df.label.unique())))
trainer = ModelTrainer(model, '../data',
                       learning_rate=0.0001, epochs=100)
trainer.train(accuracy_threshold=0.6)
trainer.get_time()
75/1:
import sys
sys.path.append('../')
from pipeline.coinbase_fetcher import CoinbaseDataFetcher
from pipeline.features import FeatureEngineer
from pipeline.create_dataloader import DataLoaderCreator
from pipeline.train import ModelTrainer
from models.simple_model import SimpleNN, EnhancedNN, resnet18

from datetime import datetime, timedelta
import torch
75/2:
# DO we want new data?
fetch = False

# First lets pull the data
fetcher = CoinbaseDataFetcher('', '')
pair = 'BTC-USD'
years = 10
start_time = datetime.utcnow() - timedelta(days=365 * years)  # Start from one year ago
end_time = datetime.utcnow()
#300-> 5-minute, 900-> 15-minute, 3600-> 1 hour
granularity = 900 

# The filename where the CSV will be saved
filename = '10_year_long_historical_data.csv'

# Fetch and save data as CSV
if fetch:
    data = fetcher.get_data_as_csv(pair, start_time, end_time, granularity, filename)
    print('Number of samples: {}'.format(len(data)))
75/3:
# Now lets shape those features
file = '../data/BTC/USD/BTC_USD_60min_20131202-20231130.csv' # or a DataFrame
#file = '../pipeline/data/BTC/USD/BTC_USD_5min_20131203-20231201.csv'
engineer = FeatureEngineer(file)
processed_data = engineer.get_processed_data(save=True) # we can turn save off if we plan to use filtered data

filtered_df = engineer.select_features_based_on_correlation(label='label')
print(filtered_df.columns, len(filtered_df.columns))
75/4: processed_data.columns
75/5: processed_data.dropna().columns
75/6:
ls = []
for i in range(0, 5):
    temp = filtered_df[filtered_df.label == i]
    ls.append(temp)
    print('For the class {} we have {} number of rows or {}% of the entire dataset'.format(i, len(temp), len(temp)/len(filtered_df)))
75/7:
# Now we can create a Dataloader
runner = DataLoaderCreator('../data/filtered_engineered_data.csv',
                               batch_size=4125)

loaders = runner.create_dataloaders(test_size=0.2,
                                    val_size=0.2, label='label',
                                    save_path='../data')

train_data = torch.load('../data/train_loader.pth')
test_data = torch.load('../data/test_loader.pth')

for inputs, labels in train_data:
    print(inputs.shape, labels.shape)  # Just for checking
    break
75/8:
# Now we can train the model! 
n_classes=len(filtered_df.label.unique())
model = EnhancedNN(n_features=len(filtered_df.columns), n_classes=n_classes)
print('number of classes: {}'.format(len(filtered_df.label.unique())))
trainer = ModelTrainer(model, '../data',
                       learning_rate=0.0001, epochs=100)
trainer.train(accuracy_threshold=0.6)
trainer.get_time()
76/1:
import sys
sys.path.append('../')
from pipeline.coinbase_fetcher import CoinbaseDataFetcher
from pipeline.features import FeatureEngineer
from pipeline.create_dataloader import DataLoaderCreator
from pipeline.train import ModelTrainer
from models.simple_model import SimpleNN, EnhancedNN, resnet18

from datetime import datetime, timedelta
import torch
76/2:
# DO we want new data?
fetch = False

# First lets pull the data
fetcher = CoinbaseDataFetcher('', '')
pair = 'BTC-USD'
years = 10
start_time = datetime.utcnow() - timedelta(days=365 * years)  # Start from one year ago
end_time = datetime.utcnow()
#300-> 5-minute, 900-> 15-minute, 3600-> 1 hour
granularity = 900 

# The filename where the CSV will be saved
filename = '10_year_long_historical_data.csv'

# Fetch and save data as CSV
if fetch:
    data = fetcher.get_data_as_csv(pair, start_time, end_time, granularity, filename)
    print('Number of samples: {}'.format(len(data)))
76/3:
# Now lets shape those features
file = '../data/BTC/USD/BTC_USD_60min_20131202-20231130.csv' # or a DataFrame
#file = '../pipeline/data/BTC/USD/BTC_USD_5min_20131203-20231201.csv'
engineer = FeatureEngineer(file)
processed_data = engineer.get_processed_data(save=True) # we can turn save off if we plan to use filtered data

filtered_df = engineer.select_features_based_on_correlation(label='label')
print(filtered_df.columns, len(filtered_df.columns))
76/4: processed_data.columns
76/5: processed_data.dropna().columns
76/6:
ls = []
for i in range(0, 5):
    temp = filtered_df[filtered_df.label == i]
    ls.append(temp)
    print('For the class {} we have {} number of rows or {}% of the entire dataset'.format(i, len(temp), len(temp)/len(filtered_df)))
76/7:
# Now we can create a Dataloader
runner = DataLoaderCreator('../data/filtered_engineered_data.csv',
                               batch_size=4125)

loaders = runner.create_dataloaders(test_size=0.2,
                                    val_size=0.2, label='label',
                                    save_path='../data')

train_data = torch.load('../data/train_loader.pth')
test_data = torch.load('../data/test_loader.pth')

for inputs, labels in train_data:
    print(inputs.shape, labels.shape)  # Just for checking
    break
76/8:
# Now we can train the model! 
n_classes=len(filtered_df.label.unique())
model = EnhancedNN(n_features=len(filtered_df.columns), n_classes=n_classes)
print('number of classes: {}'.format(len(filtered_df.label.unique())))
trainer = ModelTrainer(model, '../data',
                       learning_rate=0.0001, epochs=100)
trainer.train(accuracy_threshold=0.6, num_classes=num_classes)
trainer.get_time()
76/9:
# Now we can train the model! 
n_classes=len(filtered_df.label.unique())
model = EnhancedNN(n_features=len(filtered_df.columns), n_classes=n_classes)
print('number of classes: {}'.format(len(filtered_df.label.unique())))
trainer = ModelTrainer(model, '../data',
                       learning_rate=0.0001, epochs=100)
trainer.train(accuracy_threshold=0.6, num_classes=n_classes)
trainer.get_time()
78/1:
import sys
sys.path.append('../')
from pipeline.coinbase_fetcher import CoinbaseDataFetcher
from pipeline.features import FeatureEngineer
from pipeline.create_dataloader import DataLoaderCreator
from pipeline.train import ModelTrainer
from models.simple_model import SimpleNN, EnhancedNN, resnet18

from datetime import datetime, timedelta
import torch
78/2:
# DO we want new data?
fetch = False

# First lets pull the data
fetcher = CoinbaseDataFetcher('', '')
pair = 'BTC-USD'
years = 10
start_time = datetime.utcnow() - timedelta(days=365 * years)  # Start from one year ago
end_time = datetime.utcnow()
#300-> 5-minute, 900-> 15-minute, 3600-> 1 hour
granularity = 900 

# The filename where the CSV will be saved
filename = '10_year_long_historical_data.csv'

# Fetch and save data as CSV
if fetch:
    data = fetcher.get_data_as_csv(pair, start_time, end_time, granularity, filename)
    print('Number of samples: {}'.format(len(data)))
78/3:
# Now lets shape those features
file = '../data/BTC/USD/BTC_USD_60min_20131202-20231130.csv' # or a DataFrame
#file = '../pipeline/data/BTC/USD/BTC_USD_5min_20131203-20231201.csv'
engineer = FeatureEngineer(file)
processed_data = engineer.get_processed_data(save=True) # we can turn save off if we plan to use filtered data

filtered_df = engineer.select_features_based_on_correlation(label='label')
print(filtered_df.columns, len(filtered_df.columns))
78/4: processed_data.columns
78/5: processed_data.dropna().columns
78/6:
ls = []
for i in range(0, 5):
    temp = filtered_df[filtered_df.label == i]
    ls.append(temp)
    print('For the class {} we have {} number of rows or {}% of the entire dataset'.format(i, len(temp), len(temp)/len(filtered_df)))
78/7:
# Now we can create a Dataloader
runner = DataLoaderCreator('../data/filtered_engineered_data.csv',
                               batch_size=4125)

loaders = runner.create_dataloaders(test_size=0.2,
                                    val_size=0.2, label='label',
                                    save_path='../data')

train_data = torch.load('../data/train_loader.pth')
test_data = torch.load('../data/test_loader.pth')

for inputs, labels in train_data:
    print(inputs.shape, labels.shape)  # Just for checking
    break
78/8:
# Now we can train the model! 
n_classes=len(filtered_df.label.unique())
model = EnhancedNN(n_features=len(filtered_df.columns), n_classes=n_classes)
print('number of classes: {}'.format(len(filtered_df.label.unique())))
trainer = ModelTrainer(model, '../data',
                       learning_rate=0.0001, epochs=100)
trainer.train(accuracy_threshold=0.6, num_classes=n_classes)
trainer.get_time()
80/1:
import sys
sys.path.append('../')
from pipeline.coinbase_fetcher import CoinbaseDataFetcher
from pipeline.features import FeatureEngineer
from pipeline.create_dataloader import DataLoaderCreator
from pipeline.train import ModelTrainer
from models.simple_model import SimpleNN, EnhancedNN, resnet18

from datetime import datetime, timedelta
import torch
80/2:
# DO we want new data?
fetch = False

# First lets pull the data
fetcher = CoinbaseDataFetcher('', '')
pair = 'BTC-USD'
years = 10
start_time = datetime.utcnow() - timedelta(days=365 * years)  # Start from one year ago
end_time = datetime.utcnow()
#300-> 5-minute, 900-> 15-minute, 3600-> 1 hour
granularity = 900 

# The filename where the CSV will be saved
filename = '10_year_long_historical_data.csv'

# Fetch and save data as CSV
if fetch:
    data = fetcher.get_data_as_csv(pair, start_time, end_time, granularity, filename)
    print('Number of samples: {}'.format(len(data)))
80/3:
# Now lets shape those features
file = '../data/BTC/USD/BTC_USD_60min_20131202-20231130.csv' # or a DataFrame
#file = '../pipeline/data/BTC/USD/BTC_USD_5min_20131203-20231201.csv'
engineer = FeatureEngineer(file)
processed_data = engineer.get_processed_data(save=True) # we can turn save off if we plan to use filtered data

filtered_df = engineer.select_features_based_on_correlation(label='label')
print(filtered_df.columns, len(filtered_df.columns))
80/4: processed_data.columns
80/5: processed_data.dropna().columns
80/6:
ls = []
for i in range(0, 5):
    temp = filtered_df[filtered_df.label == i]
    ls.append(temp)
    print('For the class {} we have {} number of rows or {}% of the entire dataset'.format(i, len(temp), len(temp)/len(filtered_df)))
80/7:
# Now we can create a Dataloader
runner = DataLoaderCreator('../data/filtered_engineered_data.csv',
                               batch_size=4125)

loaders = runner.create_dataloaders(test_size=0.2,
                                    val_size=0.2, label='label',
                                    save_path='../data')

train_data = torch.load('../data/train_loader.pth')
test_data = torch.load('../data/test_loader.pth')

for inputs, labels in train_data:
    print(inputs.shape, labels.shape)  # Just for checking
    break
80/8:
# Now we can train the model! 
n_classes=len(filtered_df.label.unique())
model = EnhancedNN(n_features=len(filtered_df.columns), n_classes=n_classes)
print('number of classes: {}'.format(len(filtered_df.label.unique())))
trainer = ModelTrainer(model, '../data',
                       learning_rate=0.0001, epochs=100)
trainer.train(accuracy_threshold=0.6, num_classes=n_classes)
trainer.get_time()
80/9:
# Now we can train the model! 
n_classes=len(filtered_df.label.unique())
model = EnhancedNN(n_features=len(filtered_df.columns), n_classes=n_classes)
print('number of classes: {}'.format(len(filtered_df.label.unique())))
trainer = ModelTrainer(model, '../data',
                       learning_rate=0.0001, epochs=10)
trainer.train(accuracy_threshold=0.6, num_classes=n_classes)
trainer.get_time()
80/10:
test_loss, test_accuracy, confusion_matrix = trainer.evaluate_model(trainer.test_loader, n_classes)
print('the Model achieved {} in testing accuracy'.format(test_accuracy))
trainer.get_time()
80/11: confusion_matrix
80/12:
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np

def plot_confusion_matrix(confusion_matrix, class_names):
    """
    Plots a confusion matrix using Seaborn's heatmap.
    
    :param confusion_matrix: A 2D array of shape (num_classes, num_classes) representing the confusion matrix.
    :param class_names: A list of class names, ordered according to their index in the confusion matrix.
    """
    plt.figure(figsize=(10, 8))
    sns.heatmap(confusion_matrix, annot=True, fmt="d", cmap='Blues',
                xticklabels=class_names, yticklabels=class_names)

    plt.ylabel('True Label')
    plt.xlabel('Predicted Label')
    plt.title('Confusion Matrix')
    plt.show()
80/13: plot_confusion_matrix(confusion_matrix, [0, 1, 2, 3, 4]
80/14:
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np

def plot_confusion_matrix(confusion_matrix, class_names):
    """
    Plots a confusion matrix using Seaborn's heatmap.
    
    :param confusion_matrix: A 2D array of shape (num_classes, num_classes) representing the confusion matrix.
    :param class_names: A list of class names, ordered according to their index in the confusion matrix.
    """
    plt.figure(figsize=(10, 8))
    sns.heatmap(confusion_matrix, annot=True, fmt="d", cmap='Blues',
                xticklabels=class_names, yticklabels=class_names)

    plt.ylabel('True Label')
    plt.xlabel('Predicted Label')
    plt.title('Confusion Matrix')
    plt.show()
80/15: plot_confusion_matrix(confusion_matrix, [0, 1, 2, 3, 4])
80/16:
def plot_confusion_matrix(confusion_matrix, class_names):
    """
    Plots a confusion matrix using Seaborn's heatmap.
    
    :param confusion_matrix: A 2D array of shape (num_classes, num_classes) representing the confusion matrix.
    :param class_names: A list of class names, ordered according to their index in the confusion matrix.
    """
    plt.figure(figsize=(10, 8))
    sns.heatmap(confusion_matrix, annot=True, fmt="d", cmap='Blues',
                xticklabels=class_names, yticklabels=class_names)

    plt.ylabel('True Label')
    plt.xlabel('Predicted Label')
    plt.title('Confusion Matrix')
    plt.show()

plot_confusion_matrix(confusion_matrix, [0, 1, 'neutral', 3, 4])
80/17:
def plot_confusion_matrix(confusion_matrix, class_names):
    """
    Plots a confusion matrix using Seaborn's heatmap.
    
    :param confusion_matrix: A 2D array of shape (num_classes, num_classes) representing the confusion matrix.
    :param class_names: A list of class names, ordered according to their index in the confusion matrix.
    """
    plt.figure(figsize=(10, 8))
    sns.heatmap(confusion_matrix, annot=True, fmt="d", cmap='Blues',
                xticklabels=class_names, yticklabels=class_names)

    plt.ylabel('True Label')
    plt.xlabel('Predicted Label')
    plt.title('Confusion Matrix')
    plt.show()

plot_confusion_matrix(confusion_matrix, ['really down', 'slightly down', 'neutral', 'slighty up', 'really up'])
80/18:
# Now we can train the model! 
n_classes=len(filtered_df.label.unique())
model = EnhancedNN(n_features=len(filtered_df.columns), n_classes=n_classes)
print('number of classes: {}'.format(len(filtered_df.label.unique())))
trainer = ModelTrainer(model, '../data',
                       learning_rate=0.0001, epochs=100)
trainer.train(accuracy_threshold=0.6, num_classes=n_classes)
trainer.get_time()
80/19:
test_loss, test_accuracy, confusion_matrix = trainer.evaluate_model(trainer.test_loader, n_classes)
print('the Model achieved {} in testing accuracy'.format(test_accuracy))
trainer.get_time()
80/20: confusion_matrix
80/21:
def plot_confusion_matrix(confusion_matrix, class_names):
    """
    Plots a confusion matrix using Seaborn's heatmap.
    
    :param confusion_matrix: A 2D array of shape (num_classes, num_classes) representing the confusion matrix.
    :param class_names: A list of class names, ordered according to their index in the confusion matrix.
    """
    plt.figure(figsize=(10, 8))
    sns.heatmap(confusion_matrix, annot=True, fmt="d", cmap='Blues',
                xticklabels=class_names, yticklabels=class_names)

    plt.ylabel('True Label')
    plt.xlabel('Predicted Label')
    plt.title('Confusion Matrix')
    plt.show()

plot_confusion_matrix(confusion_matrix, ['really down', 'slightly down', 'neutral', 'slighty up', 'really up'])
80/22: confusion_matrix
82/1:
import sys
sys.path.append('../')
from pipeline.coinbase_fetcher import CoinbaseDataFetcher
from pipeline.features import FeatureEngineer
from pipeline.create_dataloader import DataLoaderCreator
from pipeline.train import ModelTrainer
from models.simple_model import SimpleNN, EnhancedNN, resnet18
from models.time_series_model import StockClassifier

from datetime import datetime, timedelta
import torch
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
84/1:
import sys
sys.path.append('../')
from pipeline.coinbase_fetcher import CoinbaseDataFetcher
from pipeline.features import FeatureEngineer
from pipeline.create_dataloader import DataLoaderCreator
from pipeline.train import ModelTrainer
from models.simple_model import SimpleNN, EnhancedNN, resnet18
from models.time_series_model import StockClassifier

from datetime import datetime, timedelta
import torch
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
84/2:
# DO we want new data?
fetch = False

# First lets pull the data
fetcher = CoinbaseDataFetcher('', '')
pair = 'BTC-USD'
years = 10
start_time = datetime.utcnow() - timedelta(days=365 * years)  # Start from one year ago
end_time = datetime.utcnow()
#300-> 5-minute, 900-> 15-minute, 3600-> 1 hour
granularity = 900 

# The filename where the CSV will be saved
filename = '10_year_long_historical_data.csv'

# Fetch and save data as CSV
if fetch:
    data = fetcher.get_data_as_csv(pair, start_time, end_time, granularity, filename)
    print('Number of samples: {}'.format(len(data)))
84/3:
# Now lets shape those features
file = '../data/BTC/USD/BTC_USD_60min_20131202-20231130.csv' # or a DataFrame
#file = '../pipeline/data/BTC/USD/BTC_USD_5min_20131203-20231201.csv'
engineer = FeatureEngineer(file)
processed_data = engineer.get_processed_data(save=True) # we can turn save off if we plan to use filtered data

filtered_df = engineer.select_features_based_on_correlation(label='label')
print(filtered_df.columns, len(filtered_df.columns))
84/4: processed_data.columns
84/5: processed_data.dropna().columns
84/6:
ls = []
for i in range(0, 5):
    temp = filtered_df[filtered_df.label == i]
    ls.append(temp)
    print('For the class {} we have {} number of rows or {}% of the entire dataset'.format(i, len(temp), len(temp)/len(filtered_df)))
84/7:
# Now we can create a Dataloader
runner = DataLoaderCreator('../data/filtered_engineered_data.csv',
                               batch_size=4125)

loaders = runner.create_dataloaders(test_size=0.2,
                                    val_size=0.2, label='label',
                                    save_path='../data')

train_data = torch.load('../data/train_loader.pth')
test_data = torch.load('../data/test_loader.pth')

for inputs, labels in train_data:
    print(inputs.shape, labels.shape)  # Just for checking
    break
84/8:
# Now we can train the model! 
n_classes=len(filtered_df.label.unique())
model = StockClassifier(n_features=len(filtered_df.columns), n_classes=n_classes)
print('number of classes: {}'.format(len(filtered_df.label.unique())))
trainer = ModelTrainer(model, '../data',
                       learning_rate=0.0001, epochs=100)
trainer.train(accuracy_threshold=0.6, num_classes=n_classes)
trainer.get_time()
85/1:
import sys
sys.path.append('../')
from pipeline.coinbase_fetcher import CoinbaseDataFetcher
from pipeline.features import FeatureEngineer
from pipeline.create_dataloader import DataLoaderCreator
from pipeline.train import ModelTrainer
from models.simple_model import SimpleNN, EnhancedNN, resnet18
from models.time_series_model import StockClassifier

from datetime import datetime, timedelta
import torch
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
85/2:
# DO we want new data?
fetch = False

# First lets pull the data
fetcher = CoinbaseDataFetcher('', '')
pair = 'BTC-USD'
years = 10
start_time = datetime.utcnow() - timedelta(days=365 * years)  # Start from one year ago
end_time = datetime.utcnow()
#300-> 5-minute, 900-> 15-minute, 3600-> 1 hour
granularity = 900 

# The filename where the CSV will be saved
filename = '10_year_long_historical_data.csv'

# Fetch and save data as CSV
if fetch:
    data = fetcher.get_data_as_csv(pair, start_time, end_time, granularity, filename)
    print('Number of samples: {}'.format(len(data)))
85/3:
# Now lets shape those features
file = '../data/BTC/USD/BTC_USD_60min_20131202-20231130.csv' # or a DataFrame
#file = '../pipeline/data/BTC/USD/BTC_USD_5min_20131203-20231201.csv'
engineer = FeatureEngineer(file)
processed_data = engineer.get_processed_data(save=True) # we can turn save off if we plan to use filtered data

filtered_df = engineer.select_features_based_on_correlation(label='label')
print(filtered_df.columns, len(filtered_df.columns))
85/4: processed_data.columns
85/5: processed_data.dropna().columns
85/6:
ls = []
for i in range(0, 5):
    temp = filtered_df[filtered_df.label == i]
    ls.append(temp)
    print('For the class {} we have {} number of rows or {}% of the entire dataset'.format(i, len(temp), len(temp)/len(filtered_df)))
85/7:
# Now we can create a Dataloader
runner = DataLoaderCreator('../data/filtered_engineered_data.csv',
                               batch_size=4125)

loaders = runner.create_dataloaders(test_size=0.2,
                                    val_size=0.2, label='label',
                                    save_path='../data')

train_data = torch.load('../data/train_loader.pth')
test_data = torch.load('../data/test_loader.pth')

for inputs, labels in train_data:
    print(inputs.shape, labels.shape)  # Just for checking
    break
85/8:
# Now we can train the model! 
n_classes=len(filtered_df.label.unique())
model = StockClassifier(n_features=len(filtered_df.columns), n_classes=n_classes)
print('number of classes: {}'.format(len(filtered_df.label.unique())))
trainer = ModelTrainer(model, '../data',
                       learning_rate=0.0001, epochs=100)
trainer.train(accuracy_threshold=0.6, num_classes=n_classes)
trainer.get_time()
87/1:
import sys
sys.path.append('../')
from pipeline.coinbase_fetcher import CoinbaseDataFetcher
from pipeline.features import FeatureEngineer
from pipeline.create_dataloader import DataLoaderCreator
from pipeline.train import ModelTrainer
from models.simple_model import SimpleNN, EnhancedNN, resnet18
from models.time_series_model import StockClassifier

from datetime import datetime, timedelta
import torch
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
87/2:
# DO we want new data?
fetch = False

# First lets pull the data
fetcher = CoinbaseDataFetcher('', '')
pair = 'BTC-USD'
years = 10
start_time = datetime.utcnow() - timedelta(days=365 * years)  # Start from one year ago
end_time = datetime.utcnow()
#300-> 5-minute, 900-> 15-minute, 3600-> 1 hour
granularity = 900 

# The filename where the CSV will be saved
filename = '10_year_long_historical_data.csv'

# Fetch and save data as CSV
if fetch:
    data = fetcher.get_data_as_csv(pair, start_time, end_time, granularity, filename)
    print('Number of samples: {}'.format(len(data)))
87/3:
# Now lets shape those features
file = '../data/BTC/USD/BTC_USD_60min_20131202-20231130.csv' # or a DataFrame
#file = '../pipeline/data/BTC/USD/BTC_USD_5min_20131203-20231201.csv'
engineer = FeatureEngineer(file)
processed_data = engineer.get_processed_data(save=True) # we can turn save off if we plan to use filtered data

filtered_df = engineer.select_features_based_on_correlation(label='label')
print(filtered_df.columns, len(filtered_df.columns))
87/4: processed_data.columns
87/5: processed_data.dropna().columns
87/6:
ls = []
for i in range(0, 5):
    temp = filtered_df[filtered_df.label == i]
    ls.append(temp)
    print('For the class {} we have {} number of rows or {}% of the entire dataset'.format(i, len(temp), len(temp)/len(filtered_df)))
87/7:
# Now we can create a Dataloader
runner = DataLoaderCreator('../data/filtered_engineered_data.csv',
                               batch_size=4125)

loaders = runner.create_dataloaders(test_size=0.2,
                                    val_size=0.2, label='label',
                                    save_path='../data')

train_data = torch.load('../data/train_loader.pth')
test_data = torch.load('../data/test_loader.pth')

for inputs, labels in train_data:
    print(inputs.shape, labels.shape)  # Just for checking
    break
87/8:
# Now we can train the model! 
n_classes=len(filtered_df.label.unique())
model = StockClassifier(n_features=len(filtered_df.columns), n_classes=n_classes)
print('number of classes: {}'.format(len(filtered_df.label.unique())))
trainer = ModelTrainer(model, '../data',
                       learning_rate=0.0001, epochs=100)
trainer.train(accuracy_threshold=0.6, num_classes=n_classes)
trainer.get_time()
88/1:
import sys
sys.path.append('../')
from pipeline.coinbase_fetcher import CoinbaseDataFetcher
from pipeline.features import FeatureEngineer
from pipeline.create_dataloader import DataLoaderCreator
from pipeline.train import ModelTrainer
from models.simple_model import SimpleNN, EnhancedNN, resnet18
from models.time_series_model import StockClassifier

from datetime import datetime, timedelta
import torch
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
88/2:
# DO we want new data?
fetch = False

# First lets pull the data
fetcher = CoinbaseDataFetcher('', '')
pair = 'BTC-USD'
years = 10
start_time = datetime.utcnow() - timedelta(days=365 * years)  # Start from one year ago
end_time = datetime.utcnow()
#300-> 5-minute, 900-> 15-minute, 3600-> 1 hour
granularity = 900 

# The filename where the CSV will be saved
filename = '10_year_long_historical_data.csv'

# Fetch and save data as CSV
if fetch:
    data = fetcher.get_data_as_csv(pair, start_time, end_time, granularity, filename)
    print('Number of samples: {}'.format(len(data)))
88/3:
# Now lets shape those features
file = '../data/BTC/USD/BTC_USD_60min_20131202-20231130.csv' # or a DataFrame
#file = '../pipeline/data/BTC/USD/BTC_USD_5min_20131203-20231201.csv'
engineer = FeatureEngineer(file)
processed_data = engineer.get_processed_data(save=True) # we can turn save off if we plan to use filtered data

filtered_df = engineer.select_features_based_on_correlation(label='label')
print(filtered_df.columns, len(filtered_df.columns))
88/4: processed_data.columns
88/5: processed_data.dropna().columns
88/6:
ls = []
for i in range(0, 5):
    temp = filtered_df[filtered_df.label == i]
    ls.append(temp)
    print('For the class {} we have {} number of rows or {}% of the entire dataset'.format(i, len(temp), len(temp)/len(filtered_df)))
88/7:
# Now we can create a Dataloader
runner = DataLoaderCreator('../data/filtered_engineered_data.csv',
                               batch_size=4125)

loaders = runner.create_dataloaders(test_size=0.2,
                                    val_size=0.2, label='label',
                                    save_path='../data')

train_data = torch.load('../data/train_loader.pth')
test_data = torch.load('../data/test_loader.pth')

for inputs, labels in train_data:
    print(inputs.shape, labels.shape)  # Just for checking
    break
88/8:
# Now we can train the model! 
n_classes=len(filtered_df.label.unique())
model = StockClassifier(n_features=len(filtered_df.columns), n_classes=n_classes)
print('number of classes: {}'.format(len(filtered_df.label.unique())))
trainer = ModelTrainer(model, '../data',
                       learning_rate=0.0001, epochs=100)
trainer.train(accuracy_threshold=0.6, num_classes=n_classes)
trainer.get_time()
90/1:
import sys
sys.path.append('../')
from pipeline.coinbase_fetcher import CoinbaseDataFetcher
from pipeline.features import FeatureEngineer
from pipeline.create_dataloader import DataLoaderCreator
from pipeline.train import ModelTrainer
from models.simple_model import SimpleNN, EnhancedNN, resnet18
from models.time_series_model import StockClassifier

from datetime import datetime, timedelta
import torch
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
90/2:
# DO we want new data?
fetch = False

# First lets pull the data
fetcher = CoinbaseDataFetcher('', '')
pair = 'BTC-USD'
years = 10
start_time = datetime.utcnow() - timedelta(days=365 * years)  # Start from one year ago
end_time = datetime.utcnow()
#300-> 5-minute, 900-> 15-minute, 3600-> 1 hour
granularity = 900 

# The filename where the CSV will be saved
filename = '10_year_long_historical_data.csv'

# Fetch and save data as CSV
if fetch:
    data = fetcher.get_data_as_csv(pair, start_time, end_time, granularity, filename)
    print('Number of samples: {}'.format(len(data)))
90/3:
# Now lets shape those features
file = '../data/BTC/USD/BTC_USD_60min_20131202-20231130.csv' # or a DataFrame
#file = '../pipeline/data/BTC/USD/BTC_USD_5min_20131203-20231201.csv'
engineer = FeatureEngineer(file)
processed_data = engineer.get_processed_data(save=True) # we can turn save off if we plan to use filtered data

filtered_df = engineer.select_features_based_on_correlation(label='label')
print(filtered_df.columns, len(filtered_df.columns))
90/4: processed_data.columns
90/5: processed_data.dropna().columns
90/6:
ls = []
for i in range(0, 5):
    temp = filtered_df[filtered_df.label == i]
    ls.append(temp)
    print('For the class {} we have {} number of rows or {}% of the entire dataset'.format(i, len(temp), len(temp)/len(filtered_df)))
90/7:
# Now we can create a Dataloader
runner = DataLoaderCreator('../data/filtered_engineered_data.csv',
                               batch_size=4125)

loaders = runner.create_dataloaders(test_size=0.2,
                                    val_size=0.2, label='label',
                                    save_path='../data')

train_data = torch.load('../data/train_loader.pth')
test_data = torch.load('../data/test_loader.pth')

for inputs, labels in train_data:
    print(inputs.shape, labels.shape)  # Just for checking
    break
90/8:
# Now we can train the model! 
n_classes=len(filtered_df.label.unique())
model = StockClassifier(n_features=len(filtered_df.columns), n_classes=n_classes)
print('number of classes: {}'.format(len(filtered_df.label.unique())))
trainer = ModelTrainer(model, '../data',
                       learning_rate=0.0001, epochs=100)
trainer.train(accuracy_threshold=0.6, num_classes=n_classes)
trainer.get_time()
92/1:
import sys
sys.path.append('../')
from pipeline.coinbase_fetcher import CoinbaseDataFetcher
from pipeline.features import FeatureEngineer
from pipeline.create_dataloader import DataLoaderCreator
from pipeline.train import ModelTrainer
from models.simple_model import SimpleNN, EnhancedNN, resnet18
from models.time_series_model import StockClassifier

from datetime import datetime, timedelta
import torch
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
92/2:
# DO we want new data?
fetch = False

# First lets pull the data
fetcher = CoinbaseDataFetcher('', '')
pair = 'BTC-USD'
years = 10
start_time = datetime.utcnow() - timedelta(days=365 * years)  # Start from one year ago
end_time = datetime.utcnow()
#300-> 5-minute, 900-> 15-minute, 3600-> 1 hour
granularity = 900 

# The filename where the CSV will be saved
filename = '10_year_long_historical_data.csv'

# Fetch and save data as CSV
if fetch:
    data = fetcher.get_data_as_csv(pair, start_time, end_time, granularity, filename)
    print('Number of samples: {}'.format(len(data)))
92/3:
# Now lets shape those features
file = '../data/BTC/USD/BTC_USD_60min_20131202-20231130.csv' # or a DataFrame
#file = '../pipeline/data/BTC/USD/BTC_USD_5min_20131203-20231201.csv'
engineer = FeatureEngineer(file)
processed_data = engineer.get_processed_data(save=True) # we can turn save off if we plan to use filtered data

filtered_df = engineer.select_features_based_on_correlation(label='label')
print(filtered_df.columns, len(filtered_df.columns))
92/4: processed_data.columns
92/5: processed_data.dropna().columns
92/6:
ls = []
for i in range(0, 5):
    temp = filtered_df[filtered_df.label == i]
    ls.append(temp)
    print('For the class {} we have {} number of rows or {}% of the entire dataset'.format(i, len(temp), len(temp)/len(filtered_df)))
92/7:
# Now we can create a Dataloader
runner = DataLoaderCreator('../data/filtered_engineered_data.csv',
                               batch_size=4125)

loaders = runner.create_dataloaders(test_size=0.2,
                                    val_size=0.2, label='label',
                                    save_path='../data')

train_data = torch.load('../data/train_loader.pth')
test_data = torch.load('../data/test_loader.pth')

for inputs, labels in train_data:
    print(inputs.shape, labels.shape)  # Just for checking
    break
92/8:
# Now we can train the model! 
n_classes=len(filtered_df.label.unique())
model = StockClassifier(n_features=len(filtered_df.columns), n_classes=n_classes)
print('number of classes: {}'.format(len(filtered_df.label.unique())))
trainer = ModelTrainer(model, '../data',
                       learning_rate=0.0001, epochs=100)
trainer.train(accuracy_threshold=0.6, num_classes=n_classes)
trainer.get_time()
92/9:
# Now we can create a Dataloader
runner = DataLoaderCreator('../data/filtered_engineered_data.csv',
                               batch_size=64)

loaders = runner.create_dataloaders(test_size=0.2,
                                    val_size=0.2, label='label',
                                    save_path='../data')

train_data = torch.load('../data/train_loader.pth')
test_data = torch.load('../data/test_loader.pth')

for inputs, labels in train_data:
    print(inputs.shape, labels.shape)  # Just for checking
    break
92/10:
# Now we can train the model! 
n_classes=len(filtered_df.label.unique())
model = StockClassifier(n_features=len(filtered_df.columns), n_classes=n_classes)
print('number of classes: {}'.format(len(filtered_df.label.unique())))
trainer = ModelTrainer(model, '../data',
                       learning_rate=0.0001, epochs=100)
trainer.train(accuracy_threshold=0.6, num_classes=n_classes)
trainer.get_time()
93/1:
import sys
sys.path.append('../')
from pipeline.coinbase_fetcher import CoinbaseDataFetcher
from pipeline.features import FeatureEngineer
from pipeline.create_dataloader import DataLoaderCreator
from pipeline.train import ModelTrainer
from models.simple_model import SimpleNN, EnhancedNN, resnet18
from models.time_series_model import StockClassifier

from datetime import datetime, timedelta
import torch
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
93/2:
# DO we want new data?
fetch = False

# First lets pull the data
fetcher = CoinbaseDataFetcher('', '')
pair = 'BTC-USD'
years = 10
start_time = datetime.utcnow() - timedelta(days=365 * years)  # Start from one year ago
end_time = datetime.utcnow()
#300-> 5-minute, 900-> 15-minute, 3600-> 1 hour
granularity = 900 

# The filename where the CSV will be saved
filename = '10_year_long_historical_data.csv'

# Fetch and save data as CSV
if fetch:
    data = fetcher.get_data_as_csv(pair, start_time, end_time, granularity, filename)
    print('Number of samples: {}'.format(len(data)))
93/3:
# Now lets shape those features
file = '../data/BTC/USD/BTC_USD_60min_20131202-20231130.csv' # or a DataFrame
#file = '../pipeline/data/BTC/USD/BTC_USD_5min_20131203-20231201.csv'
engineer = FeatureEngineer(file)
processed_data = engineer.get_processed_data(save=True) # we can turn save off if we plan to use filtered data

filtered_df = engineer.select_features_based_on_correlation(label='label')
print(filtered_df.columns, len(filtered_df.columns))
93/4: processed_data.columns
93/5: processed_data.dropna().columns
93/6:
ls = []
for i in range(0, 5):
    temp = filtered_df[filtered_df.label == i]
    ls.append(temp)
    print('For the class {} we have {} number of rows or {}% of the entire dataset'.format(i, len(temp), len(temp)/len(filtered_df)))
93/7:
# Now we can create a Dataloader
runner = DataLoaderCreator('../data/filtered_engineered_data.csv',
                               batch_size=64)

loaders = runner.create_dataloaders(test_size=0.2,
                                    val_size=0.2, label='label',
                                    save_path='../data')

train_data = torch.load('../data/train_loader.pth')
test_data = torch.load('../data/test_loader.pth')

for inputs, labels in train_data:
    print(inputs.shape, labels.shape)  # Just for checking
    break
93/8:
# Now we can train the model! 
n_classes=len(filtered_df.label.unique())
model = StockClassifier(n_features=len(filtered_df.columns), n_classes=n_classes)
print('number of classes: {}'.format(len(filtered_df.label.unique())))
trainer = ModelTrainer(model, '../data',
                       learning_rate=0.0001, epochs=100)
trainer.train(accuracy_threshold=0.6, num_classes=n_classes)
trainer.get_time()
94/1:
import sys
sys.path.append('../')
from pipeline.coinbase_fetcher import CoinbaseDataFetcher
from pipeline.features import FeatureEngineer
from pipeline.create_dataloader import DataLoaderCreator
from pipeline.train import ModelTrainer
from models.simple_model import SimpleNN, EnhancedNN, resnet18
from models.time_series_model import StockClassifier

from datetime import datetime, timedelta
import torch
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
94/2:
# DO we want new data?
fetch = False

# First lets pull the data
fetcher = CoinbaseDataFetcher('', '')
pair = 'BTC-USD'
years = 10
start_time = datetime.utcnow() - timedelta(days=365 * years)  # Start from one year ago
end_time = datetime.utcnow()
#300-> 5-minute, 900-> 15-minute, 3600-> 1 hour
granularity = 900 

# The filename where the CSV will be saved
filename = '10_year_long_historical_data.csv'

# Fetch and save data as CSV
if fetch:
    data = fetcher.get_data_as_csv(pair, start_time, end_time, granularity, filename)
    print('Number of samples: {}'.format(len(data)))
94/3:
# Now lets shape those features
file = '../data/BTC/USD/BTC_USD_60min_20131202-20231130.csv' # or a DataFrame
#file = '../pipeline/data/BTC/USD/BTC_USD_5min_20131203-20231201.csv'
engineer = FeatureEngineer(file)
processed_data = engineer.get_processed_data(save=True) # we can turn save off if we plan to use filtered data

filtered_df = engineer.select_features_based_on_correlation(label='label')
print(filtered_df.columns, len(filtered_df.columns))
94/4: processed_data.columns
94/5: processed_data.dropna().columns
94/6:
ls = []
for i in range(0, 5):
    temp = filtered_df[filtered_df.label == i]
    ls.append(temp)
    print('For the class {} we have {} number of rows or {}% of the entire dataset'.format(i, len(temp), len(temp)/len(filtered_df)))
94/7:
# Now we can create a Dataloader
runner = DataLoaderCreator('../data/filtered_engineered_data.csv',
                               batch_size=64)

loaders = runner.create_dataloaders(test_size=0.2,
                                    val_size=0.2, label='label',
                                    save_path='../data')

train_data = torch.load('../data/train_loader.pth')
test_data = torch.load('../data/test_loader.pth')

for inputs, labels in train_data:
    print(inputs.shape, labels.shape)  # Just for checking
    break
94/8:
# Now we can train the model! 
n_classes=len(filtered_df.label.unique())
model = StockClassifier(n_features=len(filtered_df.columns), n_classes=n_classes)
print('number of classes: {}'.format(len(filtered_df.label.unique())))
trainer = ModelTrainer(model, '../data',
                       learning_rate=0.0001, epochs=100)
trainer.train(accuracy_threshold=0.6, num_classes=n_classes)
trainer.get_time()
94/9:
# Now we can create a Dataloader
runner = DataLoaderCreator('../data/filtered_engineered_data.csv',
                               batch_size=1024)

loaders = runner.create_dataloaders(test_size=0.2,
                                    val_size=0.2, label='label',
                                    save_path='../data')

train_data = torch.load('../data/train_loader.pth')
test_data = torch.load('../data/test_loader.pth')

for inputs, labels in train_data:
    print(inputs.shape, labels.shape)  # Just for checking
    break
94/10:
# Now we can train the model! 
n_classes=len(filtered_df.label.unique())
model = StockClassifier(n_features=len(filtered_df.columns), n_classes=n_classes)
print('number of classes: {}'.format(len(filtered_df.label.unique())))
trainer = ModelTrainer(model, '../data',
                       learning_rate=0.0001, epochs=100)
trainer.train(accuracy_threshold=0.6, num_classes=n_classes)
trainer.get_time()
94/11:
test_loss, test_accuracy, confusion_matrix = trainer.evaluate_model(trainer.test_loader, n_classes)
print('the Model achieved {} in testing accuracy'.format(test_accuracy))
trainer.get_time()
94/12:
def plot_confusion_matrix(confusion_matrix, class_names):
    """
    Plots a confusion matrix using Seaborn's heatmap.
    
    :param confusion_matrix: A 2D array of shape (num_classes, num_classes) representing the confusion matrix.
    :param class_names: A list of class names, ordered according to their index in the confusion matrix.
    """
    plt.figure(figsize=(10, 8))
    sns.heatmap(confusion_matrix, annot=True, fmt="d", cmap='Blues',
                xticklabels=class_names, yticklabels=class_names)

    plt.ylabel('True Label')
    plt.xlabel('Predicted Label')
    plt.title('Confusion Matrix')
    plt.show()

plot_confusion_matrix(confusion_matrix, ['really down', 'slightly down', 'neutral', 'slighty up', 'really up'])
94/13: confusion_matrix
94/14:
def plot_confusion_matrix(confusion_matrix, class_names):
    """
    Plots a confusion matrix using Seaborn's heatmap.
    
    :param confusion_matrix: A 2D array of shape (num_classes, num_classes) representing the confusion matrix.
    :param class_names: A list of class names, ordered according to their index in the confusion matrix.
    """
    plt.figure(figsize=(10, 8))
    sns.heatmap(confusion_matrix, annot=True, fmt="d", cmap='Blues',
                xticklabels=class_names, yticklabels=class_names)

    plt.ylabel('True Label')
    plt.xlabel('Predicted Label')
    plt.title('Confusion Matrix')
    plt.show()

plot_confusion_matrix(confusion_matrix, ['really down', 'slightly down', 'neutral', 'slighty up', 'really up'])
94/15: confusion_matrix
94/16:
# Now we can create a Dataloader
runner = DataLoaderCreator('../data/filtered_engineered_data.csv',
                               batch_size=64)

loaders = runner.create_dataloaders(test_size=0.2,
                                    val_size=0.2, label='label',
                                    save_path='../data')

train_data = torch.load('../data/train_loader.pth')
test_data = torch.load('../data/test_loader.pth')

for inputs, labels in train_data:
    print(inputs.shape, labels.shape)  # Just for checking
    break
94/17:
# Now we can train the model! 
n_classes=len(filtered_df.label.unique())
model = StockClassifier(n_features=len(filtered_df.columns), n_classes=n_classes)
print('number of classes: {}'.format(len(filtered_df.label.unique())))
trainer = ModelTrainer(model, '../data',
                       learning_rate=0.0001, epochs=20)
trainer.train(accuracy_threshold=0.6, num_classes=n_classes)
trainer.get_time()
94/18:
test_loss, test_accuracy, confusion_matrix = trainer.evaluate_model(trainer.test_loader, n_classes)
print('the Model achieved {} in testing accuracy'.format(test_accuracy))
trainer.get_time()
94/19:
def plot_confusion_matrix(confusion_matrix, class_names):
    """
    Plots a confusion matrix using Seaborn's heatmap.
    
    :param confusion_matrix: A 2D array of shape (num_classes, num_classes) representing the confusion matrix.
    :param class_names: A list of class names, ordered according to their index in the confusion matrix.
    """
    plt.figure(figsize=(10, 8))
    sns.heatmap(confusion_matrix, annot=True, fmt="d", cmap='Blues',
                xticklabels=class_names, yticklabels=class_names)

    plt.ylabel('True Label')
    plt.xlabel('Predicted Label')
    plt.title('Confusion Matrix')
    plt.show()

plot_confusion_matrix(confusion_matrix, ['really down', 'slightly down', 'neutral', 'slighty up', 'really up'])
94/20: confusion_matrix
94/21:
correct_predictions = np.trace(confusion_matrix)
total_predictions = np.sum(confusion_matrix)
accuracy = correct_predictions / total_predictions

print("Accuracy:", accuracy)
94/22: confusion_matrix
94/23: confusion_matrix[0]
94/24: confusion_matrix
94/25: np.array(confusion_matrix)
94/26:
confusion_matrix = np.array(confusion_matrix)
correct_predictions = np.trace(confusion_matrix)
total_predictions = np.sum(confusion_matrix)
accuracy = correct_predictions / total_predictions

print("Accuracy:", accuracy)
95/1:
import sys
sys.path.append('../')
from pipeline.coinbase_fetcher import CoinbaseDataFetcher
from pipeline.features import FeatureEngineer
from pipeline.create_dataloader import DataLoaderCreator
from pipeline.train import ModelTrainer
from models.simple_model import SimpleNN, EnhancedNN, resnet18
from models.time_series_model import StockClassifier

from datetime import datetime, timedelta
import torch
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
95/2:
# DO we want new data?
fetch = False

# First lets pull the data
fetcher = CoinbaseDataFetcher('', '')
pair = 'BTC-USD'
years = 10
start_time = datetime.utcnow() - timedelta(days=365 * years)  # Start from one year ago
end_time = datetime.utcnow()
#300-> 5-minute, 900-> 15-minute, 3600-> 1 hour
granularity = 900 

# The filename where the CSV will be saved
filename = '10_year_long_historical_data.csv'

# Fetch and save data as CSV
if fetch:
    data = fetcher.get_data_as_csv(pair, start_time, end_time, granularity, filename)
    print('Number of samples: {}'.format(len(data)))
95/3:
# Now lets shape those features
file = '../data/BTC/USD/BTC_USD_60min_20131202-20231130.csv' # or a DataFrame
#file = '../pipeline/data/BTC/USD/BTC_USD_5min_20131203-20231201.csv'
engineer = FeatureEngineer(file)
processed_data = engineer.get_processed_data(save=True) # we can turn save off if we plan to use filtered data

filtered_df = engineer.select_features_based_on_correlation(label='label')
print(filtered_df.columns, len(filtered_df.columns))
95/4: processed_data.columns
95/5: processed_data.dropna().columns
95/6:
ls = []
for i in range(0, 5):
    temp = filtered_df[filtered_df.label == i]
    ls.append(temp)
    print('For the class {} we have {} number of rows or {}% of the entire dataset'.format(i, len(temp), len(temp)/len(filtered_df)))
95/7:
# Now we can create a Dataloader
runner = DataLoaderCreator('../data/filtered_engineered_data.csv',
                               batch_size=64)

loaders = runner.create_dataloaders(test_size=0.2,
                                    val_size=0.2, label='label',
                                    save_path='../data')

train_data = torch.load('../data/train_loader.pth')
test_data = torch.load('../data/test_loader.pth')

for inputs, labels in train_data:
    print(inputs.shape, labels.shape)  # Just for checking
    break
95/8:
# Now we can train the model! 
n_classes=len(filtered_df.label.unique())
model = StockClassifier(n_features=len(filtered_df.columns), n_classes=n_classes)
print('number of classes: {}'.format(len(filtered_df.label.unique())))
trainer = ModelTrainer(model, '../data',
                       learning_rate=0.0001, epochs=20)
trainer.train(accuracy_threshold=0.6, num_classes=n_classes)
trainer.get_time()
96/1:
import sys
sys.path.append('../')
from pipeline.coinbase_fetcher import CoinbaseDataFetcher
from pipeline.features import FeatureEngineer
from pipeline.create_dataloader import DataLoaderCreator
from pipeline.train import ModelTrainer
from models.simple_model import SimpleNN, EnhancedNN, resnet18
from models.time_series_model import StockClassifier

from datetime import datetime, timedelta
import torch
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
96/2:
# DO we want new data?
fetch = False

# First lets pull the data
fetcher = CoinbaseDataFetcher('', '')
pair = 'BTC-USD'
years = 10
start_time = datetime.utcnow() - timedelta(days=365 * years)  # Start from one year ago
end_time = datetime.utcnow()
#300-> 5-minute, 900-> 15-minute, 3600-> 1 hour
granularity = 900 

# The filename where the CSV will be saved
filename = '10_year_long_historical_data.csv'

# Fetch and save data as CSV
if fetch:
    data = fetcher.get_data_as_csv(pair, start_time, end_time, granularity, filename)
    print('Number of samples: {}'.format(len(data)))
96/3:
# Now lets shape those features
file = '../data/BTC/USD/BTC_USD_60min_20131202-20231130.csv' # or a DataFrame
#file = '../pipeline/data/BTC/USD/BTC_USD_5min_20131203-20231201.csv'
engineer = FeatureEngineer(file)
processed_data = engineer.get_processed_data(save=True) # we can turn save off if we plan to use filtered data

filtered_df = engineer.select_features_based_on_correlation(label='label')
print(filtered_df.columns, len(filtered_df.columns))
96/4: processed_data.columns
96/5: processed_data.dropna().columns
96/6:
ls = []
for i in range(0, 5):
    temp = filtered_df[filtered_df.label == i]
    ls.append(temp)
    print('For the class {} we have {} number of rows or {}% of the entire dataset'.format(i, len(temp), len(temp)/len(filtered_df)))
96/7:
# Now we can create a Dataloader
runner = DataLoaderCreator('../data/filtered_engineered_data.csv',
                               batch_size=64)

loaders = runner.create_dataloaders(test_size=0.2,
                                    val_size=0.2, label='label',
                                    save_path='../data')

train_data = torch.load('../data/train_loader.pth')
test_data = torch.load('../data/test_loader.pth')

for inputs, labels in train_data:
    print(inputs.shape, labels.shape)  # Just for checking
    break
96/8:
# Now we can train the model! 
n_classes=len(filtered_df.label.unique())
model = EnhacedNN(n_features=len(filtered_df.columns), n_classes=n_classes)
print('number of classes: {}'.format(len(filtered_df.label.unique())))
trainer = ModelTrainer(model, '../data',
                       learning_rate=0.0001, epochs=20)
trainer.train(accuracy_threshold=0.6, num_classes=n_classes)
trainer.get_time()
96/9:
# Now we can train the model! 
n_classes=len(filtered_df.label.unique())
model = EnhancedNN(n_features=len(filtered_df.columns), n_classes=n_classes)
print('number of classes: {}'.format(len(filtered_df.label.unique())))
trainer = ModelTrainer(model, '../data',
                       learning_rate=0.0001, epochs=20)
trainer.train(accuracy_threshold=0.6, num_classes=n_classes)
trainer.get_time()
96/10:
test_loss, test_accuracy, confusion_matrix = trainer.evaluate_model(trainer.test_loader, n_classes)
print('the Model achieved {} in testing accuracy'.format(test_accuracy))
trainer.get_time()
96/11:
def plot_confusion_matrix(confusion_matrix, class_names):
    """
    Plots a confusion matrix using Seaborn's heatmap.
    
    :param confusion_matrix: A 2D array of shape (num_classes, num_classes) representing the confusion matrix.
    :param class_names: A list of class names, ordered according to their index in the confusion matrix.
    """
    plt.figure(figsize=(10, 8))
    sns.heatmap(confusion_matrix, annot=True, fmt="d", cmap='Blues',
                xticklabels=class_names, yticklabels=class_names)

    plt.ylabel('True Label')
    plt.xlabel('Predicted Label')
    plt.title('Confusion Matrix')
    plt.show()

plot_confusion_matrix(confusion_matrix, ['really down', 'slightly down', 'neutral', 'slighty up', 'really up'])
96/12:
confusion_matrix = np.array(confusion_matrix)
correct_predictions = np.trace(confusion_matrix)
total_predictions = np.sum(confusion_matrix)
accuracy = correct_predictions / total_predictions

print("Accuracy:", accuracy)
97/1:
import sys
sys.path.append('../')
from pipeline.coinbase_fetcher import CoinbaseDataFetcher
from pipeline.features import FeatureEngineer
from pipeline.create_dataloader import DataLoaderCreator
from pipeline.train import ModelTrainer
from models.simple_model import SimpleNN, EnhancedNN, resnet18
from models.time_series_model import StockClassifier

from datetime import datetime, timedelta
import torch
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
97/2:
# DO we want new data?
fetch = False

# First lets pull the data
fetcher = CoinbaseDataFetcher('', '')
pair = 'BTC-USD'
years = 10
start_time = datetime.utcnow() - timedelta(days=365 * years)  # Start from one year ago
end_time = datetime.utcnow()
#300-> 5-minute, 900-> 15-minute, 3600-> 1 hour
granularity = 900 

# The filename where the CSV will be saved
filename = '10_year_long_historical_data.csv'

# Fetch and save data as CSV
if fetch:
    data = fetcher.get_data_as_csv(pair, start_time, end_time, granularity, filename)
    print('Number of samples: {}'.format(len(data)))
97/3:
# Now lets shape those features
file = '../data/BTC/USD/BTC_USD_60min_20131202-20231130.csv' # or a DataFrame
#file = '../pipeline/data/BTC/USD/BTC_USD_5min_20131203-20231201.csv'
engineer = FeatureEngineer(file)
processed_data = engineer.get_processed_data(save=True) # we can turn save off if we plan to use filtered data

filtered_df = engineer.select_features_based_on_correlation(label='label')
print(filtered_df.columns, len(filtered_df.columns))
97/4: processed_data.columns
97/5: processed_data.dropna().columns
97/6:
ls = []
for i in range(0, 5):
    temp = filtered_df[filtered_df.label == i]
    ls.append(temp)
    print('For the class {} we have {} number of rows or {}% of the entire dataset'.format(i, len(temp), len(temp)/len(filtered_df)))
97/7:
# Now we can create a Dataloader
runner = DataLoaderCreator('../data/filtered_engineered_data.csv',
                               batch_size=64)

loaders = runner.create_dataloaders(test_size=0.2,
                                    val_size=0.2, label='label',
                                    save_path='../data')

train_data = torch.load('../data/train_loader.pth')
test_data = torch.load('../data/test_loader.pth')

for inputs, labels in train_data:
    print(inputs.shape, labels.shape)  # Just for checking
    break
97/8:
# Now we can train the model! 
n_classes=len(filtered_df.label.unique())
model = EnhancedNN(n_features=len(filtered_df.columns), n_classes=n_classes)
print('number of classes: {}'.format(len(filtered_df.label.unique())))
trainer = ModelTrainer(model, '../data',
                       learning_rate=0.0001, epochs=20)
trainer.train(accuracy_threshold=0.6, num_classes=n_classes)
trainer.get_time()
97/9:
test_loss, test_accuracy, confusion_matrix = trainer.evaluate_model(trainer.test_loader, n_classes)
print('the Model achieved {} in testing accuracy'.format(test_accuracy))
trainer.get_time()
97/10:
def plot_confusion_matrix(confusion_matrix, class_names):
    """
    Plots a confusion matrix using Seaborn's heatmap.
    
    :param confusion_matrix: A 2D array of shape (num_classes, num_classes) representing the confusion matrix.
    :param class_names: A list of class names, ordered according to their index in the confusion matrix.
    """
    plt.figure(figsize=(10, 8))
    sns.heatmap(confusion_matrix, annot=True, fmt="d", cmap='Blues',
                xticklabels=class_names, yticklabels=class_names)

    plt.ylabel('True Label')
    plt.xlabel('Predicted Label')
    plt.title('Confusion Matrix')
    plt.show()

plot_confusion_matrix(confusion_matrix, ['really down', 'slightly down', 'neutral', 'slighty up', 'really up'])
97/11:
confusion_matrix = np.array(confusion_matrix)
correct_predictions = np.trace(confusion_matrix)
total_predictions = np.sum(confusion_matrix)
accuracy = correct_predictions / total_predictions

print("Accuracy:", accuracy)
97/12:
confusion_matrix = np.array(confusion_matrix)
correct_predictions = np.trace(confusion_matrix)
total_predictions = np.sum(confusion_matrix)
accuracy = correct_predictions / total_predictions

print("Accuracy:", accuracy)
98/1:
import sys
sys.path.append('../')
from pipeline.coinbase_fetcher import CoinbaseDataFetcher
from pipeline.features import FeatureEngineer
from pipeline.create_dataloader import DataLoaderCreator
from pipeline.train import ModelTrainer
from models.simple_model import SimpleNN, EnhancedNN, resnet18
from models.time_series_model import StockClassifier

from datetime import datetime, timedelta
import torch
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
98/2:
# DO we want new data?
fetch = False

# First lets pull the data
fetcher = CoinbaseDataFetcher('', '')
pair = 'BTC-USD'
years = 10
start_time = datetime.utcnow() - timedelta(days=365 * years)  # Start from one year ago
end_time = datetime.utcnow()
#300-> 5-minute, 900-> 15-minute, 3600-> 1 hour
granularity = 900 

# The filename where the CSV will be saved
filename = '10_year_long_historical_data.csv'

# Fetch and save data as CSV
if fetch:
    data = fetcher.get_data_as_csv(pair, start_time, end_time, granularity, filename)
    print('Number of samples: {}'.format(len(data)))
98/3:
# Now lets shape those features
file = '../data/BTC/USD/BTC_USD_60min_20131202-20231130.csv' # or a DataFrame
#file = '../pipeline/data/BTC/USD/BTC_USD_5min_20131203-20231201.csv'
engineer = FeatureEngineer(file)
processed_data = engineer.get_processed_data(save=True) # we can turn save off if we plan to use filtered data

filtered_df = engineer.select_features_based_on_correlation(label='label')
print(filtered_df.columns, len(filtered_df.columns))
98/4: processed_data.columns
98/5: processed_data.dropna().columns
98/6:
ls = []
for i in range(0, 5):
    temp = filtered_df[filtered_df.label == i]
    ls.append(temp)
    print('For the class {} we have {} number of rows or {}% of the entire dataset'.format(i, len(temp), len(temp)/len(filtered_df)))
98/7:
# Now we can create a Dataloader
runner = DataLoaderCreator('../data/filtered_engineered_data.csv',
                               batch_size=64)

loaders = runner.create_dataloaders(test_size=0.2,
                                    val_size=0.2, label='label',
                                    save_path='../data')

train_data = torch.load('../data/train_loader.pth')
test_data = torch.load('../data/test_loader.pth')

for inputs, labels in train_data:
    print(inputs.shape, labels.shape)  # Just for checking
    break
98/8:
# Now we can train the model! 
n_classes=len(filtered_df.label.unique())
model = StockClassifier(n_features=len(filtered_df.columns), n_classes=n_classes)
print('number of classes: {}'.format(len(filtered_df.label.unique())))
trainer = ModelTrainer(model, '../data',
                       learning_rate=0.0001, epochs=20)
trainer.train(accuracy_threshold=0.6, num_classes=n_classes)
trainer.get_time()
99/1:
import sys
sys.path.append('../')
from pipeline.coinbase_fetcher import CoinbaseDataFetcher
from pipeline.features import FeatureEngineer
from pipeline.create_dataloader import DataLoaderCreator
from pipeline.train import ModelTrainer
from models.simple_model import SimpleNN, EnhancedNN, resnet18
from models.time_series_model import StockClassifier

from datetime import datetime, timedelta
import torch
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
99/2:
# DO we want new data?
fetch = False

# First lets pull the data
fetcher = CoinbaseDataFetcher('', '')
pair = 'BTC-USD'
years = 10
start_time = datetime.utcnow() - timedelta(days=365 * years)  # Start from one year ago
end_time = datetime.utcnow()
#300-> 5-minute, 900-> 15-minute, 3600-> 1 hour
granularity = 900 

# The filename where the CSV will be saved
filename = '10_year_long_historical_data.csv'

# Fetch and save data as CSV
if fetch:
    data = fetcher.get_data_as_csv(pair, start_time, end_time, granularity, filename)
    print('Number of samples: {}'.format(len(data)))
99/3:
# Now lets shape those features
file = '../data/BTC/USD/BTC_USD_60min_20131202-20231130.csv' # or a DataFrame
#file = '../pipeline/data/BTC/USD/BTC_USD_5min_20131203-20231201.csv'
engineer = FeatureEngineer(file)
processed_data = engineer.get_processed_data(save=True) # we can turn save off if we plan to use filtered data

filtered_df = engineer.select_features_based_on_correlation(label='label')
print(filtered_df.columns, len(filtered_df.columns))
99/4: processed_data.columns
99/5: processed_data.dropna().columns
99/6:
ls = []
for i in range(0, 5):
    temp = filtered_df[filtered_df.label == i]
    ls.append(temp)
    print('For the class {} we have {} number of rows or {}% of the entire dataset'.format(i, len(temp), len(temp)/len(filtered_df)))
99/7:
# Now we can create a Dataloader
runner = DataLoaderCreator('../data/filtered_engineered_data.csv',
                               batch_size=64)

loaders = runner.create_dataloaders(test_size=0.2,
                                    val_size=0.2, label='label',
                                    save_path='../data')

train_data = torch.load('../data/train_loader.pth')
test_data = torch.load('../data/test_loader.pth')

for inputs, labels in train_data:
    print(inputs.shape, labels.shape)  # Just for checking
    break
99/8:
# Now we can train the model! 
n_classes=len(filtered_df.label.unique())
model = StockClassifier(n_features=len(filtered_df.columns), n_classes=n_classes)
print('number of classes: {}'.format(len(filtered_df.label.unique())))
trainer = ModelTrainer(model, '../data',
                       learning_rate=0.0001, epochs=20)
trainer.train(accuracy_threshold=0.6, num_classes=n_classes)
trainer.get_time()
102/1:
import sys
sys.path.append('../')
from pipeline.coinbase_fetcher import CoinbaseDataFetcher
from pipeline.features import FeatureEngineer
from pipeline.create_dataloader import DataLoaderCreator
from pipeline.train import ModelTrainer
from models.simple_model import SimpleNN, EnhancedNN, resnet18
from models.time_series_model import StockClassifier

from datetime import datetime, timedelta
import torch
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
102/2:
# DO we want new data?
fetch = False

# First lets pull the data
fetcher = CoinbaseDataFetcher('', '')
pair = 'BTC-USD'
years = 10
start_time = datetime.utcnow() - timedelta(days=365 * years)  # Start from one year ago
end_time = datetime.utcnow()
#300-> 5-minute, 900-> 15-minute, 3600-> 1 hour
granularity = 900 

# The filename where the CSV will be saved
filename = '10_year_long_historical_data.csv'

# Fetch and save data as CSV
if fetch:
    data = fetcher.get_data_as_csv(pair, start_time, end_time, granularity, filename)
    print('Number of samples: {}'.format(len(data)))
102/3:
# Now lets shape those features
file = '../data/BTC/USD/BTC_USD_60min_20131202-20231130.csv' # or a DataFrame
#file = '../pipeline/data/BTC/USD/BTC_USD_5min_20131203-20231201.csv'
engineer = FeatureEngineer(file)
processed_data = engineer.get_processed_data(save=True) # we can turn save off if we plan to use filtered data

filtered_df = engineer.select_features_based_on_correlation(label='label')
print(filtered_df.columns, len(filtered_df.columns))
102/4: processed_data.columns
102/5: processed_data.dropna().columns
102/6:
ls = []
for i in range(0, 5):
    temp = filtered_df[filtered_df.label == i]
    ls.append(temp)
    print('For the class {} we have {} number of rows or {}% of the entire dataset'.format(i, len(temp), len(temp)/len(filtered_df)))
102/7:
# Now we can create a Dataloader
runner = DataLoaderCreator('../data/filtered_engineered_data.csv',
                               batch_size=64)

loaders = runner.create_dataloaders(test_size=0.2,
                                    val_size=0.2, label='label',
                                    save_path='../data')

train_data = torch.load('../data/train_loader.pth')
test_data = torch.load('../data/test_loader.pth')

for inputs, labels in train_data:
    print(inputs.shape, labels.shape)  # Just for checking
    break
102/8:
# Now we can train the model! 
n_classes=len(filtered_df.label.unique())
model = StockClassifier(n_features=len(filtered_df.columns), n_classes=n_classes)
print('number of classes: {}'.format(len(filtered_df.label.unique())))
trainer = ModelTrainer(model, '../data',
                       learning_rate=0.0001, epochs=2)
trainer.train(accuracy_threshold=0.6, num_classes=n_classes)
trainer.get_time()
103/1:
import sys
sys.path.append('../')
from pipeline.coinbase_fetcher import CoinbaseDataFetcher
from pipeline.features import FeatureEngineer
from pipeline.create_dataloader import DataLoaderCreator
from pipeline.train import ModelTrainer
from models.simple_model import SimpleNN, EnhancedNN, resnet18
from models.time_series_model import StockClassifier

from datetime import datetime, timedelta
import torch
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
103/2:
# DO we want new data?
fetch = False

# First lets pull the data
fetcher = CoinbaseDataFetcher('', '')
pair = 'BTC-USD'
years = 10
start_time = datetime.utcnow() - timedelta(days=365 * years)  # Start from one year ago
end_time = datetime.utcnow()
#300-> 5-minute, 900-> 15-minute, 3600-> 1 hour
granularity = 900 

# The filename where the CSV will be saved
filename = '10_year_long_historical_data.csv'

# Fetch and save data as CSV
if fetch:
    data = fetcher.get_data_as_csv(pair, start_time, end_time, granularity, filename)
    print('Number of samples: {}'.format(len(data)))
103/3:
# Now lets shape those features
file = '../data/BTC/USD/BTC_USD_60min_20131202-20231130.csv' # or a DataFrame
#file = '../pipeline/data/BTC/USD/BTC_USD_5min_20131203-20231201.csv'
engineer = FeatureEngineer(file)
processed_data = engineer.get_processed_data(save=True) # we can turn save off if we plan to use filtered data

filtered_df = engineer.select_features_based_on_correlation(label='label')
print(filtered_df.columns, len(filtered_df.columns))
103/4: processed_data.columns
103/5: processed_data.dropna().columns
103/6:
ls = []
for i in range(0, 5):
    temp = filtered_df[filtered_df.label == i]
    ls.append(temp)
    print('For the class {} we have {} number of rows or {}% of the entire dataset'.format(i, len(temp), len(temp)/len(filtered_df)))
103/7:
# Now we can create a Dataloader
runner = DataLoaderCreator('../data/filtered_engineered_data.csv',
                               batch_size=64)

loaders = runner.create_dataloaders(test_size=0.2,
                                    val_size=0.2, label='label',
                                    save_path='../data')

train_data = torch.load('../data/train_loader.pth')
test_data = torch.load('../data/test_loader.pth')

for inputs, labels in train_data:
    print(inputs.shape, labels.shape)  # Just for checking
    break
103/8:
# Now we can train the model! 
n_classes=len(filtered_df.label.unique())
model = StockClassifier(n_features=len(filtered_df.columns), n_classes=n_classes)
print('number of classes: {}'.format(len(filtered_df.label.unique())))
trainer = ModelTrainer(model, '../data',
                       learning_rate=0.0001, epochs=2)
trainer.train(accuracy_threshold=0.6, num_classes=n_classes)
trainer.get_time()
105/1:
import sys
sys.path.append('../')
from pipeline.coinbase_fetcher import CoinbaseDataFetcher
from pipeline.features import FeatureEngineer
from pipeline.create_dataloader import DataLoaderCreator
from pipeline.train import ModelTrainer
from models.simple_model import SimpleNN, EnhancedNN, resnet18
from models.time_series_model import StockClassifier

from datetime import datetime, timedelta
import torch
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
105/2:
# DO we want new data?
fetch = False

# First lets pull the data
fetcher = CoinbaseDataFetcher('', '')
pair = 'BTC-USD'
years = 10
start_time = datetime.utcnow() - timedelta(days=365 * years)  # Start from one year ago
end_time = datetime.utcnow()
#300-> 5-minute, 900-> 15-minute, 3600-> 1 hour
granularity = 900 

# The filename where the CSV will be saved
filename = '10_year_long_historical_data.csv'

# Fetch and save data as CSV
if fetch:
    data = fetcher.get_data_as_csv(pair, start_time, end_time, granularity, filename)
    print('Number of samples: {}'.format(len(data)))
105/3:
# Now lets shape those features
file = '../data/BTC/USD/BTC_USD_60min_20131202-20231130.csv' # or a DataFrame
#file = '../pipeline/data/BTC/USD/BTC_USD_5min_20131203-20231201.csv'
engineer = FeatureEngineer(file)
processed_data = engineer.get_processed_data(save=True) # we can turn save off if we plan to use filtered data

filtered_df = engineer.select_features_based_on_correlation(label='label')
print(filtered_df.columns, len(filtered_df.columns))
105/4: processed_data.columns
105/5: processed_data.dropna().columns
105/6:
ls = []
for i in range(0, 5):
    temp = filtered_df[filtered_df.label == i]
    ls.append(temp)
    print('For the class {} we have {} number of rows or {}% of the entire dataset'.format(i, len(temp), len(temp)/len(filtered_df)))
105/7:
# Now we can create a Dataloader
runner = DataLoaderCreator('../data/filtered_engineered_data.csv',
                               batch_size=64)

loaders = runner.create_dataloaders(test_size=0.2,
                                    val_size=0.2, label='label',
                                    save_path='../data')

train_data = torch.load('../data/train_loader.pth')
test_data = torch.load('../data/test_loader.pth')

for inputs, labels in train_data:
    print(inputs.shape, labels.shape)  # Just for checking
    break
105/8:
# Now we can train the model! 
n_classes=len(filtered_df.label.unique())
model = StockClassifier(n_features=len(filtered_df.columns), n_classes=n_classes)
print('number of classes: {}'.format(len(filtered_df.label.unique())))
trainer = ModelTrainer(model, '../data',
                       learning_rate=0.0001, epochs=2)
trainer.train(accuracy_threshold=0.6, num_classes=n_classes)
trainer.get_time()
107/1:
import sys
sys.path.append('../')
from pipeline.coinbase_fetcher import CoinbaseDataFetcher
from pipeline.features import FeatureEngineer
from pipeline.create_dataloader import DataLoaderCreator
from pipeline.train import ModelTrainer
from models.simple_model import SimpleNN, EnhancedNN, resnet18
from models.time_series_model import StockClassifier

from datetime import datetime, timedelta
import torch
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
107/2:
# DO we want new data?
fetch = False

# First lets pull the data
fetcher = CoinbaseDataFetcher('', '')
pair = 'BTC-USD'
years = 10
start_time = datetime.utcnow() - timedelta(days=365 * years)  # Start from one year ago
end_time = datetime.utcnow()
#300-> 5-minute, 900-> 15-minute, 3600-> 1 hour
granularity = 900 

# The filename where the CSV will be saved
filename = '10_year_long_historical_data.csv'

# Fetch and save data as CSV
if fetch:
    data = fetcher.get_data_as_csv(pair, start_time, end_time, granularity, filename)
    print('Number of samples: {}'.format(len(data)))
107/3:
# Now lets shape those features
file = '../data/BTC/USD/BTC_USD_60min_20131202-20231130.csv' # or a DataFrame
#file = '../pipeline/data/BTC/USD/BTC_USD_5min_20131203-20231201.csv'
engineer = FeatureEngineer(file)
processed_data = engineer.get_processed_data(save=True) # we can turn save off if we plan to use filtered data

filtered_df = engineer.select_features_based_on_correlation(label='label')
print(filtered_df.columns, len(filtered_df.columns))
107/4: processed_data.columns
107/5: processed_data.dropna().columns
107/6:
ls = []
for i in range(0, 5):
    temp = filtered_df[filtered_df.label == i]
    ls.append(temp)
    print('For the class {} we have {} number of rows or {}% of the entire dataset'.format(i, len(temp), len(temp)/len(filtered_df)))
107/7:
# Now we can create a Dataloader
runner = DataLoaderCreator('../data/filtered_engineered_data.csv',
                               batch_size=64)

loaders = runner.create_dataloaders(test_size=0.2,
                                    val_size=0.2, label='label',
                                    save_path='../data')

train_data = torch.load('../data/train_loader.pth')
test_data = torch.load('../data/test_loader.pth')

for inputs, labels in train_data:
    print(inputs.shape, labels.shape)  # Just for checking
    break
107/8:
# Now we can train the model! 
n_classes=len(filtered_df.label.unique())
model = StockClassifier(n_features=len(filtered_df.columns), n_classes=n_classes)
print('number of classes: {}'.format(len(filtered_df.label.unique())))
trainer = ModelTrainer(model, '../data',
                       learning_rate=0.0001, epochs=2)
trainer.train(accuracy_threshold=0.6, num_classes=n_classes)
trainer.get_time()
107/9:
test_loss, test_accuracy, confusion_matrix = trainer.evaluate_model(trainer.test_loader, n_classes)
trainer.plot_confusion_matrix(confusion_matrix)
print('the Model achieved {} in testing accuracy'.format(test_accuracy))
trainer.get_time()
107/10:
def plot_confusion_matrix(confusion_matrix, class_names):
    """
    Plots a confusion matrix using Seaborn's heatmap.
    
    :param confusion_matrix: A 2D array of shape (num_classes, num_classes) representing the confusion matrix.
    :param class_names: A list of class names, ordered according to their index in the confusion matrix.
    """
    plt.figure(figsize=(10, 8))
    sns.heatmap(confusion_matrix, annot=True, fmt="d", cmap='Blues',
                xticklabels=class_names, yticklabels=class_names)

    plt.ylabel('True Label')
    plt.xlabel('Predicted Label')
    plt.title('Confusion Matrix')
    plt.show()

plot_confusion_matrix(confusion_matrix, ['really down', 'slightly down', 'neutral', 'slighty up', 'really up'])
107/11:
test_loss, test_accuracy, confusion_matrix = trainer.evaluate_model(trainer.test_loader, n_classes)
# trainer.plot_confusion_matrix(confusion_matrix)
print('the Model achieved {} in testing accuracy'.format(test_accuracy))
trainer.get_time()
107/12:
def plot_confusion_matrix(confusion_matrix, class_names):
    """
    Plots a confusion matrix using Seaborn's heatmap.
    
    :param confusion_matrix: A 2D array of shape (num_classes, num_classes) representing the confusion matrix.
    :param class_names: A list of class names, ordered according to their index in the confusion matrix.
    """
    plt.figure(figsize=(10, 8))
    sns.heatmap(confusion_matrix, annot=True, fmt="d", cmap='Blues',
                xticklabels=class_names, yticklabels=class_names)

    plt.ylabel('True Label')
    plt.xlabel('Predicted Label')
    plt.title('Confusion Matrix')
    plt.show()

plot_confusion_matrix(confusion_matrix, ['really down', 'slightly down', 'neutral', 'slighty up', 'really up'])
107/13:
test_loss, test_accuracy, confusion_matrix = trainer.evaluate_model(trainer.test_loader, n_classes)
trainer.plot_confusion_matrix(confusion_matrix)
print('the Model achieved {} in testing accuracy'.format(test_accuracy))
trainer.get_time()
109/1:
import sys
sys.path.append('../')
from pipeline.coinbase_fetcher import CoinbaseDataFetcher
from pipeline.features import FeatureEngineer
from pipeline.create_dataloader import DataLoaderCreator
from pipeline.train import ModelTrainer
from models.simple_model import SimpleNN, EnhancedNN, resnet18
from models.time_series_model import StockClassifier

from datetime import datetime, timedelta
import torch
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
109/2:
# DO we want new data?
fetch = False

# First lets pull the data
fetcher = CoinbaseDataFetcher('', '')
pair = 'BTC-USD'
years = 10
start_time = datetime.utcnow() - timedelta(days=365 * years)  # Start from one year ago
end_time = datetime.utcnow()
#300-> 5-minute, 900-> 15-minute, 3600-> 1 hour
granularity = 900 

# The filename where the CSV will be saved
filename = '10_year_long_historical_data.csv'

# Fetch and save data as CSV
if fetch:
    data = fetcher.get_data_as_csv(pair, start_time, end_time, granularity, filename)
    print('Number of samples: {}'.format(len(data)))
109/3:
# Now lets shape those features
file = '../data/BTC/USD/BTC_USD_60min_20131202-20231130.csv' # or a DataFrame
#file = '../pipeline/data/BTC/USD/BTC_USD_5min_20131203-20231201.csv'
engineer = FeatureEngineer(file)
processed_data = engineer.get_processed_data(save=True) # we can turn save off if we plan to use filtered data

filtered_df = engineer.select_features_based_on_correlation(label='label')
print(filtered_df.columns, len(filtered_df.columns))
109/4: processed_data.columns
109/5: processed_data.dropna().columns
109/6:
ls = []
for i in range(0, 5):
    temp = filtered_df[filtered_df.label == i]
    ls.append(temp)
    print('For the class {} we have {} number of rows or {}% of the entire dataset'.format(i, len(temp), len(temp)/len(filtered_df)))
109/7:
# Now we can create a Dataloader
runner = DataLoaderCreator('../data/filtered_engineered_data.csv',
                               batch_size=64)

loaders = runner.create_dataloaders(test_size=0.2,
                                    val_size=0.2, label='label',
                                    save_path='../data')

train_data = torch.load('../data/train_loader.pth')
test_data = torch.load('../data/test_loader.pth')

for inputs, labels in train_data:
    print(inputs.shape, labels.shape)  # Just for checking
    break
109/8:
# Now we can train the model! 
n_classes=len(filtered_df.label.unique())
model = StockClassifier(n_features=len(filtered_df.columns), n_classes=n_classes)
print('number of classes: {}'.format(len(filtered_df.label.unique())))
trainer = ModelTrainer(model, '../data',
                       learning_rate=0.0001, epochs=2)
trainer.train(accuracy_threshold=0.6, num_classes=n_classes)
trainer.get_time()
109/9:
test_loss, test_accuracy, confusion_matrix = trainer.evaluate_model(trainer.test_loader, n_classes)
trainer.plot_confusion_matrix(confusion_matrix)
print('the Model achieved {} in testing accuracy'.format(test_accuracy))
trainer.get_time()
109/10:
def plot_confusion_matrix(confusion_matrix, class_names):
    """
    Plots a confusion matrix using Seaborn's heatmap.
    
    :param confusion_matrix: A 2D array of shape (num_classes, num_classes) representing the confusion matrix.
    :param class_names: A list of class names, ordered according to their index in the confusion matrix.
    """
    plt.figure(figsize=(10, 8))
    sns.heatmap(confusion_matrix, annot=True, fmt="d", cmap='Blues',
                xticklabels=class_names, yticklabels=class_names)

    plt.ylabel('True Label')
    plt.xlabel('Predicted Label')
    plt.title('Confusion Matrix')
    plt.show()

plot_confusion_matrix(confusion_matrix, ['really down', 'slightly down', 'neutral', 'slighty up', 'really up'])
109/11:
confusion_matrix = np.array(confusion_matrix)
correct_predictions = np.trace(confusion_matrix)
total_predictions = np.sum(confusion_matrix)
accuracy = correct_predictions / total_predictions

print("Accuracy:", accuracy)
109/12:
# Now we can train the model! 
n_classes=len(filtered_df.label.unique())
model = StockClassifier(n_features=len(filtered_df.columns), n_classes=n_classes)
print('number of classes: {}'.format(len(filtered_df.label.unique())))
trainer = ModelTrainer(model, '../data',
                       learning_rate=0.001, epochs=10)
trainer.train(accuracy_threshold=0.6, num_classes=n_classes)
trainer.get_time()
109/13:
# Now we can train the model! 
n_classes=len(filtered_df.label.unique())
model = StockClassifier(n_features=len(filtered_df.columns), n_classes=n_classes)
print('number of classes: {}'.format(len(filtered_df.label.unique())))
trainer = ModelTrainer(model, '../data',
                       learning_rate=0.01, epochs=10)
trainer.train(accuracy_threshold=0.6, num_classes=n_classes)
trainer.get_time()
109/14:
test_loss, test_accuracy, confusion_matrix = trainer.evaluate_model(trainer.test_loader, n_classes)
trainer.plot_confusion_matrix(confusion_matrix)
print('the Model achieved {} in testing accuracy'.format(test_accuracy))
trainer.get_time()
109/15:
# Now lets shape those features
file = '../data/BTC/USD/BTC_USD_60min_20131202-20231130.csv' # or a DataFrame
file = '../pipeline/data/BTC/USD/BTC_USD_5min_20131203-20231201.csv'
engineer = FeatureEngineer(file)
processed_data = engineer.get_processed_data(save=True) # we can turn save off if we plan to use filtered data

filtered_df = engineer.select_features_based_on_correlation(label='label')
print(filtered_df.columns, len(filtered_df.columns))
109/16: processed_data.columns
109/17: processed_data.dropna().columns
109/18:
ls = []
for i in range(0, 5):
    temp = filtered_df[filtered_df.label == i]
    ls.append(temp)
    print('For the class {} we have {} number of rows or {}% of the entire dataset'.format(i, len(temp), len(temp)/len(filtered_df)))
109/19:
# Now we can create a Dataloader
runner = DataLoaderCreator('../data/filtered_engineered_data.csv',
                               batch_size=64)

loaders = runner.create_dataloaders(test_size=0.2,
                                    val_size=0.2, label='label',
                                    save_path='../data')

train_data = torch.load('../data/train_loader.pth')
test_data = torch.load('../data/test_loader.pth')

for inputs, labels in train_data:
    print(inputs.shape, labels.shape)  # Just for checking
    break
109/20:
# Now we can train the model! 
n_classes=len(filtered_df.label.unique())
model = StockClassifier(n_features=len(filtered_df.columns), n_classes=n_classes)
print('number of classes: {}'.format(len(filtered_df.label.unique())))
trainer = ModelTrainer(model, '../data',
                       learning_rate=0.01, epochs=10)
trainer.train(accuracy_threshold=0.6, num_classes=n_classes)
trainer.get_time()
109/21:
# Now we can create a Dataloader
runner = DataLoaderCreator('../data/filtered_engineered_data.csv',
                               batch_size=1024)

loaders = runner.create_dataloaders(test_size=0.2,
                                    val_size=0.2, label='label',
                                    save_path='../data')

train_data = torch.load('../data/train_loader.pth')
test_data = torch.load('../data/test_loader.pth')

for inputs, labels in train_data:
    print(inputs.shape, labels.shape)  # Just for checking
    break
109/22:
# Now we can train the model! 
n_classes=len(filtered_df.label.unique())
model = StockClassifier(n_features=len(filtered_df.columns), n_classes=n_classes)
print('number of classes: {}'.format(len(filtered_df.label.unique())))
trainer = ModelTrainer(model, '../data',
                       learning_rate=0.01, epochs=10)
trainer.train(accuracy_threshold=0.6, num_classes=n_classes)
trainer.get_time()
109/23:
test_loss, test_accuracy, confusion_matrix = trainer.evaluate_model(trainer.test_loader, n_classes)
trainer.plot_confusion_matrix(confusion_matrix)
print('the Model achieved {} in testing accuracy'.format(test_accuracy))
trainer.get_time()
110/1:
import sys
sys.path.append('../')
from pipeline.coinbase_fetcher import CoinbaseDataFetcher
from pipeline.features import FeatureEngineer
from pipeline.create_dataloader import DataLoaderCreator
from pipeline.train import ModelTrainer
from models.simple_model import SimpleNN, EnhancedNN, resnet18
from models.time_series_model import StockClassifier

from datetime import datetime, timedelta
import torch
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
110/2:
# DO we want new data?
fetch = False

# First lets pull the data
fetcher = CoinbaseDataFetcher('', '')
pair = 'BTC-USD'
years = 10
start_time = datetime.utcnow() - timedelta(days=365 * years)  # Start from one year ago
end_time = datetime.utcnow()
#300-> 5-minute, 900-> 15-minute, 3600-> 1 hour
granularity = 900 

# The filename where the CSV will be saved
filename = '10_year_long_historical_data.csv'

# Fetch and save data as CSV
if fetch:
    data = fetcher.get_data_as_csv(pair, start_time, end_time, granularity, filename)
    print('Number of samples: {}'.format(len(data)))
110/3:
# Now lets shape those features
# file = '../data/BTC/USD/BTC_USD_60min_20131202-20231130.csv' # or a DataFrame
file = '../pipeline/data/BTC/USD/BTC_USD_5min_20131203-20231201.csv'
engineer = FeatureEngineer(file)
processed_data = engineer.get_processed_data(save=True) # we can turn save off if we plan to use filtered data

filtered_df = engineer.select_features_based_on_correlation(label='label')
print(filtered_df.columns, len(filtered_df.columns))
110/4: processed_data.columns
110/5: processed_data.dropna().columns
110/6:
ls = []
for i in range(0, 5):
    temp = filtered_df[filtered_df.label == i]
    ls.append(temp)
    print('For the class {} we have {} number of rows or {}% of the entire dataset'.format(i, len(temp), len(temp)/len(filtered_df)))
110/7:
# Now we can create a Dataloader
runner = DataLoaderCreator('../data/filtered_engineered_data.csv',
                               batch_size=1024)

loaders = runner.create_dataloaders(test_size=0.2,
                                    val_size=0.2, label='label',
                                    save_path='../data')

train_data = torch.load('../data/train_loader.pth')
test_data = torch.load('../data/test_loader.pth')

for inputs, labels in train_data:
    print(inputs.shape, labels.shape)  # Just for checking
    break
110/8:
# Now we can train the model! 
n_classes=len(filtered_df.label.unique())
model = StockClassifier(n_features=len(filtered_df.columns), n_classes=n_classes)
print('number of classes: {}'.format(len(filtered_df.label.unique())))
trainer = ModelTrainer(model, '../data',
                       learning_rate=0.01, epochs=10)
trainer.train(accuracy_threshold=0.6, num_classes=n_classes)
trainer.get_time()
110/9:
test_loss, test_accuracy, confusion_matrix = trainer.evaluate_model(trainer.test_loader, n_classes)
trainer.plot_confusion_matrix(confusion_matrix)
print('the Model achieved {} in testing accuracy'.format(test_accuracy))
trainer.get_time()
110/10:
# Now we can train the model! 
n_classes=len(filtered_df.label.unique())
model = EnhancedNN(n_features=len(filtered_df.columns), n_classes=n_classes)
print('number of classes: {}'.format(len(filtered_df.label.unique())))
trainer = ModelTrainer(model, '../data',
                       learning_rate=0.01, epochs=10)
trainer.train(accuracy_threshold=0.6, num_classes=n_classes)
trainer.get_time()
110/11:
# Now we can create a Dataloader
runner = DataLoaderCreator('../data/filtered_engineered_data.csv',
                               batch_size=2048)

loaders = runner.create_dataloaders(test_size=0.2,
                                    val_size=0.2, label='label',
                                    save_path='../data')

train_data = torch.load('../data/train_loader.pth')
test_data = torch.load('../data/test_loader.pth')

for inputs, labels in train_data:
    print(inputs.shape, labels.shape)  # Just for checking
    break
110/12:
# Now we can train the model! 
n_classes=len(filtered_df.label.unique())
model = EnhancedNN(n_features=len(filtered_df.columns), n_classes=n_classes)
print('number of classes: {}'.format(len(filtered_df.label.unique())))
trainer = ModelTrainer(model, '../data',
                       learning_rate=0.01, epochs=10)
trainer.train(accuracy_threshold=0.6, num_classes=n_classes)
trainer.get_time()
110/13:
test_loss, test_accuracy, confusion_matrix = trainer.evaluate_model(trainer.test_loader, n_classes)
trainer.plot_confusion_matrix(confusion_matrix)
print('the Model achieved {} in testing accuracy'.format(test_accuracy))
trainer.get_time()
110/14:
# Now we can train the model! 
n_classes=len(filtered_df.label.unique())
model = StockClassifier(n_features=len(filtered_df.columns), n_classes=n_classes)
print('number of classes: {}'.format(len(filtered_df.label.unique())))
trainer = ModelTrainer(model, '../data',
                       learning_rate=0.01, epochs=10)
trainer.train(accuracy_threshold=0.6, num_classes=n_classes)
trainer.get_time()
110/15:
test_loss, test_accuracy, confusion_matrix = trainer.evaluate_model(trainer.test_loader, n_classes)
trainer.plot_confusion_matrix(confusion_matrix)
print('the Model achieved {} in testing accuracy'.format(test_accuracy))
trainer.get_time()
110/16:
plt.scatter(processed_data.index, processed_data['Close'], c=df['label'], cmap='viridis')
plt.colorbar(label='Color scale')  # Show color scale
plt.xlabel('X axis (Index)')
plt.ylabel('Y axis')
plt.title('Scatter Plot with Colored Points')
plt.show()
110/17:
plt.scatter(processed_data.index, processed_data['Close'], c=processed_data['label'], cmap='viridis')
plt.colorbar(label='Color scale')  # Show color scale
plt.xlabel('X axis (Index)')
plt.ylabel('Y axis')
plt.title('Scatter Plot with Colored Points')
plt.show()
110/18:
plt.scatter(processed_data.index, processed_data['Close'], c=processed_data['future_price'], cmap='viridis')
plt.colorbar(label='Color scale')  # Show color scale
plt.xlabel('X axis (Index)')
plt.ylabel('Y axis')
plt.title('Scatter Plot with Colored Points')
plt.show()
110/19:
plt.scatter(processed_data.index, processed_data['Close'], c=processed_data['Candle_Color'], cmap='viridis')
plt.colorbar(label='Color scale')  # Show color scale
plt.xlabel('X axis (Index)')
plt.ylabel('Y axis')
plt.title('Scatter Plot with Colored Points')
plt.show()
110/20:
plt.scatter(processed_data.index, processed_data['Close'], c=processed_data['Trend'], cmap='viridis')
plt.colorbar(label='Color scale')  # Show color scale
plt.xlabel('X axis (Index)')
plt.ylabel('Y axis')
plt.title('Scatter Plot with Colored Points')
plt.show()
110/21:
plt.scatter(processed_data.index, processed_data['Close'], c=processed_data['label'], cmap='viridis')
plt.colorbar(label='Color scale')  # Show color scale
plt.xlabel('X axis (Index)')
plt.ylabel('Y axis')
plt.title('Scatter Plot with Colored Points')
plt.show()
116/1: runfile('/home/whaleshark/Documents/git/whale-shark/trade_tools/trading_projections.py', wdir='/home/whaleshark/Documents/git/whale-shark/trade_tools')
116/2: !pip install plotly
116/3: runfile('/home/whaleshark/Documents/git/whale-shark/trade_tools/trading_projections.py', wdir='/home/whaleshark/Documents/git/whale-shark/trade_tools')
116/4: runfile('/home/whaleshark/Documents/git/whale-shark/trade_tools/trading_projections.py', wdir='/home/whaleshark/Documents/git/whale-shark/trade_tools')
116/5: runfile('/home/whaleshark/Documents/git/whale-shark/trade_tools/trading_projections.py', wdir='/home/whaleshark/Documents/git/whale-shark/trade_tools')
116/6: runfile('/home/whaleshark/Documents/git/whale-shark/trade_tools/trading_projections.py', wdir='/home/whaleshark/Documents/git/whale-shark/trade_tools')
116/7: runfile('/home/whaleshark/Documents/git/whale-shark/trade_tools/trading_projections.py', wdir='/home/whaleshark/Documents/git/whale-shark/trade_tools')
116/8: df
116/9: runfile('/home/whaleshark/Documents/git/whale-shark/trade_tools/trading_projections.py', wdir='/home/whaleshark/Documents/git/whale-shark/trade_tools')
116/10: runfile('/home/whaleshark/Documents/git/whale-shark/trade_tools/trading_projections.py', wdir='/home/whaleshark/Documents/git/whale-shark/trade_tools')
116/11: runfile('/home/whaleshark/Documents/git/whale-shark/trade_tools/trading_projections.py', wdir='/home/whaleshark/Documents/git/whale-shark/trade_tools')
116/12: runfile('/home/whaleshark/Documents/git/whale-shark/trade_tools/trading_projections.py', wdir='/home/whaleshark/Documents/git/whale-shark/trade_tools')
118/1:
import ccxt
import pandas as pd
from mlforecast.core import TimeSeries
from mlforecast.forecast import Forecast
from lightgbm import LGBMRegressor

# Fetch historical data from Coinbase
def fetch_data(symbol, timeframe, since):
    exchange = ccxt.coinbasepro()
    ohlcv = exchange.fetch_ohlcv(symbol, timeframe, since)
    df = pd.DataFrame(ohlcv, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
    df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')
    df.set_index('timestamp', inplace=True)
    return df

# Main forecasting function
def forecast_bitcoin():
    # Fetch BTC data
    btc_data = fetch_data('BTC/USD', '1d', '2020-01-01T00:00:00Z')

    # Prepare data for forecasting
    btc_data.reset_index(inplace=True)
    btc_data['symbol'] = 'BTC'
    ts = TimeSeries(date_col='timestamp', id_col='symbol', y_col='close')

    # Split data
    train_df, test_df = ts.split(btc_data, test_size=0.2)

    # Define and train model
    params = {'n_estimators': 100, 'learning_rate': 0.1}
    model = LGBMRegressor(**params)
    fcst = Forecast(model, freq='D')
    fcst.fit(train_df)

    # Make predictions
    predictions = fcst.predict(test_df.index.levels[1].max())

    return predictions

# Run the forecasting function
forecast_results = forecast_bitcoin()
print(forecast_results)
120/1:
import ccxt
import pandas as pd
from mlforecast.core import TimeSeries
from mlforecast.forecast import Forecast
from lightgbm import LGBMRegressor

# Fetch historical data from Coinbase
def fetch_data(symbol, timeframe, since):
    exchange = ccxt.coinbasepro()
    ohlcv = exchange.fetch_ohlcv(symbol, timeframe, since)
    df = pd.DataFrame(ohlcv, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
    df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')
    df.set_index('timestamp', inplace=True)
    return df

# Main forecasting function
def forecast_bitcoin():
    # Fetch BTC data
    btc_data = fetch_data('BTC/USD', '1d', '2020-01-01T00:00:00Z')

    # Prepare data for forecasting
    btc_data.reset_index(inplace=True)
    btc_data['symbol'] = 'BTC'
    ts = TimeSeries(date_col='timestamp', id_col='symbol', y_col='close')

    # Split data
    train_df, test_df = ts.split(btc_data, test_size=0.2)

    # Define and train model
    params = {'n_estimators': 100, 'learning_rate': 0.1}
    model = LGBMRegressor(**params)
    fcst = Forecast(model, freq='D')
    fcst.fit(train_df)

    # Make predictions
    predictions = fcst.predict(test_df.index.levels[1].max())

    return predictions

# Run the forecasting function
forecast_results = forecast_bitcoin()
print(forecast_results)
120/2:
import ccxt
import pandas as pd
from mlforecast.core import TimeSeries
from mlforecast.forecast import Forecast
from lightgbm import LGBMRegressor

# Fetch historical data from Coinbase
def fetch_data(symbol, timeframe, since):
    exchange = ccxt.coinbasepro()
    ohlcv = exchange.fetch_ohlcv(symbol, timeframe, since)
    df = pd.DataFrame(ohlcv, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
    df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')
    df.set_index('timestamp', inplace=True)
    return df

# Main forecasting function
def forecast_bitcoin():
    # Fetch BTC data
    btc_data = fetch_data('BTC/USD', '1d', '2020-01-01T00:00:00Z')

    # Prepare data for forecasting
    btc_data.reset_index(inplace=True)
    btc_data['symbol'] = 'BTC'
    ts = TimeSeries(date_col='timestamp', id_col='symbol', y_col='close')

    # Split data
    train_df, test_df = ts.split(btc_data, test_size=0.2)

    # Define and train model
    params = {'n_estimators': 100, 'learning_rate': 0.1}
    model = LGBMRegressor(**params)
    fcst = Forecast(model, freq='D')
    fcst.fit(train_df)

    # Make predictions
    predictions = fcst.predict(test_df.index.levels[1].max())

    return predictions

# Run the forecasting function
forecast_results = forecast_bitcoin()
print(forecast_results)
120/3:
import ccxt
import pandas as pd
from mlforecast.core import TimeSeries
from mlforecast.forecast import Forecast
from lightgbm import LGBMRegressor

# Fetch historical data from Coinbase
def fetch_data(symbol, timeframe, since):
    exchange = ccxt.coinbasepro()
    ohlcv = exchange.fetch_ohlcv(symbol, timeframe, since)
    df = pd.DataFrame(ohlcv, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
    df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')
    df.set_index('timestamp', inplace=True)
    return df

# Main forecasting function
def forecast_bitcoin():
    # Fetch BTC data
    btc_data = fetch_data('BTC/USD', '1d', '2020-01-01T00:00:00Z')

    # Prepare data for forecasting
    btc_data.reset_index(inplace=True)
    btc_data['symbol'] = 'BTC'
    ts = TimeSeries(date_col='timestamp', id_col='symbol', y_col='close')

    # Split data
    train_df, test_df = ts.split(btc_data, test_size=0.2)

    # Define and train model
    params = {'n_estimators': 100, 'learning_rate': 0.1}
    model = LGBMRegressor(**params)
    fcst = Forecast(model, freq='D')
    fcst.fit(train_df)

    # Make predictions
    predictions = fcst.predict(test_df.index.levels[1].max())

    return predictions

# Run the forecasting function
forecast_results = forecast_bitcoin()
print(forecast_results)
120/4:
import random

import pandas as pd
from datasetsforecast.m4 import M4
from utilsforecast.plotting import plot_series
120/5:
import random

import pandas as pd
from datasetsforecast.m4 import M4
from utilsforecast.plotting import plot_series
120/6:
await M4.async_download('data', group='Hourly')
df, *_ = M4.load('data', 'Hourly')
uids = df['unique_id'].unique()
random.seed(0)
sample_uids = random.choices(uids, k=4)
df = df[df['unique_id'].isin(sample_uids)].reset_index(drop=True)
df['ds'] = df['ds'].astype('int64')
df
120/7: fig = plot_series(df, max_insample_length=24 * 14)
120/8:
fig = plot_series(df, max_insample_length=24 * 14)
fig
120/9:
from mlforecast import MLForecast
from mlforecast.target_transforms import Differences

fcst = MLForecast(
    models=[],  # we're not interested in modeling yet
    freq=1,  # our series have integer timestamps, so we'll just add 1 in every timestep
    target_transforms=[Differences([24])],
)
prep = fcst.preprocess(df)
prep
120/10:
fig = plot_series(prep)
fig
120/11:
fcst = MLForecast(
    models=[],
    freq=1,
    lags=[1, 24],
    target_transforms=[Differences([24])],    
)
prep = fcst.preprocess(df)
prep
120/12: prep.drop(columns=['unique_id', 'ds']).corr()['y']
120/13: import lightgbm as lgb
120/14:
lgb_params = {
    'verbosity': -1,
    'num_leaves': 512,
}

fcst = MLForecast(
    models={
        'avg': lgb.LGBMRegressor(**lgb_params),
        'q75': lgb.LGBMRegressor(**lgb_params, objective='quantile', alpha=0.75),
        'q25': lgb.LGBMRegressor(**lgb_params, objective='quantile', alpha=0.25),
    },
    freq=1,
    target_transforms=[Differences([24])],
    lags=[1, 24],
    lag_transforms={
        1: [expanding_mean],
        24: [(rolling_mean, 48)],
    },
    date_features=[hour_index],
)
fcst.fit(df)
120/15:
import lightgbm as lgb
from numba import njit
from window_ops.expanding import expanding_mean
from window_ops.rolling import rolling_mean
120/16:
lgb_params = {
    'verbosity': -1,
    'num_leaves': 512,
}

fcst = MLForecast(
    models={
        'avg': lgb.LGBMRegressor(**lgb_params),
        'q75': lgb.LGBMRegressor(**lgb_params, objective='quantile', alpha=0.75),
        'q25': lgb.LGBMRegressor(**lgb_params, objective='quantile', alpha=0.25),
    },
    freq=1,
    target_transforms=[Differences([24])],
    lags=[1, 24],
    lag_transforms={
        1: [expanding_mean],
        24: [(rolling_mean, 48)],
    },
    date_features=[hour_index],
)
fcst.fit(df)
120/17:
import lightgbm as lgb
from numba import njit
from window_ops.expanding import expanding_mean
from window_ops.rolling import rolling_mean

def hour_index(times):
    return times % 24
120/18:
lgb_params = {
    'verbosity': -1,
    'num_leaves': 512,
}

fcst = MLForecast(
    models={
        'avg': lgb.LGBMRegressor(**lgb_params),
        'q75': lgb.LGBMRegressor(**lgb_params, objective='quantile', alpha=0.75),
        'q25': lgb.LGBMRegressor(**lgb_params, objective='quantile', alpha=0.25),
    },
    freq=1,
    target_transforms=[Differences([24])],
    lags=[1, 24],
    lag_transforms={
        1: [expanding_mean],
        24: [(rolling_mean, 48)],
    },
    date_features=[hour_index],
)
fcst.fit(df)
120/19: MLForecast(models=[avg, q75, q25], freq=1, lag_features=['lag1', 'lag24', 'expanding_mean_lag1', 'rolling_mean_lag24_window_size48'], date_features=[<function hour_index>], num_threads=1)
120/20: MLForecast(models=[avg, q75, q25], freq=1, lag_features=['lag1', 'lag24', 'expanding_mean_lag1', 'rolling_mean_lag24_window_size48'], date_features=[<function hour_index>], num_threads=1)
120/21:
preds = fcst.predict(48)
preds
120/22:
preds = fcst.predict(48)
preds
120/23: fig = plot_series(df, preds, max_insample_length=24 * 7)
120/24:
fig = plot_series(df, preds, max_insample_length=24 * 7)
fig
120/25:
fcst = MLForecast(
    models=lgb.LGBMRegressor(**lgb_params),
    freq=1,
    target_transforms=[Differences([24])],
    lags=[1, 24],
    lag_transforms={
        1: [expanding_mean],
        24: [(rolling_mean, 48)],
    },
    date_features=[hour_index],
)
cv_result = fcst.cross_validation(
    df,
    n_windows=4,  # number of models to train/splits to perform
    h=48,  # length of the validation set in each window
)
cv_result
120/26:
fig = plot_series(cv_result, cv_result.drop(columns='cutoff'), max_insample_length=0)
fig
122/1: import pandas as pd
122/2:
file = '../pipeline/data/BTC/USD/BTC_USD_5min_20131203-20231201.csv'
data = pd.read_csv(file)
122/3:
file = '../pipeline/data/BTC/USD/BTC_USD_5min_20131203-20231201.csv'
data = pd.read_csv(file)
data
122/4: plot_series(data, max_insample_length=24 * 14)
122/5:
import pandas as pd
from utilsforecast.plotting import plot_series
122/6:
file = '../pipeline/data/BTC/USD/BTC_USD_5min_20131203-20231201.csv'
data = pd.read_csv(file)
data
122/7: plot_series(data, max_insample_length=24 * 14)
122/8:
file = '../pipeline/data/BTC/USD/BTC_USD_5min_20131203-20231201.csv'
data = pd.read_csv(file)
uids = data['unique_id'].unique()
random.seed(0)
sample_uids = random.choices(uids, k=4)
df = data[data['unique_id'].isin(sample_uids)].reset_index(drop=True)
df['ds'] = df['ds'].astype('int64')
df?
122/9:
file = '../pipeline/data/BTC/USD/BTC_USD_5min_20131203-20231201.csv'
data = pd.read_csv(file)
uids = data['unique_id'].unique()
random.seed(0)
sample_uids = random.choices(uids, k=4)
df = data[data['unique_id'].isin(sample_uids)].reset_index(drop=True)
df['ds'] = df['ds'].astype('int64')
df
122/10:
file = '../pipeline/data/BTC/USD/BTC_USD_5min_20131203-20231201.csv'
data = pd.read_csv(file)
uids = data.index.unique()
random.seed(0)
sample_uids = random.choices(uids, k=4)
df = data[data['unique_id'].isin(sample_uids)].reset_index(drop=True)
df['ds'] = df['ds'].astype('int64')
df
122/11:
import pandas as pd
from utilsforecast.plotting import plot_series
import random
122/12:
file = '../pipeline/data/BTC/USD/BTC_USD_5min_20131203-20231201.csv'
data = pd.read_csv(file)
uids = data.index.unique()
random.seed(0)
sample_uids = random.choices(uids, k=4)
df = data[data['unique_id'].isin(sample_uids)].reset_index(drop=True)
df['ds'] = df['ds'].astype('int64')
df
122/13: plot_series(data, max_insample_length=24 * 14)
122/14:
file = '../pipeline/data/BTC/USD/BTC_USD_5min_20131203-20231201.csv'
data = pd.read_csv(file)
data['unique_id'] = [item for item in data.index]
uids = data.index.unique()
random.seed(0)
sample_uids = random.choices(uids, k=4)
df = data[data['unique_id'].isin(sample_uids)].reset_index(drop=True)
df['ds'] = df['ds'].astype('int64')
df
122/15:
file = '../pipeline/data/BTC/USD/BTC_USD_5min_20131203-20231201.csv'
data = pd.read_csv(file)
data.columns, data.head()
122/16:

data['unique_id'] = [item for item in data.index]
uids = data.index.unique()
random.seed(0)
sample_uids = random.choices(uids, k=4)
df = data[data['unique_id'].isin(sample_uids)].reset_index(drop=True)
df['ds'] = df['Time'].astype('int64')
df
124/1:
import pandas as pd
import yfinance as yf

def download_data(ticker, start_date, end_date):
    data = yf.download(ticker, start=start_date, end=end_date, progress=False)
    data.drop(['Adj Close'], axis=1, inplace=True)
    return data

btc_data = download_data('BTC-USD', '2018-01-01', '2023-12-07')
ada_data = download_data('ADA-USD', '2018-01-01', '2023-12-07')
124/2:
import pandas as pd
import yfinance as yf

def download_data(ticker, start_date, end_date):
    data = yf.download(ticker, start=start_date, end=end_date, progress=False)
    data.drop(['Adj Close'], axis=1, inplace=True)
    return data

btc_data = download_data('BTC-USD', '2018-01-01', '2023-12-07')
ada_data = download_data('ADA-USD', '2018-01-01', '2023-12-07')
124/3:
btc_data['SMA5'] = btc_data['Close'].rolling(5).mean()
btc_data['SMA20'] = btc_data['Close'].rolling(20).mean()
btc_data['SMA60'] = btc_data['Close'].rolling(60).mean()

ada_data['SMA5'] = ada_data['Close'].rolling(5).mean()
ada_data['SMA20'] = ada_data['Close'].rolling(20).mean()
ada_data['SMA60'] = ada_data['Close'].rolling(60).mean()
124/4:
from sklearn.linear_model import LinearRegression
from sklearn.model_selection import train_test_split

# Split the data into X (features) and y (target)
X_btc = btc_data[['SMA5', 'SMA20', 'SMA60']]
y_btc = btc_data['Close']
X_ada = ada_data[['SMA5', 'SMA20', 'SMA60']]
y_ada = ada_data['Close']

# Split the data into training and testing sets
X_btc_train, X_btc_test, y_btc_train, y_btc_test = train_test_split(X_btc, y_btc, test_size=0.2, shuffle=False)
X_ada_train, X_ada_test, y_ada_train, y_ada_test = train_test_split(X_ada, y_ada, test_size=0.2, shuffle=False)

# Create and fit the linear regression model for BTC
model_btc = LinearRegression()
model_btc.fit(X_btc_train, y_btc_train)

# Create and fit the linear regression model for ADA
model_ada = LinearRegression()
model_ada.fit(X_ada_train, y_ada_train)

# Make predictions on the testing data
btc_pred = model_btc.predict(X_btc_test)
ada_pred = model_ada.predict(X_ada_test)
124/5:
import pandas as pd
import yfinance as yf
from sklearn.linear_model import LinearRegression
from sklearn.model_selection import train_test_split
import matplotlib.pyplot as plt
124/6:
def download_data(ticker, start_date, end_date):
    data = yf.download(ticker, start=start_date, end=end_date, progress=False)
    data.drop(['Adj Close'], axis=1, inplace=True)
    return data

btc_data = download_data('BTC-USD', '2018-01-01', '2023-12-07')
ada_data = download_data('ADA-USD', '2018-01-01', '2023-12-07')
124/7:
btc_data['SMA5'] = btc_data['Close'].rolling(5).mean()
btc_data['SMA20'] = btc_data['Close'].rolling(20).mean()
btc_data['SMA60'] = btc_data['Close'].rolling(60).mean()

ada_data['SMA5'] = ada_data['Close'].rolling(5).mean()
ada_data['SMA20'] = ada_data['Close'].rolling(20).mean()
ada_data['SMA60'] = ada_data['Close'].rolling(60).mean()
124/8:


# Split the data into X (features) and y (target)
X_btc = btc_data[['SMA5', 'SMA20', 'SMA60']]
y_btc = btc_data['Close']
X_ada = ada_data[['SMA5', 'SMA20', 'SMA60']]
y_ada = ada_data['Close']

# Split the data into training and testing sets
X_btc_train, X_btc_test, y_btc_train, y_btc_test = train_test_split(X_btc, y_btc, test_size=0.2, shuffle=False)
X_ada_train, X_ada_test, y_ada_train, y_ada_test = train_test_split(X_ada, y_ada, test_size=0.2, shuffle=False)

# Create and fit the linear regression model for BTC
model_btc = LinearRegression()
model_btc.fit(X_btc_train, y_btc_train)

# Create and fit the linear regression model for ADA
model_ada = LinearRegression()
model_ada.fit(X_ada_train, y_ada_train)

# Make predictions on the testing data
btc_pred = model_btc.predict(X_btc_test)
ada_pred = model_ada.predict(X_ada_test)
124/9:
# Split the data into X (features) and y (target)
X_btc = btc_data[['SMA5', 'SMA20', 'SMA60']]
y_btc = btc_data['Close']
X_ada = ada_data[['SMA5', 'SMA20', 'SMA60']]
y_ada = ada_data['Close']

# Split the data into training and testing sets
X_btc_train, X_btc_test, y_btc_train, y_btc_test = train_test_split(X_btc, y_btc, test_size=0.2, shuffle=False)
X_ada_train, X_ada_test, y_ada_train, y_ada_test = train_test_split(X_ada, y_ada, test_size=0.2, shuffle=False)
124/10: btc_data
124/11: btc_data.head()
124/12:
btc_data['SMA5'] = btc_data['Close'].rolling(5).mean()
btc_data['SMA20'] = btc_data['Close'].rolling(20).mean()
btc_data['SMA60'] = btc_data['Close'].rolling(60).mean()

ada_data['SMA5'] = ada_data['Close'].rolling(5).mean()
ada_data['SMA20'] = ada_data['Close'].rolling(20).mean()
ada_data['SMA60'] = ada_data['Close'].rolling(60).mean()

btc_data = btc_data.dropna()
ada_data ada_data.dropna()
124/13:
btc_data['SMA5'] = btc_data['Close'].rolling(5).mean()
btc_data['SMA20'] = btc_data['Close'].rolling(20).mean()
btc_data['SMA60'] = btc_data['Close'].rolling(60).mean()

ada_data['SMA5'] = ada_data['Close'].rolling(5).mean()
ada_data['SMA20'] = ada_data['Close'].rolling(20).mean()
ada_data['SMA60'] = ada_data['Close'].rolling(60).mean()

btc_data = btc_data.dropna()
ada_data = ada_data.dropna()
124/14: btc_data.head()
124/15:
# Split the data into X (features) and y (target)
X_btc = btc_data[['SMA5', 'SMA20', 'SMA60']]
y_btc = btc_data['Close']
X_ada = ada_data[['SMA5', 'SMA20', 'SMA60']]
y_ada = ada_data['Close']

# Split the data into training and testing sets
X_btc_train, X_btc_test, y_btc_train, y_btc_test = train_test_split(X_btc, y_btc, test_size=0.2, shuffle=False)
X_ada_train, X_ada_test, y_ada_train, y_ada_test = train_test_split(X_ada, y_ada, test_size=0.2, shuffle=False)
124/16:
# Create and fit the linear regression model for BTC
model_btc = LinearRegression()
model_btc.fit(X_btc_train, y_btc_train)

# Create and fit the linear regression model for ADA
model_ada = LinearRegression()
model_ada.fit(X_ada_train, y_ada_train)

# Make predictions on the testing data
btc_pred = model_btc.predict(X_btc_test)
ada_pred = model_ada.predict(X_ada_test)
124/17:

plt.plot(y_btc_test, label='Actual BTC')
plt.plot(btc_pred, label='Predicted BTC')
plt.legend()
plt.show()

plt.plot(y_ada_test, label='Actual ADA')
plt.plot(ada_pred, label='Predicted ADA')
plt.legend()
plt.show()
124/18:
import pandas as pd
import yfinance as yf
from sklearn.linear_model import LinearRegression
from sklearn.model_selection import train_test_split
import matplotlib.pyplot as plt
124/19:
def download_data(ticker, start_date, end_date):
    data = yf.download(ticker, start=start_date, end=end_date, progress=False)
    data.drop(['Adj Close'], axis=1, inplace=True)
    return data

btc_data = download_data('BTC-USD', '2018-01-01', '2023-12-07')
ada_data = download_data('ADA-USD', '2018-01-01', '2023-12-07')
124/20:
btc_data['SMA5'] = btc_data['Close'].rolling(5).mean()
btc_data['SMA20'] = btc_data['Close'].rolling(20).mean()
btc_data['SMA60'] = btc_data['Close'].rolling(60).mean()

ada_data['SMA5'] = ada_data['Close'].rolling(5).mean()
ada_data['SMA20'] = ada_data['Close'].rolling(20).mean()
ada_data['SMA60'] = ada_data['Close'].rolling(60).mean()

btc_data = btc_data.dropna()
ada_data = ada_data.dropna()
124/21: btc_data.head()
124/22:
# Split the data into X (features) and y (target)
X_btc = btc_data[['SMA5', 'SMA20', 'SMA60']]
y_btc = btc_data['Close']
X_ada = ada_data[['SMA5', 'SMA20', 'SMA60']]
y_ada = ada_data['Close']

# Split the data into training and testing sets
X_btc_train, X_btc_test, y_btc_train, y_btc_test = train_test_split(X_btc, y_btc, test_size=0.2, shuffle=False)
X_ada_train, X_ada_test, y_ada_train, y_ada_test = train_test_split(X_ada, y_ada, test_size=0.2, shuffle=False)
124/23:
# Create and fit the linear regression model for BTC
model_btc = LinearRegression()
model_btc.fit(X_btc_train, y_btc_train)

# Create and fit the linear regression model for ADA
model_ada = LinearRegression()
model_ada.fit(X_ada_train, y_ada_train)

# Make predictions on the testing data
btc_pred = model_btc.predict(X_btc_test)
ada_pred = model_ada.predict(X_ada_test)
124/24: btc_pred
124/25:
# Split the data into X (features) and y (target)
X_btc = btc_data[['SMA5', 'SMA20', 'SMA60']]
y_btc = btc_data['Close']
X_ada = ada_data[['SMA5', 'SMA20', 'SMA60']]
y_ada = ada_data['Close']

# Split the data into training and testing sets
# X_btc_train, X_btc_test, y_btc_train, y_btc_test = train_test_split(X_btc, y_btc, test_size=0.2, shuffle=False)
# X_ada_train, X_ada_test, y_ada_train, y_ada_test = train_test_split(X_ada, y_ada, test_size=0.2, shuffle=False)
N = 365
btc_test = btc_data.iloc[-N:]
btc_train = btc_data.iloc[:-N]

ada_test = btc_data.iloc[-N:]
ada_train = btc_data.iloc[:-N]
124/26:
# Split the data into X (features) and y (target)
X_btc = btc_data[['SMA5', 'SMA20', 'SMA60']]
y_btc = btc_data['Close']
X_ada = ada_data[['SMA5', 'SMA20', 'SMA60']]
y_ada = ada_data['Close']

# Split the data into training and testing sets
# X_btc_train, X_btc_test, y_btc_train, y_btc_test = train_test_split(X_btc, y_btc, test_size=0.2, shuffle=False)
# X_ada_train, X_ada_test, y_ada_train, y_ada_test = train_test_split(X_ada, y_ada, test_size=0.2, shuffle=False)
N = 365
x_btc_test = X_btc.iloc[-N:]
y_btc_test = y_btc.iloc[-N:]

x_btc_train = X_btc.iloc[:-N]
y_btc_train = y_btc.iloc[:-N]

x_ada_test = X_btc.iloc[-N:]
y_ada_test = y_btc.iloc[-N:]

x_ada_train = X_btc.iloc[:-N]
y_ada_train = y_btc.iloc[:-N]
124/27:
# Create and fit the linear regression model for BTC
model_btc = LinearRegression()
model_btc.fit(X_btc_train, y_btc_train)

# Create and fit the linear regression model for ADA
model_ada = LinearRegression()
model_ada.fit(X_ada_train, y_ada_train)

# Make predictions on the testing data
btc_pred = model_btc.predict(X_btc_test)
ada_pred = model_ada.predict(X_ada_test)
124/28:
import pandas as pd
import yfinance as yf
from sklearn.linear_model import LinearRegression
from sklearn.model_selection import train_test_split
import matplotlib.pyplot as plt
124/29:
def download_data(ticker, start_date, end_date):
    data = yf.download(ticker, start=start_date, end=end_date, progress=False)
    data.drop(['Adj Close'], axis=1, inplace=True)
    return data

btc_data = download_data('BTC-USD', '2018-01-01', '2023-12-07')
ada_data = download_data('ADA-USD', '2018-01-01', '2023-12-07')
124/30:
btc_data['SMA5'] = btc_data['Close'].rolling(5).mean()
btc_data['SMA20'] = btc_data['Close'].rolling(20).mean()
btc_data['SMA60'] = btc_data['Close'].rolling(60).mean()

ada_data['SMA5'] = ada_data['Close'].rolling(5).mean()
ada_data['SMA20'] = ada_data['Close'].rolling(20).mean()
ada_data['SMA60'] = ada_data['Close'].rolling(60).mean()

btc_data = btc_data.dropna()
ada_data = ada_data.dropna()
124/31: btc_data.head()
124/32:
# Split the data into X (features) and y (target)
X_btc = btc_data[['SMA5', 'SMA20', 'SMA60']]
y_btc = btc_data['Close']
X_ada = ada_data[['SMA5', 'SMA20', 'SMA60']]
y_ada = ada_data['Close']

# Split the data into training and testing sets
# X_btc_train, X_btc_test, y_btc_train, y_btc_test = train_test_split(X_btc, y_btc, test_size=0.2, shuffle=False)
# X_ada_train, X_ada_test, y_ada_train, y_ada_test = train_test_split(X_ada, y_ada, test_size=0.2, shuffle=False)
N = 365
x_btc_test = X_btc.iloc[-N:]
y_btc_test = y_btc.iloc[-N:]

x_btc_train = X_btc.iloc[:-N]
y_btc_train = y_btc.iloc[:-N]

x_ada_test = X_btc.iloc[-N:]
y_ada_test = y_btc.iloc[-N:]

x_ada_train = X_btc.iloc[:-N]
y_ada_train = y_btc.iloc[:-N]
124/33:
# Create and fit the linear regression model for BTC
model_btc = LinearRegression()
model_btc.fit(X_btc_train, y_btc_train)

# Create and fit the linear regression model for ADA
model_ada = LinearRegression()
model_ada.fit(X_ada_train, y_ada_train)

# Make predictions on the testing data
btc_pred = model_btc.predict(X_btc_test)
ada_pred = model_ada.predict(X_ada_test)
124/34:
# Split the data into X (features) and y (target)
X_btc_train = btc_train[['SMA5', 'SMA20', 'SMA60']]
y_btc_train = btc_train['Close']
X_btc_test = btc_test[['SMA5', 'SMA20', 'SMA60']]
y_btc_test = btc_test['Close']

X_ada_train = ada_train[['SMA5', 'SMA20', 'SMA60']]
y_ada_train = ada_train['Close']
X_ada_test = ada_test[['SMA5', 'SMA20', 'SMA60']]
y_ada_test = ada_test['Close']

# Split the data into training and testing sets
# X_btc_train, X_btc_test, y_btc_train, y_btc_test = train_test_split(X_btc, y_btc, test_size=0.2, shuffle=False)
# X_ada_train, X_ada_test, y_ada_train, y_ada_test = train_test_split(X_ada, y_ada, test_size=0.2, shuffle=False)
124/35:
# Create and fit the linear regression model for BTC
model_btc = LinearRegression()
model_btc.fit(X_btc_train, y_btc_train)

# Create and fit the linear regression model for ADA
model_ada = LinearRegression()
model_ada.fit(X_ada_train, y_ada_train)

# Make predictions on the testing data
btc_pred = model_btc.predict(X_btc_test)
ada_pred = model_ada.predict(X_ada_test)
124/36:

plt.plot(y_btc_test, label='Actual BTC')
plt.plot(btc_pred, label='Predicted BTC')
plt.legend()
plt.show()

plt.plot(y_ada_test, label='Actual ADA')
plt.plot(ada_pred, label='Predicted ADA')
plt.legend()
plt.show()
124/37:

plt.plot(y_btc_train, label='Actual BTC')
plt.plot(btc_pred, label='Predicted BTC')
plt.legend()
plt.show()

plt.plot(y_ada_train, label='Actual ADA')
plt.plot(ada_pred, label='Predicted ADA')
plt.legend()
plt.show()
124/38:
plt.plot(y_btc_test, label='Actual BTC')
plt.plot(btc_pred, label='Predicted BTC')
plt.legend()
plt.show()

plt.plot(y_ada_train, label='Actual ADA')
plt.plot(ada_pred, label='Predicted ADA')
plt.legend()
plt.show()
124/39:
plt.plot(X_train, y_train, 'b.', label='Training Data')
plt.plot(X_test, y_test, 'r.', label='Test Data')
plt.plot(X_test, y_pred, 'g.', label='Predictions')
plt.legend()
plt.show()

plt.plot(y_ada_train, label='Actual ADA')
plt.plot(ada_pred, label='Predicted ADA')
plt.legend()
plt.show()
124/40:
plt.plot(X_btc_train, y_btc_train, 'b.', label='Training Data')
plt.plot(X_btc_test, y_btc_test, 'r.', label='Test Data')
plt.plot(X_btc_test, btc_pred, 'g.', label='Predictions')
plt.legend()
plt.show()

plt.plot(y_ada_train, label='Actual ADA')
plt.plot(ada_pred, label='Predicted ADA')
plt.legend()
plt.show()
124/41: plt.plot(btc_data, 'b.', label='Training Data')
124/42: plt.plot(btc_data, label='Training Data')
124/43:
plt.plot(btc_data, label='Training Data')
plt.show()
124/44:
plt.plot(btc_data, label='Training Data')
plt.plot(btc_pred, label='Training Data')

plt.show()
124/45:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error

# Load data
# data = pd.read_csv("your_data.csv", index_col="Date", parse_dates=True)

# Split data into train and test
train_data = btc_data.iloc[:len(data) - 10]
test_data = btc_data.iloc[len(data) - 10:]

# Fit ARIMA model
model = ARIMA(train_data, order=(1, 1, 1))
model_fit = model.fit()

# Make predictions
start_index = len(train_data)
end_index = len(train_data) + len(test_data) - 1
predictions = model_fit.predict(start=start_index, end=end_index)

# Calculate RMSE
rmse = np.sqrt(mean_squared_error(test_data, predictions))

# Plot data
plt.plot(train_data, label="Training Data")
plt.plot(test_data, label="Test Data")
plt.plot(predictions, label="Predictions", color="red")
plt.legend()
plt.title("Time Series Prediction with ARIMA")
plt.xlabel("Date")
plt.ylabel("Value")
plt.show()

print("RMSE:", rmse)
124/46:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error

# Load data
# data = pd.read_csv("your_data.csv", index_col="Date", parse_dates=True)

# Split data into train and test
train_data = btc_data.iloc[:len(data) - 10]
test_data = btc_data.iloc[len(data) - 10:]

# Fit ARIMA model
model = ARIMA(train_data, order=(1, 1, 1))
model_fit = model.fit()

# Make predictions
start_index = len(train_data)
end_index = len(train_data) + len(test_data) - 1
predictions = model_fit.predict(start=start_index, end=end_index)

# Calculate RMSE
rmse = np.sqrt(mean_squared_error(test_data, predictions))

# Plot data
plt.plot(train_data, label="Training Data")
plt.plot(test_data, label="Test Data")
plt.plot(predictions, label="Predictions", color="red")
plt.legend()
plt.title("Time Series Prediction with ARIMA")
plt.xlabel("Date")
plt.ylabel("Value")
plt.show()

print("RMSE:", rmse)
124/47:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error

# Load data
# data = pd.read_csv("your_data.csv", index_col="Date", parse_dates=True)

# Split data into train and test
train_data = btc_data.iloc[:len(btc_data) - 10]
test_data = btc_data.iloc[len(btc_data) - 10:]

# Fit ARIMA model
model = ARIMA(train_data, order=(1, 1, 1))
model_fit = model.fit()

# Make predictions
start_index = len(train_data)
end_index = len(train_data) + len(test_data) - 1
predictions = model_fit.predict(start=start_index, end=end_index)

# Calculate RMSE
rmse = np.sqrt(mean_squared_error(test_data, predictions))

# Plot data
plt.plot(train_data, label="Training Data")
plt.plot(test_data, label="Test Data")
plt.plot(predictions, label="Predictions", color="red")
plt.legend()
plt.title("Time Series Prediction with ARIMA")
plt.xlabel("Date")
plt.ylabel("Value")
plt.show()

print("RMSE:", rmse)
124/48:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima.model import ARIMA
from sklearn.metrics import mean_squared_error

# Load data
# data = pd.read_csv("your_data.csv", index_col="Date", parse_dates=True)

# Split data into train and test
train_data = btc_data.iloc[:len(btc_data) - 10]
test_data = btc_data.iloc[len(btc_data) - 10:]

# Fit ARIMA model
model = ARIMA(train_data, order=(1, 1, 1))
model_fit = model.fit()

# Make predictions
start_index = len(train_data)
end_index = len(train_data) + len(test_data) - 1
predictions = model_fit.predict(start=start_index, end=end_index)

# Calculate RMSE
rmse = np.sqrt(mean_squared_error(test_data, predictions))

# Plot data
plt.plot(train_data, label="Training Data")
plt.plot(test_data, label="Test Data")
plt.plot(predictions, label="Predictions", color="red")
plt.legend()
plt.title("Time Series Prediction with ARIMA")
plt.xlabel("Date")
plt.ylabel("Value")
plt.show()

print("RMSE:", rmse)
124/49:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        self.data = self.load_data()
        self.train_data, self.test_data = self.split_data()

    # Load data from a CSV file
    def load_data(self, file_path):
        data = pd.read_csv(file_path)
        return data
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data
    
    # Plot the data
    def plot_data(self, data, title="Data"):
        plt.plot(data)
        plt.title(title)
        plt.xlabel("Time")
        plt.ylabel("Value")
        plt.show()

    def load_data(self):
        # Load data from the Coinbase API
        pass  # Replace with your own code to load data from the Coinbase API

    def split_data(self):
        # Split the data into train and test sets
        pass  # Replace with your own code to split the data

    def plot_data(self, predictions):
        # Plot the training data, test data, and predictions
        pass  # Replace with your own code to plot the data

    def predict(self):
        # Fit an ARIMA model and make predictions
        model = ARIMA(self.train_data, order=(1, 1, 1))
        model_fit = model.fit()
        start_index = len(self.train_data)
        end_index = len(self.train_data) + len(self.test_data) - 1
        predictions = model_fit.predict(start=start_index, end=end_index)

        # Calculate RMSE
        rmse = np.sqrt(mean_squared_error(self.test_data, predictions))

        # Plot the data and predictions
        self.plot_data(predictions)

        return predictions, rmse

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions, rmse = cp.predict()
    print(f"RMSE: {rmse}")
124/50:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        self.data = self.load_data()
        self.train_data, self.test_data = self.split_data()

    # Load data from a CSV file
    def load_data(self, file_path):
        data = pd.read_csv(file_path)
        return data
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data
    
    # Plot the data
    def plot_data(self, data, title="Data"):
        plt.plot(data)
        plt.title(title)
        plt.xlabel("Time")
        plt.ylabel("Value")
        plt.show()

    def predict(self):
        # Fit an ARIMA model and make predictions
        model = ARIMA(self.train_data, order=(1, 1, 1))
        model_fit = model.fit()
        start_index = len(self.train_data)
        end_index = len(self.train_data) + len(self.test_data) - 1
        predictions = model_fit.predict(start=start_index, end=end_index)

        # Calculate RMSE
        rmse = np.sqrt(mean_squared_error(self.test_data, predictions))

        # Plot the data and predictions
        self.plot_data(predictions)

        return predictions, rmse

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions, rmse = cp.predict()
    print(f"RMSE: {rmse}")
124/51:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        self.data = self.load_data()
        self.train_data, self.test_data = self.split_data()

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-01-01', '2023-12-07')
        return data
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data
    
    # Plot the data
    def plot_data(self, data, title="Data"):
        plt.plot(data)
        plt.title(title)
        plt.xlabel("Time")
        plt.ylabel("Value")
        plt.show()

    def predict(self):
        # Fit an ARIMA model and make predictions
        model = ARIMA(self.train_data, order=(1, 1, 1))
        model_fit = model.fit()
        start_index = len(self.train_data)
        end_index = len(self.train_data) + len(self.test_data) - 1
        predictions = model_fit.predict(start=start_index, end=end_index)

        # Calculate RMSE
        rmse = np.sqrt(mean_squared_error(self.test_data, predictions))

        # Plot the data and predictions
        self.plot_data(predictions)

        return predictions, rmse

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions, rmse = cp.predict()
    print(f"RMSE: {rmse}")
124/52:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        self.data = self.load_data()
        self.train_data, self.test_data = self.split_data()

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-01-01', '2023-12-07')
        return data
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data
    
    # Plot the data
    def plot_data(self, data, title="Data"):
        plt.plot(data)
        plt.title(title)
        plt.xlabel("Time")
        plt.ylabel("Value")
        plt.show()

    def predict(self):
        # Fit an ARIMA model and make predictions
        model = ARIMA(self.train_data, order=(1, 1, 1))
        model_fit = model.fit()
        start_index = len(self.train_data)
        end_index = len(self.train_data) + len(self.test_data) - 1
        predictions = model_fit.predict(start=start_index, end=end_index)

        # Calculate RMSE
        rmse = np.sqrt(mean_squared_error(self.test_data, predictions))

        # Plot the data and predictions
        self.plot_data(predictions)

        return predictions, rmse

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    data = cp.load_data(file_path)
    train_data, test_data = cp.split_data(data)
    predictions, rmse = cp.predict()
    print(f"RMSE: {rmse}")
124/53:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        self.data = self.load_data(self.symbol)
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-01-01', '2023-12-07')
        return data
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data
    
    # Plot the data
    def plot_data(self, data, title="Data"):
        plt.plot(data)
        plt.title(title)
        plt.xlabel("Time")
        plt.ylabel("Value")
        plt.show()

    def predict(self):
        # Fit an ARIMA model and make predictions
        model = ARIMA(self.train_data, order=(1, 1, 1))
        model_fit = model.fit()
        start_index = len(self.train_data)
        end_index = len(self.train_data) + len(self.test_data) - 1
        predictions = model_fit.predict(start=start_index, end=end_index)

        # Calculate RMSE
        rmse = np.sqrt(mean_squared_error(self.test_data, predictions))

        # Plot the data and predictions
        self.plot_data(predictions)

        return predictions, rmse

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions, rmse = cp.predict()
    print(f"RMSE: {rmse}")
124/54:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        self.data = self.load_data(self.symbol)
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-01-01', '2023-12-07')
        return data
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data
    
    # Plot the data
    def plot_data(self, data, title="Data"):
        plt.plot(data)
        plt.title(title)
        plt.xlabel("Time")
        plt.ylabel("Value")
        plt.show()

    def predict(self):
        X_train = self.train[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train['Close']
        X_test = self.test[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test['Close']
        # Fit an ARIMA model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        # Plot the data and predictions
        self.plot_data(predictions)

        return predictions

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions, rmse = cp.predict()
    print(f"RMSE: {rmse}")
124/55:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        self.data = self.load_data(self.symbol)
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-01-01', '2023-12-07')
        return data
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data
    
    # Plot the data
    def plot_data(self, data, title="Data"):
        plt.plot(data)
        plt.title(title)
        plt.xlabel("Time")
        plt.ylabel("Value")
        plt.show()

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']
        # Fit an ARIMA model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        # Plot the data and predictions
        self.plot_data(predictions)

        return predictions

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions, rmse = cp.predict()
    print(f"RMSE: {rmse}")
124/56:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        data = self.add_features()
        self.train_data, self.test_data = self.split_data(data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data
    
    # Plot the data
    def plot_data(self, data, title="Data"):
        plt.plot(data)
        plt.title(title)
        plt.xlabel("Time")
        plt.ylabel("Value")
        plt.show()

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']
        # Fit an ARIMA model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        # Plot the data and predictions
        self.plot_data(predictions)

        return predictions

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions, rmse = cp.predict()
    print(f"RMSE: {rmse}")
124/57:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        data = self.add_features(data)
        self.train_data, self.test_data = self.split_data(data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data
    
    # Plot the data
    def plot_data(self, data, title="Data"):
        plt.plot(data)
        plt.title(title)
        plt.xlabel("Time")
        plt.ylabel("Value")
        plt.show()

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']
        # Fit an ARIMA model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        # Plot the data and predictions
        self.plot_data(predictions)

        return predictions

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions, rmse = cp.predict()
    print(f"RMSE: {rmse}")
124/58:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data
    
    # Plot the data
    def plot_data(self, data, title="Data"):
        plt.plot(data)
        plt.title(title)
        plt.xlabel("Time")
        plt.ylabel("Value")
        plt.show()

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']
        # Fit an ARIMA model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        # Plot the data and predictions
        self.plot_data(predictions)

        return predictions

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions, rmse = cp.predict()
    print(f"RMSE: {rmse}")
124/59:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data
    
    # Plot the data
    def plot_data(self, data, title="Data"):
        plt.plot(data)
        plt.plot(self.data)
        plt.title(title)
        plt.xlabel("Time")
        plt.ylabel("Value")
        plt.show()

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']
        # Fit an ARIMA model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        # Plot the data and predictions
        self.plot_data(predictions)

        return predictions

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions= cp.predict()
124/60:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data
    
    # Plot the data
    def plot_data(self, data, title="Data"):
        plt.plot(data)
       # plt.plot(self.data)
        plt.title(title)
        plt.xlabel("Time")
        plt.ylabel("Value")
        plt.show()

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']
        # Fit an ARIMA model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        # Plot the data and predictions
        self.plot_data(predictions)

        return predictions

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions= cp.predict()
124/61:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data
    
    # Plot the data
    def plot_data(self, data, title="Data"):
        plt.plot(data)
       # plt.plot(self.data)
        plt.title(title)
        plt.xlabel("Time")
        plt.ylabel("Value")
        plt.show()

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']
        # Fit an ARIMA model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        # Plot the data and predictions
        self.plot_data(predictions)

        return predictions

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions= cp.predict()
124/62:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data
    
    # Plot the data
    def plot_data(self, data, title="Data"):
        plt.plot(data)
       # plt.plot(self.data)
        plt.title(title)
        plt.xlabel("Time")
        plt.ylabel("Value")
        plt.show()

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']
        # Fit an ARIMA model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        # Plot the data and predictions
        self.plot_data(predictions)

        return predictions

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions= cp.predict()
    data = cp.data"
124/63:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data
    
    # Plot the data
    def plot_data(self, data, title="Data"):
        plt.plot(data)
       # plt.plot(self.data)
        plt.title(title)
        plt.xlabel("Time")
        plt.ylabel("Value")
        plt.show()

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']
        # Fit an ARIMA model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        # Plot the data and predictions
        self.plot_data(predictions)

        return predictions

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions= cp.predict()
    data = cp.data
124/64: data
124/65: predictions
124/66:
s = data['close']
s
124/67:
s = data.filter('close')
s
124/68:
s = data.filter('Close')
s
124/69:
s = data.filter('Close')
data.columns
124/70:
s = data.filter('Close')
s
124/71:
s = data.filter(['Close'])
s
124/72:
s = data.filter(['Close'])
s.append(predictions)
124/73:
s = data.filter(['Close'])
s.concat(predictions)
124/74:
s = data.filter(['Close'])
pd.concat([s, predictions])
124/75:
s = data.filter(['Close'])
pd.concat([s, pd.DataFrame(predictions, columns['Close'])
124/76:
s = data.filter(['Close'])
pd.concat([s, pd.DataFrame(predictions, columns['Close']))
124/77:
s = data.filter(['Close'])
pd.concat([s, pd.DataFrame(predictions, columns['Close']])
124/78:
s = data.filter(['Close'])
pd.concat([s, pd.DataFrame(predictions, columns['Close'])])
124/79:
s = data.filter(['Close'])
pd.concat([s, pd.DataFrame(predictions, columns=['Close'])])
124/80:
s = data.filter(['Close'])
t = pd.concat([s, pd.DataFrame(predictions, columns=['Close'])])
t.reset_index()
plt.plot(t)
plt.plot(data)
plt.show()
124/81:
s = data.filter(['Close'])
t = pd.concat([s, pd.DataFrame(predictions, columns=['Close'])])
t.reset_index()
plt.plot(t)
#plt.plot(data)
plt.show()
124/82: t
124/83:
s = data.filter(['Close'])
t = pd.concat([s, pd.DataFrame(predictions, columns=['Close'])])
t = t.reset_index()
plt.plot(t)
#plt.plot(data)
plt.show()
124/84:
s = data.filter(['Close'])
t = pd.concat([s, pd.DataFrame(predictions, columns=['Close'])])
t = t.reset_index()
plt.plot(t)
plt.plot(data)
plt.show()
124/85:
s = data.filter(['Close'])
t = pd.concat([s, pd.DataFrame(predictions, columns=['Close'])])
t = t.reset_index()
plt.plot(t)
#plt.plot(data)
plt.show()
124/86: t
124/87:
s = data.filter(['Close'])
t = pd.concat([s, pd.DataFrame(predictions, columns=['Close'])])
t = t.reset_index()
#plt.plot(t)
#plt.plot(data)
plt.show()
124/88:
s = data.filter(['Close'])
t = pd.concat([s, pd.DataFrame(predictions, columns=['Close'])])
t = t.reset_index()
plt.plot(t)
#plt.plot(data)
plt.show()
124/89:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data
    
    # Plot the data
    def plot_data(self, actual, predictions=None, title="Data"):
        plt.figure(figsize=(10, 6))
        plt.plot(actual, label='Actual Data')
        if predictions is not None:
            plt.plot(predictions, color='red', label='Predictions')
        plt.title(title)
        plt.xlabel("Time")
        plt.ylabel("Value")
        plt.legend()
        plt.show()

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']

        # Fit an ARIMA model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        
        # Plot the data and predictions
        self.plot_data(self.test_data['Close'], predictions)

        return predictions

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions= cp.predict()
    data = cp.data
124/90:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data
    
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        plt.figure(figsize=(10, 6))
        plt.plot(full_data['Close'], label='Actual Data')
        plt.plot(test_data.index, predictions, color='red', label='Predictions')
        plt.title(title)
        plt.xlabel("Time")
        plt.ylabel("Value")
        plt.legend()
        plt.show()

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']

        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        return predictions

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions= cp.predict()
    data = cp.data
124/91:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data
    
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        plt.figure(figsize=(10, 6))
        plt.plot(full_data['Close'], label='Actual Data')
        plt.plot(test_data.index, predictions, color='red', label='Predictions')

        # Calculating and plotting the error
        error = test_data['Close'] - predictions
        plt.plot(test_data.index, error, color='green', label='Prediction Error')

        
        plt.title(title)
        plt.xlabel("Time")
        plt.ylabel("Value")
        plt.legend()
        plt.show()

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']

        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        return predictions

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions= cp.predict()
    data = cp.data
124/92:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data
    
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')

        # Creating a secondary y-axis for the error plot
        ax2 = ax1.twinx()  
        error = test_data['Close'] - predictions
        ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        ax2.set_ylabel('Error', color='green')  
        ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']

        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        return predictions

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions= cp.predict()
    data = cp.data
124/93:
import pandas as pd
import yfinance as yf
from sklearn.linear_model import LinearRegression
from sklearn.model_selection import train_test_split
import matplotlib.pyplot as plt
from sklearn.metrics import mean_squared_error
124/94:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data
    
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')

        # Creating a secondary y-axis for the error plot
        ax2 = ax1.twinx()  
        error = (test_data['Close'] - predictions) / 100
        ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        ax2.set_ylabel('Error', color='green')  
        ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']

        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)

        mse = mean_squared_error(y_test, predictions)

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions, mse)

        return predictions

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions= cp.predict()
    data = cp.data
124/95:
s = data.filter(['Close'])
t = pd.concat([s, pd.DataFrame(predictions, columns=['Close'])])
t = t.reset_index()
plt.plot(t)
#plt.plot(data)
plt.show()
124/96:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data
    
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        # ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')

        # Creating a secondary y-axis for the error plot
        ax2 = ax1.twinx()  
        error = (test_data['Close'] - predictions) / 100
        ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        ax2.set_ylabel('Error', color='green')  
        ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']

        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)

        mse = mean_squared_error(y_test, predictions)

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions, mse)

        return predictions

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions= cp.predict()
    data = cp.data
124/97:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data
    
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(test_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')

        # Creating a secondary y-axis for the error plot
        ax2 = ax1.twinx()  
        error = (test_data['Close'] - predictions) / 100
        ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        ax2.set_ylabel('Error', color='green')  
        ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']

        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)

        mse = mean_squared_error(y_test, predictions)

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions, mse)

        return predictions

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions= cp.predict()
    data = cp.data
124/98:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data
    
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        # ax1.plot(full['Close'], label='Actual Data', color='blue')

        ax1.plot(test_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')

        # Creating a secondary y-axis for the error plot
        ax2 = ax1.twinx()  
        error = (test_data['Close'] - predictions) / 100
        ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        ax2.set_ylabel('Error', color='green')  
        ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']

        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)

        mse = mean_squared_error(y_test, predictions)

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions, mse)

        return predictions

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions= cp.predict()
    data = cp.data
124/99:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.4):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data
    
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        # ax1.plot(full['Close'], label='Actual Data', color='blue')

        ax1.plot(test_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')

        # Creating a secondary y-axis for the error plot
        ax2 = ax1.twinx()  
        error = (test_data['Close'] - predictions) / 100
        ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        ax2.set_ylabel('Error', color='green')  
        ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']

        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)

        mse = mean_squared_error(y_test, predictions)

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions, mse)

        return predictions

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions= cp.predict()
    data = cp.data
124/100:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.6):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data
    
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        # ax1.plot(full['Close'], label='Actual Data', color='blue')

        ax1.plot(test_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')

        # Creating a secondary y-axis for the error plot
        ax2 = ax1.twinx()  
        error = (test_data['Close'] - predictions) / 100
        ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        ax2.set_ylabel('Error', color='green')  
        ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']

        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)

        mse = mean_squared_error(y_test, predictions)

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions, mse)

        return predictions

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions= cp.predict()
    data = cp.data
124/101:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.4):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data
    
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full['Close'], label='Actual Data', color='blue')

        ax1.plot(test_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')

        # Creating a secondary y-axis for the error plot
        ax2 = ax1.twinx()  
        error = (test_data['Close'] - predictions) / 100
        ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        ax2.set_ylabel('Error', color='green')  
        ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']

        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)

        mse = mean_squared_error(y_test, predictions)

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions, mse)

        return predictions

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions= cp.predict()
    data = cp.data
124/102:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.4):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data
    
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full['Close'], label='Actual Data', color='blue')

        # ax1.plot(test_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')

        # Creating a secondary y-axis for the error plot
        ax2 = ax1.twinx()  
        error = (test_data['Close'] - predictions) / 100
        ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        ax2.set_ylabel('Error', color='green')  
        ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']

        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)

        mse = mean_squared_error(y_test, predictions)

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions, mse)

        return predictions

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions= cp.predict()
    data = cp.data
124/103:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.4):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data
    
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full['Close'], label='Actual Data', color='blue')

        # ax1.plot(test_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')

        # Creating a secondary y-axis for the error plot
        ax2 = ax1.twinx()  
        error = (test_data['Close'] - predictions) / 100
        ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        ax2.set_ylabel('Error', color='green')  
        ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']

        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)

        mse = mean_squared_error(y_test, predictions)

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions, mse)

        return predictions

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions= cp.predict()
    data = cp.data
124/104:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.4):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data
    
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')

        # ax1.plot(test_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')

        # Creating a secondary y-axis for the error plot
        ax2 = ax1.twinx()  
        error = (test_data['Close'] - predictions) / 100
        ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        ax2.set_ylabel('Error', color='green')  
        ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']

        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)

        mse = mean_squared_error(y_test, predictions)

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions, mse)

        return predictions

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions= cp.predict()
    data = cp.data
124/105:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.4):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data
    
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')

        # ax1.plot(test_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']

        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)

        mse = mean_squared_error(y_test, predictions)

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions, mse)

        return predictions

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions= cp.predict()
    data = cp.data
124/106:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.4):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data
    
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')

        # ax1.plot(test_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']

        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)

        mse = mean_squared_error(y_test, predictions)

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions, mse)

        return predictions

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions= cp.predict()
    data = cp.data
124/107:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.1):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data
    
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')

        # ax1.plot(test_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']

        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)

        mse = mean_squared_error(y_test, predictions)

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions, mse)

        return predictions

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions= cp.predict()
    data = cp.data
124/108:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.1):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data
    
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')

        # ax1.plot(test_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')

        # Creating a secondary y-axis for the error plot
        ax2 = ax1.twinx()  
        error = (test_data['Close'] - predictions) / 100
        error = mean_squared_error(test_data['Close'] - predictions)
        ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        ax2.set_ylabel('Error', color='green')  
        ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']

        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)

        mse = mean_squared_error(y_test, predictions)

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions, mse)

        return predictions

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions= cp.predict()
    data = cp.data
124/109:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.1):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data
    
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')

        # ax1.plot(test_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')

        # Creating a secondary y-axis for the error plot
        ax2 = ax1.twinx()  
        error = (test_data['Close'] - predictions) / 100
        error = mean_squared_error(test_data['Close'] - predictions)
        ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        ax2.set_ylabel('Error', color='green')  
        ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']

        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)

        # mse = mean_squared_error(y_test, predictions)

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions, mse)

        return predictions

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions= cp.predict()
    data = cp.data
124/110:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.1):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data
    
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')

        # ax1.plot(test_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')

        # Creating a secondary y-axis for the error plot
        ax2 = ax1.twinx()  
        error = (test_data['Close'] - predictions) / 100
        error = mean_squared_error(test_data['Close'] - predictions)
        ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        ax2.set_ylabel('Error', color='green')  
        ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']

        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)

        # mse = mean_squared_error(y_test, predictions)

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        return predictions

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions= cp.predict()
    data = cp.data
124/111:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.1):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data
    
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')

        # ax1.plot(test_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')

        # Creating a secondary y-axis for the error plot
        ax2 = ax1.twinx()  
        error = (test_data['Close'] - predictions) / 100
        error = mean_squared_error(test_data['Close'], predictions)
        ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        ax2.set_ylabel('Error', color='green')  
        ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']

        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)

        # mse = mean_squared_error(y_test, predictions)

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        return predictions

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions= cp.predict()
    data = cp.data
124/112:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.1):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data
    
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')

        # ax1.plot(test_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')

        # Creating a secondary y-axis for the error plot
        ax2 = ax1.twinx()  
        error = (test_data['Close'] - predictions) / 100
        error = mean_squared_error(test_data['Close'], predictions)
        print(error
        ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        ax2.set_ylabel('Error', color='green')  
        ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']

        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)

        # mse = mean_squared_error(y_test, predictions)

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        return predictions

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions= cp.predict()
    data = cp.data
124/113:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.1):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data
    
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')

        # ax1.plot(test_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')

        # Creating a secondary y-axis for the error plot
        ax2 = ax1.twinx()  
        error = (test_data['Close'] - predictions) / 100
        error = mean_squared_error(test_data['Close'], predictions)
        print(error)
        ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        ax2.set_ylabel('Error', color='green')  
        ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']

        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)

        # mse = mean_squared_error(y_test, predictions)

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        return predictions

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions= cp.predict()
    data = cp.data
124/114:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.1):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data
    
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')

        # ax1.plot(test_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')

        # Creating a secondary y-axis for the error plot
        ax2 = ax1.twinx()  
        error = (test_data['Close'] - predictions) / 100
        ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        ax2.set_ylabel('Error', color='green')  
        ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']

        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)

        # mse = mean_squared_error(y_test, predictions)

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        return predictions

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions= cp.predict()
    data = cp.data
124/115:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.1):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data
    
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')

        # ax1.plot(test_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # # Adding legends and title
        # ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']

        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)

        # mse = mean_squared_error(y_test, predictions)

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        return predictions

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions= cp.predict()
    data = cp.data
124/116:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.1):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data
    
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')

        # ax1.plot(test_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # # Adding legends and title
        # ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']

        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE'

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        return predictions

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions= cp.predict()
    data = cp.data
124/117:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.1):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data
    
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')

        # ax1.plot(test_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # # Adding legends and title
        # ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']

        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        return predictions

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions= cp.predict()
    data = cp.data
124/118:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.1):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data
    
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')

        # ax1.plot(test_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # # Adding legends and title
        # ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()
        
    def predict_future(self, N):
        # Assuming the model and test data are already available
        last_data = self.data.iloc[-1]
        future_dates = pd.date_range(start=last_data.name, periods=N+1, closed='right')
        future_df = pd.DataFrame(index=future_dates)

        # Here, you need to calculate SMA5, SMA20, SMA60 for the future dates.
        # This is a simplified approach and might not be accurate.
        # A more complex approach would involve using the model's predictions
        # as part of the input for the next prediction.
        for sma_period in [5, 20, 60]:
            sma = self.data['Close'].rolling(sma_period).mean().iloc[-sma_period:]
            extrapolated_sma = sma.append(future_df['Close']).fillna(method='ffill').rolling(sma_period).mean()
            future_df[f'SMA{sma_period}'] = extrapolated_sma

        # Predict for future dates
        future_predictions = self.model.predict(future_df[['SMA5', 'SMA20', 'SMA60']])

        return future_predictions

    def plot_data_with_future(self, full_data, test_data, predictions, future_predictions, mse, title="Data"):
        plt.figure(figsize=(12, 7))
        
        # Plotting the actual data and predictions
        plt.plot(full_data['Close'], label='Actual Data')
        plt.plot(test_data.index, predictions, color='red', label='Predictions')

        # Plotting future predictions
        future_dates = pd.date_range(start=test_data.index[-1], periods=len(future_predictions)+1, closed='right')
        plt.plot(future_dates, future_predictions, color='orange', label='Future Predictions')

        plt.title(f"{title}\nMean Squared Error: {mse:.2f}")
        plt.xlabel("Time")
        plt.ylabel("Value")
        plt.legend()
        plt.show()

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']

        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        N = 30  # number of days to predict into the future
        future_predictions = self.predict_future(N)

        # Calculate Mean Squared Error
        mse = mean_squared_error(y_test, predictions)

        # Plot the full data, predictions, and future predictions
        self.plot_data_with_future(self.data, self.test_data, predictions, future_predictions, mse)


        return predictions

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions= cp.predict()
    data = cp.data
124/119:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.1):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data
    
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')

        # ax1.plot(test_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # # Adding legends and title
        # ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()
        
    def predict_future(self, N):
        # Initialize the future DataFrame with the latest actual data
        last_known_data = self.data.iloc[-60:].copy()  # using 60 days to ensure SMA60 can be calculated
        future_dates = pd.date_range(start=last_known_data.index[-1], periods=N+1, closed='right')
        future_df = pd.DataFrame(index=future_dates)
        future_data = pd.concat([last_known_data, future_df])

        # Iteratively predict each day and use that prediction for subsequent calculations
        for future_date in future_df.index:
            for sma_period in [5, 20, 60]:
                future_data.loc[future_date, f'SMA{sma_period}'] = \
                    future_data['Close'].rolling(sma_period).mean().iloc[-1]

            # Prepare the data for the model
            X_future = future_data.loc[future_date, ['SMA5', 'SMA20', 'SMA60']].values.reshape(1, -1)

            # Predict
            future_prediction = self.model.predict(X_future)[0]

            # Use the prediction as the 'Close' value for the next prediction
            future_data.loc[future_date, 'Close'] = future_prediction

        return future_data.loc[future_df.index, 'Close']

    def plot_data_with_future(self, full_data, test_data, predictions, future_predictions, mse, title="Data"):
        plt.figure(figsize=(12, 7))
        
        # Plotting the actual data and predictions
        plt.plot(full_data['Close'], label='Actual Data')
        plt.plot(test_data.index, predictions, color='red', label='Predictions')

        # Plotting future predictions
        future_dates = pd.date_range(start=test_data.index[-1], periods=len(future_predictions)+1, closed='right')
        plt.plot(future_dates, future_predictions, color='orange', label='Future Predictions')

        plt.title(f"{title}\nMean Squared Error: {mse:.2f}")
        plt.xlabel("Time")
        plt.ylabel("Value")
        plt.legend()
        plt.show()

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']

        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        N = 30  # number of days to predict into the future
        future_predictions = self.predict_future(N)

        # Calculate Mean Squared Error
        mse = mean_squared_error(y_test, predictions)

        # Plot the full data, predictions, and future predictions
        self.plot_data_with_future(self.data, self.test_data, predictions, future_predictions, mse)


        return predictions

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions= cp.predict()
    data = cp.data
124/120:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.1):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data
    
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')

        # ax1.plot(test_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # # Adding legends and title
        # ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()
        
    def predict_future(self, N):
        # Initialize the future DataFrame with the latest actual data
        last_known_data = self.data.iloc[-60:].copy()  # using 60 days to ensure SMA60 can be calculated
        future_dates = pd.date_range(start=last_known_data.index[-1], periods=N+1, closed='right')
        future_df = pd.DataFrame(index=future_dates)
        future_data = pd.concat([last_known_data, future_df])

        # Iteratively predict each day and use that prediction for subsequent calculations
        for future_date in future_df.index:
            for sma_period in [5, 20, 60]:
                future_data.loc[future_date, f'SMA{sma_period}'] = \
                    future_data['Close'].rolling(sma_period).mean().iloc[-1]

            # Prepare the data for the model
            X_future = future_data.loc[future_date, ['SMA5', 'SMA20', 'SMA60']].values.reshape(1, -1)

            # Predict
            future_prediction = self.model.predict(X_future)[0]

            # Use the prediction as the 'Close' value for the next prediction
            future_data.loc[future_date, 'Close'] = future_prediction

        return future_data.loc[future_df.index, 'Close']

    def plot_data_with_future(self, full_data, test_data, predictions, future_predictions, mse, title="Data"):
        plt.figure(figsize=(12, 7))
        
        # Plotting the actual data and predictions
        plt.plot(full_data['Close'], label='Actual Data')
        plt.plot(test_data.index, predictions, color='red', label='Predictions')

        # Plotting future predictions
        future_dates = pd.date_range(start=test_data.index[-1], periods=len(future_predictions)+1, closed='right')
        plt.plot(future_dates, future_predictions, color='orange', label='Future Predictions')

        plt.title(f"{title}\nMean Squared Error: {mse:.2f}")
        plt.xlabel("Time")
        plt.ylabel("Value")
        plt.legend()
        plt.show()

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']

        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        N = 30  # number of days to predict into the future
        future_predictions = self.predict_future(N)

        # Calculate Mean Squared Error
        mse = mean_squared_error(y_test, predictions)

        # Plot the full data, predictions, and future predictions
        self.plot_data_with_future(self.data, self.test_data, predictions, future_predictions, mse)


        return predictions

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions= cp.predict()
    data = cp.data
124/121:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.1):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data
    
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')

        # ax1.plot(test_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # # Adding legends and title
        # ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()
        
    def predict_future(self, N):
        # Initialize the future DataFrame with the latest actual data
        last_known_data = self.data.iloc[-60:].copy()  # using 60 days to ensure SMA60 can be calculated
        future_dates = pd.date_range(start=last_known_data.index[-1], periods=N+1, closed='right')
        future_df = pd.DataFrame(index=future_dates)
        future_data = pd.concat([last_known_data, future_df])

        # Iteratively predict each day and use that prediction for subsequent calculations
        for future_date in future_df.index:
            for sma_period in [5, 20, 60]:
                future_data.loc[future_date, f'SMA{sma_period}'] = \
                    future_data['Close'].rolling(sma_period).mean().iloc[-1]

            # Prepare the data for the model
            X_future = future_data.loc[future_date, ['SMA5', 'SMA20', 'SMA60']].values.reshape(1, -1)

            print(X_future, 'ai')

            # Predict
            future_prediction = self.model.predict(X_future)[0]

            # Use the prediction as the 'Close' value for the next prediction
            future_data.loc[future_date, 'Close'] = future_prediction

        return future_data.loc[future_df.index, 'Close']

    def plot_data_with_future(self, full_data, test_data, predictions, future_predictions, mse, title="Data"):
        plt.figure(figsize=(12, 7))
        
        # Plotting the actual data and predictions
        plt.plot(full_data['Close'], label='Actual Data')
        plt.plot(test_data.index, predictions, color='red', label='Predictions')

        # Plotting future predictions
        future_dates = pd.date_range(start=test_data.index[-1], periods=len(future_predictions)+1, closed='right')
        plt.plot(future_dates, future_predictions, color='orange', label='Future Predictions')

        plt.title(f"{title}\nMean Squared Error: {mse:.2f}")
        plt.xlabel("Time")
        plt.ylabel("Value")
        plt.legend()
        plt.show()

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']

        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        N = 30  # number of days to predict into the future
        future_predictions = self.predict_future(N)

        # Calculate Mean Squared Error
        mse = mean_squared_error(y_test, predictions)

        # Plot the full data, predictions, and future predictions
        self.plot_data_with_future(self.data, self.test_data, predictions, future_predictions, mse)


        return predictions

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions= cp.predict()
    data = cp.data
124/122:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.1):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data
    
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')

        # ax1.plot(test_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # # Adding legends and title
        # ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()
        
    def predict_future(self, N):
        # Initialize the future DataFrame with the latest actual data
        last_known_data = self.data.iloc[-60:].copy()  # using 60 days to ensure SMA60 can be calculated
        future_dates = pd.date_range(start=last_known_data.index[-1], periods=N+1, closed='right')
        future_df = pd.DataFrame(index=future_dates)
        future_data = pd.concat([last_known_data, future_df])

        # Iteratively predict each day and use that prediction for subsequent calculations
        for future_date in future_df.index:
            for sma_period in [5, 20, 60]:
                future_data.loc[future_date, f'SMA{sma_period}'] = \
                    future_data['Close'].rolling(sma_period).mean().iloc[-1]

            # Prepare the data for the model
            X_future = future_data.loc[future_date, ['SMA5', 'SMA20', 'SMA60']].values.reshape(1, -1)

            print(future_data, 'ai')

            # Predict
            future_prediction = self.model.predict(X_future)[0]

            # Use the prediction as the 'Close' value for the next prediction
            future_data.loc[future_date, 'Close'] = future_prediction

        return future_data.loc[future_df.index, 'Close']

    def plot_data_with_future(self, full_data, test_data, predictions, future_predictions, mse, title="Data"):
        plt.figure(figsize=(12, 7))
        
        # Plotting the actual data and predictions
        plt.plot(full_data['Close'], label='Actual Data')
        plt.plot(test_data.index, predictions, color='red', label='Predictions')

        # Plotting future predictions
        future_dates = pd.date_range(start=test_data.index[-1], periods=len(future_predictions)+1, closed='right')
        plt.plot(future_dates, future_predictions, color='orange', label='Future Predictions')

        plt.title(f"{title}\nMean Squared Error: {mse:.2f}")
        plt.xlabel("Time")
        plt.ylabel("Value")
        plt.legend()
        plt.show()

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']

        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        N = 30  # number of days to predict into the future
        future_predictions = self.predict_future(N)

        # Calculate Mean Squared Error
        mse = mean_squared_error(y_test, predictions)

        # Plot the full data, predictions, and future predictions
        self.plot_data_with_future(self.data, self.test_data, predictions, future_predictions, mse)


        return predictions

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions= cp.predict()
    data = cp.data
124/123:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.1):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data
    
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')

        # ax1.plot(test_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # # Adding legends and title
        # ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()
        
    def predict_future(self, N):
        # Initialize the future DataFrame with the latest actual data
        last_known_data = self.data.iloc[-120:].copy()  # using 60 days to ensure SMA60 can be calculated
        future_dates = pd.date_range(start=last_known_data.index[-1], periods=N+1, closed='right')
        future_df = pd.DataFrame(index=future_dates)
        future_data = pd.concat([last_known_data, future_df])

        # Iteratively predict each day and use that prediction for subsequent calculations
        for future_date in future_df.index:
            for sma_period in [5, 20, 60]:
                future_data.loc[future_date, f'SMA{sma_period}'] = \
                    future_data['Close'].rolling(sma_period).mean().iloc[-1]

            # Prepare the data for the model
            X_future = future_data.loc[future_date, ['SMA5', 'SMA20', 'SMA60']].values.reshape(1, -1)

            print(future_data, 'ai')

            # Predict
            future_prediction = self.model.predict(X_future)[0]

            # Use the prediction as the 'Close' value for the next prediction
            future_data.loc[future_date, 'Close'] = future_prediction

        return future_data.loc[future_df.index, 'Close']

    def plot_data_with_future(self, full_data, test_data, predictions, future_predictions, mse, title="Data"):
        plt.figure(figsize=(12, 7))
        
        # Plotting the actual data and predictions
        plt.plot(full_data['Close'], label='Actual Data')
        plt.plot(test_data.index, predictions, color='red', label='Predictions')

        # Plotting future predictions
        future_dates = pd.date_range(start=test_data.index[-1], periods=len(future_predictions)+1, closed='right')
        plt.plot(future_dates, future_predictions, color='orange', label='Future Predictions')

        plt.title(f"{title}\nMean Squared Error: {mse:.2f}")
        plt.xlabel("Time")
        plt.ylabel("Value")
        plt.legend()
        plt.show()

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']

        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        N = 30  # number of days to predict into the future
        future_predictions = self.predict_future(N)

        # Calculate Mean Squared Error
        mse = mean_squared_error(y_test, predictions)

        # Plot the full data, predictions, and future predictions
        self.plot_data_with_future(self.data, self.test_data, predictions, future_predictions, mse)


        return predictions

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions= cp.predict()
    data = cp.data
124/124:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.1):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data
    
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')

        # ax1.plot(test_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # # Adding legends and title
        # ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()
        
    def predict_future(self, N):
        # Initialize the future DataFrame with the latest actual data
        last_known_data = self.data.iloc[-60:].copy()  # using 60 days to ensure SMA60 can be calculated
        future_dates = pd.date_range(start=last_known_data.index[-1], periods=N+1, closed='right')
        future_df = pd.DataFrame(index=future_dates, columns=self.data.columns)
        future_data = pd.concat([last_known_data, future_df])

        # Iteratively predict each day and use that prediction for subsequent calculations
        for future_date in future_df.index:
            for sma_period in [5, 20, 60]:
                # Calculate SMA values, using available 'Close' values
                sma_values = future_data['Close'].rolling(sma_period, min_periods=1).mean()
                future_data.loc[future_date, f'SMA{sma_period}'] = sma_values.iloc[-1]

            # Prepare the data for the model
            X_future = future_data.loc[future_date, ['SMA5', 'SMA20', 'SMA60']].values.reshape(1, -1)

            # Predict
            future_prediction = self.model.predict(X_future)[0]

            # Use the prediction as the 'Close' value for the next prediction
            future_data.loc[future_date, 'Close'] = future_prediction

        return future_data.loc[future_df.index, 'Close']

    def plot_data_with_future(self, full_data, test_data, predictions, future_predictions, mse, title="Data"):
        plt.figure(figsize=(12, 7))
        
        # Plotting the actual data and predictions
        plt.plot(full_data['Close'], label='Actual Data')
        plt.plot(test_data.index, predictions, color='red', label='Predictions')

        # Plotting future predictions
        future_dates = pd.date_range(start=test_data.index[-1], periods=len(future_predictions)+1, closed='right')
        plt.plot(future_dates, future_predictions, color='orange', label='Future Predictions')

        plt.title(f"{title}\nMean Squared Error: {mse:.2f}")
        plt.xlabel("Time")
        plt.ylabel("Value")
        plt.legend()
        plt.show()

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']

        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        N = 30  # number of days to predict into the future
        future_predictions = self.predict_future(N)

        # Calculate Mean Squared Error
        mse = mean_squared_error(y_test, predictions)

        # Plot the full data, predictions, and future predictions
        self.plot_data_with_future(self.data, self.test_data, predictions, future_predictions, mse)


        return predictions

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions= cp.predict()
    data = cp.data
124/125:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.1):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data
    
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')

        # ax1.plot(test_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # # Adding legends and title
        # ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()
        
    def predict_future(self, N):
        # Initialize the future DataFrame with the latest actual data
        last_known_data = self.data.iloc[-60:].copy()  # using 60 days to ensure SMA60 can be calculated
        future_dates = pd.date_range(start=last_known_data.index[-1], periods=N+1, closed='right')
        future_df = pd.DataFrame(index=future_dates, columns=self.data.columns)
        future_data = pd.concat([last_known_data, future_df])

        # Iteratively predict each day and use that prediction for subsequent calculations
        for future_date in future_df.index:
            for sma_period in [5, 20, 60]:
                # Calculate SMA values, using available 'Close' values
                sma_values = future_data['Close'].rolling(sma_period, min_periods=1).mean()
                print(sma_values)
                future_data.loc[future_date, f'SMA{sma_period}'] = sma_values.iloc[-1]

            # Prepare the data for the model
            X_future = future_data.loc[future_date, ['SMA5', 'SMA20', 'SMA60']].values.reshape(1, -1)

            # Predict
            future_prediction = self.model.predict(X_future)[0]

            # Use the prediction as the 'Close' value for the next prediction
            future_data.loc[future_date, 'Close'] = future_prediction

        return future_data.loc[future_df.index, 'Close']

    def plot_data_with_future(self, full_data, test_data, predictions, future_predictions, mse, title="Data"):
        plt.figure(figsize=(12, 7))
        
        # Plotting the actual data and predictions
        plt.plot(full_data['Close'], label='Actual Data')
        plt.plot(test_data.index, predictions, color='red', label='Predictions')

        # Plotting future predictions
        future_dates = pd.date_range(start=test_data.index[-1], periods=len(future_predictions)+1, closed='right')
        plt.plot(future_dates, future_predictions, color='orange', label='Future Predictions')

        plt.title(f"{title}\nMean Squared Error: {mse:.2f}")
        plt.xlabel("Time")
        plt.ylabel("Value")
        plt.legend()
        plt.show()

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']

        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        N = 30  # number of days to predict into the future
        future_predictions = self.predict_future(N)

        # Calculate Mean Squared Error
        mse = mean_squared_error(y_test, predictions)

        # Plot the full data, predictions, and future predictions
        self.plot_data_with_future(self.data, self.test_data, predictions, future_predictions, mse)


        return predictions

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions= cp.predict()
    data = cp.data
124/126:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.1):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data
    
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')

        # ax1.plot(test_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # # Adding legends and title
        # ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()
        
    def predict_future(self, N):
        # Initialize the future DataFrame with the latest actual data
        last_known_data = self.data.iloc[-60:].copy()  # using 60 days to ensure SMA60 can be calculated
        future_dates = pd.date_range(start=last_known_data.index[-1], periods=N+1, closed='right')
        future_df = pd.DataFrame(index=future_dates, columns=self.data.columns)
        future_data = pd.concat([last_known_data, future_df])
        print(future_data)

        # Iteratively predict each day and use that prediction for subsequent calculations
        for future_date in future_df.index:
            for sma_period in [5, 20, 60]:
                # Calculate SMA values, using available 'Close' values
                sma_values = future_data['Close'].rolling(sma_period, min_periods=1).mean()
                print(sma_values)
                future_data.loc[future_date, f'SMA{sma_period}'] = sma_values.iloc[-1]

            # Prepare the data for the model
            X_future = future_data.loc[future_date, ['SMA5', 'SMA20', 'SMA60']].values.reshape(1, -1)

            # Predict
            future_prediction = self.model.predict(X_future)[0]

            # Use the prediction as the 'Close' value for the next prediction
            future_data.loc[future_date, 'Close'] = future_prediction

        return future_data.loc[future_df.index, 'Close']

    def plot_data_with_future(self, full_data, test_data, predictions, future_predictions, mse, title="Data"):
        plt.figure(figsize=(12, 7))
        
        # Plotting the actual data and predictions
        plt.plot(full_data['Close'], label='Actual Data')
        plt.plot(test_data.index, predictions, color='red', label='Predictions')

        # Plotting future predictions
        future_dates = pd.date_range(start=test_data.index[-1], periods=len(future_predictions)+1, closed='right')
        plt.plot(future_dates, future_predictions, color='orange', label='Future Predictions')

        plt.title(f"{title}\nMean Squared Error: {mse:.2f}")
        plt.xlabel("Time")
        plt.ylabel("Value")
        plt.legend()
        plt.show()

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']

        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        N = 30  # number of days to predict into the future
        future_predictions = self.predict_future(N)

        # Calculate Mean Squared Error
        mse = mean_squared_error(y_test, predictions)

        # Plot the full data, predictions, and future predictions
        self.plot_data_with_future(self.data, self.test_data, predictions, future_predictions, mse)


        return predictions

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions= cp.predict()
    data = cp.data
124/127:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.1):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data
    
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')

        # ax1.plot(test_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # # Adding legends and title
        # ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()
        
    def predict_future(self, N):
        # Initialize the future DataFrame with the latest actual data
        last_known_data = self.data.iloc[-60:].copy()  # using 60 days to ensure SMA60 can be calculated
        future_dates = pd.date_range(start=last_known_data.index[-1], periods=N+1, closed='right')
        future_df = pd.DataFrame(index=future_dates, columns=self.data.columns)
        future_data = pd.concat([last_known_data, future_df])
        print(future_data)

        # Iteratively predict each day and use that prediction for subsequent calculations
        for future_date in future_df.index:
            for sma_period in [5, 20, 60]:
                # Calculate SMA values, using available 'Close' values
                sma_values = future_data['Close'].rolling(sma_period, min_periods=1).mean()
                # print(sma_values)
                future_data.loc[future_date, f'SMA{sma_period}'] = sma_values.iloc[-1]

            # Prepare the data for the model
            X_future = future_data.loc[future_date, ['SMA5', 'SMA20', 'SMA60']].values.reshape(1, -1)

            # Predict
            future_prediction = self.model.predict(X_future)[0]

            # Use the prediction as the 'Close' value for the next prediction
            future_data.loc[future_date, 'Close'] = future_prediction

        return future_data.loc[future_df.index, 'Close']

    def plot_data_with_future(self, full_data, test_data, predictions, future_predictions, mse, title="Data"):
        plt.figure(figsize=(12, 7))
        
        # Plotting the actual data and predictions
        plt.plot(full_data['Close'], label='Actual Data')
        plt.plot(test_data.index, predictions, color='red', label='Predictions')

        # Plotting future predictions
        future_dates = pd.date_range(start=test_data.index[-1], periods=len(future_predictions)+1, closed='right')
        plt.plot(future_dates, future_predictions, color='orange', label='Future Predictions')

        plt.title(f"{title}\nMean Squared Error: {mse:.2f}")
        plt.xlabel("Time")
        plt.ylabel("Value")
        plt.legend()
        plt.show()

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']

        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        N = 30  # number of days to predict into the future
        future_predictions = self.predict_future(N)

        # Calculate Mean Squared Error
        mse = mean_squared_error(y_test, predictions)

        # Plot the full data, predictions, and future predictions
        self.plot_data_with_future(self.data, self.test_data, predictions, future_predictions, mse)


        return predictions

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions= cp.predict()
    data = cp.data
124/128:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.1):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data
    
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')

        # ax1.plot(test_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # # Adding legends and title
        # ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()
        
    def predict_future(self, N):
        # Initialize the future DataFrame with the latest actual data
        last_known_data = self.data.iloc[-60:].copy()  # using 60 days to ensure SMA60 can be calculated
        print(last_known_data)
        future_dates = pd.date_range(start=last_known_data.index[-1], periods=N+1, closed='right')
        future_df = pd.DataFrame(index=future_dates, columns=self.data.columns)
        future_data = pd.concat([last_known_data, future_df])
        print(future_data)

        # Iteratively predict each day and use that prediction for subsequent calculations
        for future_date in future_df.index:
            for sma_period in [5, 20, 60]:
                # Calculate SMA values, using available 'Close' values
                sma_values = future_data['Close'].rolling(sma_period, min_periods=1).mean()
                # print(sma_values)
                future_data.loc[future_date, f'SMA{sma_period}'] = sma_values.iloc[-1]

            # Prepare the data for the model
            X_future = future_data.loc[future_date, ['SMA5', 'SMA20', 'SMA60']].values.reshape(1, -1)

            # Predict
            future_prediction = self.model.predict(X_future)[0]

            # Use the prediction as the 'Close' value for the next prediction
            future_data.loc[future_date, 'Close'] = future_prediction

        return future_data.loc[future_df.index, 'Close']

    def plot_data_with_future(self, full_data, test_data, predictions, future_predictions, mse, title="Data"):
        plt.figure(figsize=(12, 7))
        
        # Plotting the actual data and predictions
        plt.plot(full_data['Close'], label='Actual Data')
        plt.plot(test_data.index, predictions, color='red', label='Predictions')

        # Plotting future predictions
        future_dates = pd.date_range(start=test_data.index[-1], periods=len(future_predictions)+1, closed='right')
        plt.plot(future_dates, future_predictions, color='orange', label='Future Predictions')

        plt.title(f"{title}\nMean Squared Error: {mse:.2f}")
        plt.xlabel("Time")
        plt.ylabel("Value")
        plt.legend()
        plt.show()

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']

        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        N = 30  # number of days to predict into the future
        future_predictions = self.predict_future(N)

        # Calculate Mean Squared Error
        mse = mean_squared_error(y_test, predictions)

        # Plot the full data, predictions, and future predictions
        self.plot_data_with_future(self.data, self.test_data, predictions, future_predictions, mse)


        return predictions

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions= cp.predict()
    data = cp.data
124/129:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.1):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data
    
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')

        # ax1.plot(test_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # # Adding legends and title
        # ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()
        
    def predict_future(self, N):
        # Initialize the future DataFrame with the latest actual data
        last_known_data = self.data.iloc[-60:].copy()  # using 60 days to ensure SMA60 can be calculated
        future_dates = pd.date_range(start=last_known_data.index[-1], periods=N+1, closed='right')
        future_df = pd.DataFrame(index=future_dates, columns=self.data.columns)
        future_data = pd.concat([last_known_data, future_df])
        print(future_data)

        # Iteratively predict each day and use that prediction for subsequent calculations
        for future_date in future_df.index:
            for sma_period in [5, 20, 60]:
                # Calculate SMA values, using available 'Close' values
                sma_values = future_data['Close'].rolling(sma_period, min_periods=1).mean()
                # print(sma_values)
                future_data.loc[future_date, f'SMA{sma_period}'] = sma_values.iloc[-1]
                print(sma_values.iloc[-1])

            # Prepare the data for the model
            X_future = future_data.loc[future_date, ['SMA5', 'SMA20', 'SMA60']].values.reshape(1, -1)

            # Predict
            future_prediction = self.model.predict(X_future)[0]

            # Use the prediction as the 'Close' value for the next prediction
            future_data.loc[future_date, 'Close'] = future_prediction

        return future_data.loc[future_df.index, 'Close']

    def plot_data_with_future(self, full_data, test_data, predictions, future_predictions, mse, title="Data"):
        plt.figure(figsize=(12, 7))
        
        # Plotting the actual data and predictions
        plt.plot(full_data['Close'], label='Actual Data')
        plt.plot(test_data.index, predictions, color='red', label='Predictions')

        # Plotting future predictions
        future_dates = pd.date_range(start=test_data.index[-1], periods=len(future_predictions)+1, closed='right')
        plt.plot(future_dates, future_predictions, color='orange', label='Future Predictions')

        plt.title(f"{title}\nMean Squared Error: {mse:.2f}")
        plt.xlabel("Time")
        plt.ylabel("Value")
        plt.legend()
        plt.show()

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']

        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        N = 30  # number of days to predict into the future
        future_predictions = self.predict_future(N)

        # Calculate Mean Squared Error
        mse = mean_squared_error(y_test, predictions)

        # Plot the full data, predictions, and future predictions
        self.plot_data_with_future(self.data, self.test_data, predictions, future_predictions, mse)


        return predictions

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions= cp.predict()
    data = cp.data
124/130:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.1):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data
    
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')

        # ax1.plot(test_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # # Adding legends and title
        # ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()
        
    def predict_future(self, N):
        # Initialize the future DataFrame with the latest actual data
        last_known_data = self.data.iloc[-60:].copy()  # using 60 days to ensure SMA60 can be calculated
        future_dates = pd.date_range(start=last_known_data.index[-1], periods=N+1, closed='right')
        future_df = pd.DataFrame(index=future_dates, columns=self.data.columns)
        future_data = pd.concat([last_known_data, future_df])
        # print(future_data)

        # Iteratively predict each day and use that prediction for subsequent calculations
        for future_date in future_df.index:
            for sma_period in [5, 20, 60]:
                # Calculate SMA values, using available 'Close' values
                sma_values = future_data['Close'].rolling(sma_period, min_periods=1).mean()
                # print(sma_values)
                future_data.loc[future_date, f'SMA{sma_period}'] = sma_values.iloc[-1]
                print(sma_values.iloc[-1])

            # Prepare the data for the model
            X_future = future_data.loc[future_date, ['SMA5', 'SMA20', 'SMA60']].values.reshape(1, -1)

            # Predict
            future_prediction = self.model.predict(X_future)[0]

            # Use the prediction as the 'Close' value for the next prediction
            future_data.loc[future_date, 'Close'] = future_prediction

        return future_data.loc[future_df.index, 'Close']

    def plot_data_with_future(self, full_data, test_data, predictions, future_predictions, mse, title="Data"):
        plt.figure(figsize=(12, 7))
        
        # Plotting the actual data and predictions
        plt.plot(full_data['Close'], label='Actual Data')
        plt.plot(test_data.index, predictions, color='red', label='Predictions')

        # Plotting future predictions
        future_dates = pd.date_range(start=test_data.index[-1], periods=len(future_predictions)+1, closed='right')
        plt.plot(future_dates, future_predictions, color='orange', label='Future Predictions')

        plt.title(f"{title}\nMean Squared Error: {mse:.2f}")
        plt.xlabel("Time")
        plt.ylabel("Value")
        plt.legend()
        plt.show()

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']

        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        N = 30  # number of days to predict into the future
        future_predictions = self.predict_future(N)

        # Calculate Mean Squared Error
        mse = mean_squared_error(y_test, predictions)

        # Plot the full data, predictions, and future predictions
        self.plot_data_with_future(self.data, self.test_data, predictions, future_predictions, mse)


        return predictions

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions= cp.predict()
    data = cp.data
124/131:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.1):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data
    
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')

        # ax1.plot(test_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # # Adding legends and title
        # ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()
        
    def predict_future(self, N):
        # Initialize the future DataFrame with the latest actual data
        last_known_data = self.data.iloc[-60:].copy()  # using 60 days to ensure SMA60 can be calculated
        future_dates = pd.date_range(start=last_known_data.index[-1], periods=N+1, closed='right')
        future_df = pd.DataFrame(index=future_dates, columns=self.data.columns)
        future_data = pd.concat([last_known_data, future_df])
        # print(future_data)

        # Iteratively predict each day and use that prediction for subsequent calculations
        for future_date in future_df.index:
            for sma_period in [5, 20, 60]:
                # Calculate SMA values, using available 'Close' values
                sma_values = future_data['Close'].rolling(sma_period, min_periods=1).mean()
                # print(sma_values)
                future_data.loc[future_date, f'SMA{sma_period}'] = sma_values.iloc[-1]
                print(sma_values.iloc[-1], 'nan')

            # Prepare the data for the model
            X_future = future_data.loc[future_date, ['SMA5', 'SMA20', 'SMA60']].values.reshape(1, -1)

            # Predict
            future_prediction = self.model.predict(X_future)[0]

            # Use the prediction as the 'Close' value for the next prediction
            future_data.loc[future_date, 'Close'] = future_prediction

        return future_data.loc[future_df.index, 'Close']

    def plot_data_with_future(self, full_data, test_data, predictions, future_predictions, mse, title="Data"):
        plt.figure(figsize=(12, 7))
        
        # Plotting the actual data and predictions
        plt.plot(full_data['Close'], label='Actual Data')
        plt.plot(test_data.index, predictions, color='red', label='Predictions')

        # Plotting future predictions
        future_dates = pd.date_range(start=test_data.index[-1], periods=len(future_predictions)+1, closed='right')
        plt.plot(future_dates, future_predictions, color='orange', label='Future Predictions')

        plt.title(f"{title}\nMean Squared Error: {mse:.2f}")
        plt.xlabel("Time")
        plt.ylabel("Value")
        plt.legend()
        plt.show()

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']

        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        N = 30  # number of days to predict into the future
        future_predictions = self.predict_future(N)

        # Calculate Mean Squared Error
        mse = mean_squared_error(y_test, predictions)

        # Plot the full data, predictions, and future predictions
        self.plot_data_with_future(self.data, self.test_data, predictions, future_predictions, mse)


        return predictions

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions= cp.predict()
    data = cp.data
124/132:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.1):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data
    
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')

        # ax1.plot(test_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # # Adding legends and title
        # ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()
        
    def predict_future(self, N):
        # Initialize the future DataFrame with the latest actual data
        last_known_data = self.data.iloc[-60:].copy()  # using 60 days to ensure SMA60 can be calculated
        future_dates = pd.date_range(start=last_known_data.index[-1], periods=N+1, closed='right')
        future_df = pd.DataFrame(index=future_dates, columns=self.data.columns)
        future_data = pd.concat([last_known_data, future_df])
        # print(future_data)

        # Iteratively predict each day and use that prediction for subsequent calculations
        for future_date in future_df.index:
            for sma_period in [5, 20, 60]:
                # Calculate SMA values, using available 'Close' values
                sma_values = future_data['Close'].rolling(sma_period, min_periods=1).mean()
                # print(sma_values)
                future_data.loc[future_date, f'SMA{sma_period}'] = sma_values.iloc[-1]
                print(sma_values, sma_values.iloc[-1], 'nan')

            # Prepare the data for the model
            X_future = future_data.loc[future_date, ['SMA5', 'SMA20', 'SMA60']].values.reshape(1, -1)

            # Predict
            future_prediction = self.model.predict(X_future)[0]

            # Use the prediction as the 'Close' value for the next prediction
            future_data.loc[future_date, 'Close'] = future_prediction

        return future_data.loc[future_df.index, 'Close']

    def plot_data_with_future(self, full_data, test_data, predictions, future_predictions, mse, title="Data"):
        plt.figure(figsize=(12, 7))
        
        # Plotting the actual data and predictions
        plt.plot(full_data['Close'], label='Actual Data')
        plt.plot(test_data.index, predictions, color='red', label='Predictions')

        # Plotting future predictions
        future_dates = pd.date_range(start=test_data.index[-1], periods=len(future_predictions)+1, closed='right')
        plt.plot(future_dates, future_predictions, color='orange', label='Future Predictions')

        plt.title(f"{title}\nMean Squared Error: {mse:.2f}")
        plt.xlabel("Time")
        plt.ylabel("Value")
        plt.legend()
        plt.show()

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']

        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        N = 30  # number of days to predict into the future
        future_predictions = self.predict_future(N)

        # Calculate Mean Squared Error
        mse = mean_squared_error(y_test, predictions)

        # Plot the full data, predictions, and future predictions
        self.plot_data_with_future(self.data, self.test_data, predictions, future_predictions, mse)


        return predictions

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions= cp.predict()
    data = cp.data
124/133:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.1):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data
    
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')

        # ax1.plot(test_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # # Adding legends and title
        # ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()
        
    def predict_future(self, N):
        # Initialize the future DataFrame with the latest actual data
        last_known_data = self.data.iloc[-60:].copy()  # using 60 days to ensure SMA60 can be calculated
        future_dates = pd.date_range(start=last_known_data.index[-1], periods=N+1, closed='right')
        future_df = pd.DataFrame(index=future_dates, columns=self.data.columns)
        future_data = pd.concat([last_known_data, future_df])
        # print(future_data)

        # Iteratively predict each day and use that prediction for subsequent calculations
        for future_date in future_df.index:
            for sma_period in [5, 20, 60]:
                # Calculate SMA values, using available 'Close' values
                sma_values = future_data['Close'].rolling(sma_period, min_periods=1).mean()
                # print(sma_values)
                future_data.loc[future_date, f'SMA{sma_period}'] = sma_values.iloc[-1]
                print(sma_values.dropna(), sma_values.iloc[-1], 'nan')

            # Prepare the data for the model
            X_future = future_data.loc[future_date, ['SMA5', 'SMA20', 'SMA60']].values.reshape(1, -1)

            # Predict
            future_prediction = self.model.predict(X_future)[0]

            # Use the prediction as the 'Close' value for the next prediction
            future_data.loc[future_date, 'Close'] = future_prediction

        return future_data.loc[future_df.index, 'Close']

    def plot_data_with_future(self, full_data, test_data, predictions, future_predictions, mse, title="Data"):
        plt.figure(figsize=(12, 7))
        
        # Plotting the actual data and predictions
        plt.plot(full_data['Close'], label='Actual Data')
        plt.plot(test_data.index, predictions, color='red', label='Predictions')

        # Plotting future predictions
        future_dates = pd.date_range(start=test_data.index[-1], periods=len(future_predictions)+1, closed='right')
        plt.plot(future_dates, future_predictions, color='orange', label='Future Predictions')

        plt.title(f"{title}\nMean Squared Error: {mse:.2f}")
        plt.xlabel("Time")
        plt.ylabel("Value")
        plt.legend()
        plt.show()

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']

        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        N = 30  # number of days to predict into the future
        future_predictions = self.predict_future(N)

        # Calculate Mean Squared Error
        mse = mean_squared_error(y_test, predictions)

        # Plot the full data, predictions, and future predictions
        self.plot_data_with_future(self.data, self.test_data, predictions, future_predictions, mse)


        return predictions

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions= cp.predict()
    data = cp.data
124/134:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.1):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data
    
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')

        # ax1.plot(test_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # # Adding legends and title
        # ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()
        
    def predict_future(self, N):
        # Initialize the future DataFrame with the latest actual data
        last_known_data = self.data.iloc[-60:].copy()  # using 60 days to ensure SMA60 can be calculated
        future_dates = pd.date_range(start=last_known_data.index[-1], periods=N+1, closed='right')
        future_df = pd.DataFrame(index=future_dates, columns=self.data.columns)
        future_data = pd.concat([last_known_data, future_df])
        # print(future_data)

        # Iteratively predict each day and use that prediction for subsequent calculations
        for future_date in future_df.index:
            for sma_period in [5, 20, 60]:
                # Calculate SMA values, using available 'Close' values
                sma_values = future_data['Close'].rolling(sma_period, min_periods=1).mean()
                # print(sma_values)
                future_data.loc[future_date, f'SMA{sma_period}'] = sma_values.iloc[-1].dropna()
                # print(sma_values.dropna(), sma_values.iloc[-1], 'nan')

            # Prepare the data for the model
            X_future = future_data.loc[future_date, ['SMA5', 'SMA20', 'SMA60']].values.reshape(1, -1)

            # Predict
            future_prediction = self.model.predict(X_future)[0]

            # Use the prediction as the 'Close' value for the next prediction
            future_data.loc[future_date, 'Close'] = future_prediction

        return future_data.loc[future_df.index, 'Close']

    def plot_data_with_future(self, full_data, test_data, predictions, future_predictions, mse, title="Data"):
        plt.figure(figsize=(12, 7))
        
        # Plotting the actual data and predictions
        plt.plot(full_data['Close'], label='Actual Data')
        plt.plot(test_data.index, predictions, color='red', label='Predictions')

        # Plotting future predictions
        future_dates = pd.date_range(start=test_data.index[-1], periods=len(future_predictions)+1, closed='right')
        plt.plot(future_dates, future_predictions, color='orange', label='Future Predictions')

        plt.title(f"{title}\nMean Squared Error: {mse:.2f}")
        plt.xlabel("Time")
        plt.ylabel("Value")
        plt.legend()
        plt.show()

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']

        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        N = 30  # number of days to predict into the future
        future_predictions = self.predict_future(N)

        # Calculate Mean Squared Error
        mse = mean_squared_error(y_test, predictions)

        # Plot the full data, predictions, and future predictions
        self.plot_data_with_future(self.data, self.test_data, predictions, future_predictions, mse)


        return predictions

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions= cp.predict()
    data = cp.data
124/135:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.1):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data
    
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')

        # ax1.plot(test_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # # Adding legends and title
        # ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()
        
    def predict_future(self, N):
        # Initialize the future DataFrame with the latest actual data
        last_known_data = self.data.iloc[-60:].copy()  # using 60 days to ensure SMA60 can be calculated
        future_dates = pd.date_range(start=last_known_data.index[-1], periods=N+1, closed='right')
        future_df = pd.DataFrame(index=future_dates, columns=self.data.columns)
        future_data = pd.concat([last_known_data, future_df])
        # print(future_data)

        # Iteratively predict each day and use that prediction for subsequent calculations
        for future_date in future_df.index:
            for sma_period in [5, 20, 60]:
                # Calculate SMA values, using available 'Close' values
                sma_values = future_data['Close'].rolling(sma_period, min_periods=1).mean()
                # print(sma_values)
                future_data.loc[future_date, f'SMA{sma_period}'] = sma_values.dropna()
                # print(sma_values.dropna(), sma_values.iloc[-1], 'nan')

            # Prepare the data for the model
            X_future = future_data.loc[future_date, ['SMA5', 'SMA20', 'SMA60']].values.reshape(1, -1)

            # Predict
            future_prediction = self.model.predict(X_future)[0]

            # Use the prediction as the 'Close' value for the next prediction
            future_data.loc[future_date, 'Close'] = future_prediction

        return future_data.loc[future_df.index, 'Close']

    def plot_data_with_future(self, full_data, test_data, predictions, future_predictions, mse, title="Data"):
        plt.figure(figsize=(12, 7))
        
        # Plotting the actual data and predictions
        plt.plot(full_data['Close'], label='Actual Data')
        plt.plot(test_data.index, predictions, color='red', label='Predictions')

        # Plotting future predictions
        future_dates = pd.date_range(start=test_data.index[-1], periods=len(future_predictions)+1, closed='right')
        plt.plot(future_dates, future_predictions, color='orange', label='Future Predictions')

        plt.title(f"{title}\nMean Squared Error: {mse:.2f}")
        plt.xlabel("Time")
        plt.ylabel("Value")
        plt.legend()
        plt.show()

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']

        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        N = 30  # number of days to predict into the future
        future_predictions = self.predict_future(N)

        # Calculate Mean Squared Error
        mse = mean_squared_error(y_test, predictions)

        # Plot the full data, predictions, and future predictions
        self.plot_data_with_future(self.data, self.test_data, predictions, future_predictions, mse)


        return predictions

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions= cp.predict()
    data = cp.data
124/136:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.1):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data
    
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')

        # ax1.plot(test_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # # Adding legends and title
        # ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()
        
    def predict_future(self, N):
        # Initialize the future DataFrame with the latest actual data
        last_known_data = self.data.iloc[-60:].copy()  # using 60 days to ensure SMA60 can be calculated
        future_dates = pd.date_range(start=last_known_data.index[-1], periods=N+1, closed='right')
        future_df = pd.DataFrame(index=future_dates, columns=self.data.columns)
        future_data = pd.concat([last_known_data, future_df])
        # print(future_data)

        # Iteratively predict each day and use that prediction for subsequent calculations
        for future_date in future_df.index:
            for sma_period in [5, 20, 60]:
                # Calculate SMA values, using available 'Close' values
                sma_values = future_data['Close'].rolling(sma_period, min_periods=1).mean()
                # print(sma_values)
                future_data.loc[future_date, f'SMA{sma_period}'] = sma_values.iloc[-1]
                print(sma_values.iloc[-1], 'nan')

            # Prepare the data for the model
            X_future = future_data.loc[future_date, ['SMA5', 'SMA20', 'SMA60']].values.reshape(1, -1)

            # Predict
            future_prediction = self.model.predict(X_future)[0]

            # Use the prediction as the 'Close' value for the next prediction
            future_data.loc[future_date, 'Close'] = future_prediction

        return future_data.loc[future_df.index, 'Close']

    def plot_data_with_future(self, full_data, test_data, predictions, future_predictions, mse, title="Data"):
        plt.figure(figsize=(12, 7))
        
        # Plotting the actual data and predictions
        plt.plot(full_data['Close'], label='Actual Data')
        plt.plot(test_data.index, predictions, color='red', label='Predictions')

        # Plotting future predictions
        future_dates = pd.date_range(start=test_data.index[-1], periods=len(future_predictions)+1, closed='right')
        plt.plot(future_dates, future_predictions, color='orange', label='Future Predictions')

        plt.title(f"{title}\nMean Squared Error: {mse:.2f}")
        plt.xlabel("Time")
        plt.ylabel("Value")
        plt.legend()
        plt.show()

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']

        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        N = 30  # number of days to predict into the future
        future_predictions = self.predict_future(N)

        # Calculate Mean Squared Error
        mse = mean_squared_error(y_test, predictions)

        # Plot the full data, predictions, and future predictions
        self.plot_data_with_future(self.data, self.test_data, predictions, future_predictions, mse)


        return predictions

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions= cp.predict()
    data = cp.data
124/137:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.1):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data
    
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')

        # ax1.plot(test_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # # Adding legends and title
        # ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()
        
    def predict_future(self, N):
        # Initialize the future DataFrame with the latest actual data
        last_known_data = self.data.iloc[-60:].copy()  # using 60 days to ensure SMA60 can be calculated
        future_dates = pd.date_range(start=last_known_data.index[-1], periods=N+1, closed='right')
        future_df = pd.DataFrame(index=future_dates, columns=self.data.columns)
        future_data = pd.concat([last_known_data, future_df])
        # print(future_data)

        # Iteratively predict each day and use that prediction for subsequent calculations
        for future_date in future_df.index:
            for sma_period in [5, 20, 60]:
                # Calculate SMA values, using available 'Close' values
                sma_values = future_data['Close'].rolling(sma_period, min_periods=1).mean()
                # print(sma_values)
                future_data.loc[future_date, f'SMA{sma_period}'] = sma_values.iloc[-1]
                print(sma_values.iloc[-1][-1], 'nan')

            # Prepare the data for the model
            X_future = future_data.loc[future_date, ['SMA5', 'SMA20', 'SMA60']].values.reshape(1, -1)

            # Predict
            future_prediction = self.model.predict(X_future)[0]

            # Use the prediction as the 'Close' value for the next prediction
            future_data.loc[future_date, 'Close'] = future_prediction

        return future_data.loc[future_df.index, 'Close']

    def plot_data_with_future(self, full_data, test_data, predictions, future_predictions, mse, title="Data"):
        plt.figure(figsize=(12, 7))
        
        # Plotting the actual data and predictions
        plt.plot(full_data['Close'], label='Actual Data')
        plt.plot(test_data.index, predictions, color='red', label='Predictions')

        # Plotting future predictions
        future_dates = pd.date_range(start=test_data.index[-1], periods=len(future_predictions)+1, closed='right')
        plt.plot(future_dates, future_predictions, color='orange', label='Future Predictions')

        plt.title(f"{title}\nMean Squared Error: {mse:.2f}")
        plt.xlabel("Time")
        plt.ylabel("Value")
        plt.legend()
        plt.show()

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']

        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        N = 30  # number of days to predict into the future
        future_predictions = self.predict_future(N)

        # Calculate Mean Squared Error
        mse = mean_squared_error(y_test, predictions)

        # Plot the full data, predictions, and future predictions
        self.plot_data_with_future(self.data, self.test_data, predictions, future_predictions, mse)


        return predictions

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions= cp.predict()
    data = cp.data
124/138:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.1):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data
    
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')

        # ax1.plot(test_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # # Adding legends and title
        # ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()
        
    def predict_future(self, N):
        # Initialize the future DataFrame with the latest actual data
        last_known_data = self.data.iloc[-60:].copy()  # using 60 days to ensure SMA60 can be calculated
        future_dates = pd.date_range(start=last_known_data.index[-1], periods=N+1, closed='right')
        future_df = pd.DataFrame(index=future_dates, columns=self.data.columns)
        future_data = pd.concat([last_known_data, future_df])
        # print(future_data)

        # Iteratively predict each day and use that prediction for subsequent calculations
        for future_date in future_df.index:
            for sma_period in [5, 20, 60]:
                # Calculate SMA values, using available 'Close' values
                sma_values = future_data['Close'].rolling(sma_period, min_periods=1).mean()
                # print(sma_values)
                future_data.loc[future_date, f'SMA{sma_period}'] = sma_values.iloc[-1]
                print(sma_values.iloc[-1], 'nan')

            # Prepare the data for the model
            X_future = future_data.loc[future_date, ['SMA5', 'SMA20', 'SMA60']].values.reshape(1, -1)

            # Predict
            future_prediction = self.model.predict(X_future)[0]

            # Use the prediction as the 'Close' value for the next prediction
            future_data.loc[future_date, 'Close'] = future_prediction

        return future_data.loc[future_df.index, 'Close']

    def plot_data_with_future(self, full_data, test_data, predictions, future_predictions, mse, title="Data"):
        plt.figure(figsize=(12, 7))
        
        # Plotting the actual data and predictions
        plt.plot(full_data['Close'], label='Actual Data')
        plt.plot(test_data.index, predictions, color='red', label='Predictions')

        # Plotting future predictions
        future_dates = pd.date_range(start=test_data.index[-1], periods=len(future_predictions)+1, closed='right')
        plt.plot(future_dates, future_predictions, color='orange', label='Future Predictions')

        plt.title(f"{title}\nMean Squared Error: {mse:.2f}")
        plt.xlabel("Time")
        plt.ylabel("Value")
        plt.legend()
        plt.show()

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']

        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        N = 30  # number of days to predict into the future
        future_predictions = self.predict_future(N)

        # Calculate Mean Squared Error
        mse = mean_squared_error(y_test, predictions)

        # Plot the full data, predictions, and future predictions
        self.plot_data_with_future(self.data, self.test_data, predictions, future_predictions, mse)


        return predictions

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions= cp.predict()
    data = cp.data
124/139:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.1):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data
    
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')

        # ax1.plot(test_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # # Adding legends and title
        # ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()
        
    def predict_future(self, N):
        # Initialize the future DataFrame with the latest actual data
        last_known_data = self.data.iloc[-60:].copy()  # using 60 days to ensure SMA60 can be calculated
        future_dates = pd.date_range(start=last_known_data.index[-1], periods=N+1, closed='right')
        future_df = pd.DataFrame(index=future_dates, columns=self.data.columns)
        future_data = pd.concat([last_known_data, future_df])
        # print(future_data)

        # Iteratively predict each day and use that prediction for subsequent calculations
        for future_date in future_df.index:
            for sma_period in [5, 20, 60]:
                # Calculate SMA values, using available 'Close' values
                sma_values = future_data['Close'].rolling(sma_period, min_periods=1).mean()
                # print(sma_values)
                future_data.loc[future_date, f'SMA{sma_period}'] = sma_values.iloc[-1]
                print(sma_values.iloc[-1], sma_period, 'nan')

            # Prepare the data for the model
            X_future = future_data.loc[future_date, ['SMA5', 'SMA20', 'SMA60']].values.reshape(1, -1)

            # Predict
            future_prediction = self.model.predict(X_future)[0]

            # Use the prediction as the 'Close' value for the next prediction
            future_data.loc[future_date, 'Close'] = future_prediction

        return future_data.loc[future_df.index, 'Close']

    def plot_data_with_future(self, full_data, test_data, predictions, future_predictions, mse, title="Data"):
        plt.figure(figsize=(12, 7))
        
        # Plotting the actual data and predictions
        plt.plot(full_data['Close'], label='Actual Data')
        plt.plot(test_data.index, predictions, color='red', label='Predictions')

        # Plotting future predictions
        future_dates = pd.date_range(start=test_data.index[-1], periods=len(future_predictions)+1, closed='right')
        plt.plot(future_dates, future_predictions, color='orange', label='Future Predictions')

        plt.title(f"{title}\nMean Squared Error: {mse:.2f}")
        plt.xlabel("Time")
        plt.ylabel("Value")
        plt.legend()
        plt.show()

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']

        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        N = 30  # number of days to predict into the future
        future_predictions = self.predict_future(N)

        # Calculate Mean Squared Error
        mse = mean_squared_error(y_test, predictions)

        # Plot the full data, predictions, and future predictions
        self.plot_data_with_future(self.data, self.test_data, predictions, future_predictions, mse)


        return predictions

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions= cp.predict()
    data = cp.data
124/140:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.1):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data
    
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')

        # ax1.plot(test_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # # Adding legends and title
        # ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()
        
    def predict_future(self, N):
        # Initialize the future DataFrame with the latest actual data
        last_known_data = self.data.iloc[-60:].copy()  # using 60 days to ensure SMA60 can be calculated
        future_dates = pd.date_range(start=last_known_data.index[-1], periods=N+1, closed='right')
        future_df = pd.DataFrame(index=future_dates, columns=self.data.columns)
        future_data = pd.concat([last_known_data, future_df])
        # print(future_data)

        # Iteratively predict each day and use that prediction for subsequent calculations
        for future_date in future_df.index:
            for sma_period in [5, 20, 60, 65]:
                # Calculate SMA values, using available 'Close' values
                sma_values = future_data['Close'].rolling(sma_period, min_periods=1).mean()
                # print(sma_values)
                future_data.loc[future_date, f'SMA{sma_period}'] = sma_values.iloc[-1]
                print(sma_values.iloc[-1], sma_period, 'nan')

            # Prepare the data for the model
            X_future = future_data.loc[future_date, ['SMA5', 'SMA20', 'SMA60']].values.reshape(1, -1)

            # Predict
            future_prediction = self.model.predict(X_future)[0]

            # Use the prediction as the 'Close' value for the next prediction
            future_data.loc[future_date, 'Close'] = future_prediction

        return future_data.loc[future_df.index, 'Close']

    def plot_data_with_future(self, full_data, test_data, predictions, future_predictions, mse, title="Data"):
        plt.figure(figsize=(12, 7))
        
        # Plotting the actual data and predictions
        plt.plot(full_data['Close'], label='Actual Data')
        plt.plot(test_data.index, predictions, color='red', label='Predictions')

        # Plotting future predictions
        future_dates = pd.date_range(start=test_data.index[-1], periods=len(future_predictions)+1, closed='right')
        plt.plot(future_dates, future_predictions, color='orange', label='Future Predictions')

        plt.title(f"{title}\nMean Squared Error: {mse:.2f}")
        plt.xlabel("Time")
        plt.ylabel("Value")
        plt.legend()
        plt.show()

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']

        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        N = 30  # number of days to predict into the future
        future_predictions = self.predict_future(N)

        # Calculate Mean Squared Error
        mse = mean_squared_error(y_test, predictions)

        # Plot the full data, predictions, and future predictions
        self.plot_data_with_future(self.data, self.test_data, predictions, future_predictions, mse)


        return predictions

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions= cp.predict()
    data = cp.data
124/141:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.1):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data
    
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')

        # ax1.plot(test_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # # Adding legends and title
        # ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()
        
    def predict_future(self, N):
        # Initialize the future DataFrame with the latest actual data
        last_known_data = self.data.iloc[-60:].copy()  # using 60 days to ensure SMA60 can be calculated
        future_dates = pd.date_range(start=last_known_data.index[-1], periods=N+1, closed='right')
        future_df = pd.DataFrame(index=future_dates, columns=self.data.columns)
        future_data = pd.concat([last_known_data, future_df])
        # print(future_data)

        # Iteratively predict each day and use that prediction for subsequent calculations
        for future_date in future_df.index:
            for sma_period in [5, 20, 60, 65, 120]:
                # Calculate SMA values, using available 'Close' values
                sma_values = future_data['Close'].rolling(sma_period, min_periods=1).mean()
                # print(sma_values)
                future_data.loc[future_date, f'SMA{sma_period}'] = sma_values.iloc[-1]
                print(sma_values.iloc[-1], sma_period, 'nan')

            # Prepare the data for the model
            X_future = future_data.loc[future_date, ['SMA5', 'SMA20', 'SMA60']].values.reshape(1, -1)

            # Predict
            future_prediction = self.model.predict(X_future)[0]

            # Use the prediction as the 'Close' value for the next prediction
            future_data.loc[future_date, 'Close'] = future_prediction

        return future_data.loc[future_df.index, 'Close']

    def plot_data_with_future(self, full_data, test_data, predictions, future_predictions, mse, title="Data"):
        plt.figure(figsize=(12, 7))
        
        # Plotting the actual data and predictions
        plt.plot(full_data['Close'], label='Actual Data')
        plt.plot(test_data.index, predictions, color='red', label='Predictions')

        # Plotting future predictions
        future_dates = pd.date_range(start=test_data.index[-1], periods=len(future_predictions)+1, closed='right')
        plt.plot(future_dates, future_predictions, color='orange', label='Future Predictions')

        plt.title(f"{title}\nMean Squared Error: {mse:.2f}")
        plt.xlabel("Time")
        plt.ylabel("Value")
        plt.legend()
        plt.show()

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']

        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        N = 30  # number of days to predict into the future
        future_predictions = self.predict_future(N)

        # Calculate Mean Squared Error
        mse = mean_squared_error(y_test, predictions)

        # Plot the full data, predictions, and future predictions
        self.plot_data_with_future(self.data, self.test_data, predictions, future_predictions, mse)


        return predictions

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions= cp.predict()
    data = cp.data
124/142:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.1):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data
    
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')

        # ax1.plot(test_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # # Adding legends and title
        # ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()
        
    def predict_future(self, N):
        # Initialize the future DataFrame with the latest actual data
        last_known_data = self.data.iloc[-60:].copy()  # using 60 days to ensure SMA60 can be calculated
        future_dates = pd.date_range(start=last_known_data.index[-1], periods=N+1, closed='right')
        future_df = pd.DataFrame(index=future_dates, columns=self.data.columns)
        future_data = pd.concat([last_known_data, future_df])
        # print(future_data)

        # Iteratively predict each day and use that prediction for subsequent calculations
        for future_date in future_df.index:
            for sma_period in [5, 20, 60, 65, 99999]:
                # Calculate SMA values, using available 'Close' values
                sma_values = future_data['Close'].rolling(sma_period, min_periods=1).mean()
                # print(sma_values)
                future_data.loc[future_date, f'SMA{sma_period}'] = sma_values.iloc[-1]
                print(sma_values.iloc[-1], sma_period, 'nan')

            # Prepare the data for the model
            X_future = future_data.loc[future_date, ['SMA5', 'SMA20', 'SMA60']].values.reshape(1, -1)

            # Predict
            future_prediction = self.model.predict(X_future)[0]

            # Use the prediction as the 'Close' value for the next prediction
            future_data.loc[future_date, 'Close'] = future_prediction

        return future_data.loc[future_df.index, 'Close']

    def plot_data_with_future(self, full_data, test_data, predictions, future_predictions, mse, title="Data"):
        plt.figure(figsize=(12, 7))
        
        # Plotting the actual data and predictions
        plt.plot(full_data['Close'], label='Actual Data')
        plt.plot(test_data.index, predictions, color='red', label='Predictions')

        # Plotting future predictions
        future_dates = pd.date_range(start=test_data.index[-1], periods=len(future_predictions)+1, closed='right')
        plt.plot(future_dates, future_predictions, color='orange', label='Future Predictions')

        plt.title(f"{title}\nMean Squared Error: {mse:.2f}")
        plt.xlabel("Time")
        plt.ylabel("Value")
        plt.legend()
        plt.show()

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']

        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        N = 30  # number of days to predict into the future
        future_predictions = self.predict_future(N)

        # Calculate Mean Squared Error
        mse = mean_squared_error(y_test, predictions)

        # Plot the full data, predictions, and future predictions
        self.plot_data_with_future(self.data, self.test_data, predictions, future_predictions, mse)


        return predictions

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions= cp.predict()
    data = cp.data
124/143:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.1):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data
    
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')

        # ax1.plot(test_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # # Adding legends and title
        # ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()
        
    def predict_future(self, N):
        # Ensure there's enough historical data for SMA calculations
        historical_data_length = max(60, N)  # At least as long as the longest SMA period
        last_known_data = self.data.iloc[-historical_data_length:].copy()

        # Prepare DataFrame for future predictions
        future_dates = pd.date_range(start=last_known_data.index[-1], periods=N+1, closed='right')
        future_df = pd.DataFrame(index=future_dates, columns=self.data.columns)
        future_data = pd.concat([last_known_data, future_df])

        # Iteratively predict each future day
        for future_date in future_df.index:
            # Update SMAs with available 'Close' data
            for sma_period in [5, 20, 60]:
                sma_values = future_data['Close'].rolling(sma_period, min_periods=1).mean()
                future_data.loc[future_date, f'SMA{sma_period}'] = sma_values.iloc[-1]

            # Ensure there are no NaN values in the input features
            if future_data.loc[future_date, ['SMA5', 'SMA20', 'SMA60']].isna().any():
                continue

            # Prepare the data for the model
            X_future = future_data.loc[future_date, ['SMA5', 'SMA20', 'SMA60']].values.reshape(1, -1)

            # Predict and update 'Close' value
            future_prediction = self.model.predict(X_future)[0]
            future_data.loc[future_date, 'Close'] = future_prediction

        return future_data.loc[future_df.index, 'Close']

    def plot_data_with_future(self, full_data, test_data, predictions, future_predictions, mse, title="Data"):
        plt.figure(figsize=(12, 7))
        
        # Plotting the actual data and predictions
        plt.plot(full_data['Close'], label='Actual Data')
        plt.plot(test_data.index, predictions, color='red', label='Predictions')

        # Plotting future predictions
        future_dates = pd.date_range(start=test_data.index[-1], periods=len(future_predictions)+1, closed='right')
        plt.plot(future_dates, future_predictions, color='orange', label='Future Predictions')

        plt.title(f"{title}\nMean Squared Error: {mse:.2f}")
        plt.xlabel("Time")
        plt.ylabel("Value")
        plt.legend()
        plt.show()

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']

        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        N = 30  # number of days to predict into the future
        future_predictions = self.predict_future(N)

        # Calculate Mean Squared Error
        mse = mean_squared_error(y_test, predictions)

        # Plot the full data, predictions, and future predictions
        self.plot_data_with_future(self.data, self.test_data, predictions, future_predictions, mse)


        return predictions

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions= cp.predict()
    data = cp.data
124/144:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.1):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data
    
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')

        # ax1.plot(test_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # # Adding legends and title
        # ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()
        
    def predict_future(self, N):
        # Ensure there's enough historical data for SMA calculations
        historical_data_length = max(60, N)  # At least as long as the longest SMA period
        last_known_data = self.data.iloc[-historical_data_length:].copy()

        # Prepare DataFrame for future predictions
        future_dates = pd.date_range(start=last_known_data.index[-1], periods=N+1, closed='right')
        future_df = pd.DataFrame(index=future_dates, columns=self.data.columns)
        future_data = pd.concat([last_known_data, future_df])

        # Iteratively predict each future day
        for future_date in future_df.index:
            # Update SMAs with available 'Close' data
            for sma_period in [5, 20, 60]:
                sma_values = future_data['Close'].rolling(sma_period, min_periods=1).mean()
                future_data.loc[future_date, f'SMA{sma_period}'] = sma_values.iloc[-1]

            # Ensure there are no NaN values in the input features
            if future_data.loc[future_date, ['SMA5', 'SMA20', 'SMA60']].isna().any():
                continue

            # Prepare the data for the model
            X_future = future_data.loc[future_date, ['SMA5', 'SMA20', 'SMA60']].values.reshape(1, -1)

            # Predict and update 'Close' value
            future_prediction = self.model.predict(X_future)[0]
            future_data.loc[future_date, 'Close'] = future_prediction

        return future_data.loc[future_df.index, 'Close']

    def plot_data_with_future(self, full_data, test_data, predictions, future_predictions, mse, title="Data"):
        plt.figure(figsize=(12, 7))
        
        # Plotting the actual data and predictions
        plt.plot(full_data['Close'], label='Actual Data')
        plt.plot(test_data.index, predictions, color='red', label='Predictions')

        # Plotting future predictions
        future_dates = pd.date_range(start=test_data.index[-1], periods=len(future_predictions)+1, closed='right')
        plt.plot(future_dates, future_predictions, color='orange', label='Future Predictions')

        plt.title(f"{title}\nMean Squared Error: {mse:.2f}")
        plt.xlabel("Time")
        plt.ylabel("Value")
        plt.legend()
        plt.show()

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']

        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        N = 365  # number of days to predict into the future
        future_predictions = self.predict_future(N)

        # Calculate Mean Squared Error
        mse = mean_squared_error(y_test, predictions)

        # Plot the full data, predictions, and future predictions
        self.plot_data_with_future(self.data, self.test_data, predictions, future_predictions, mse)


        return predictions

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions= cp.predict()
    data = cp.data
124/145:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.1):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data
    
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')

        # ax1.plot(test_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # # Adding legends and title
        # ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()
        
    def predict_future(self, N):
        # Ensure there's enough historical data for SMA calculations
        historical_data_length = max(60, N)  # At least as long as the longest SMA period
        last_known_data = self.data.iloc[-historical_data_length:].copy()

        # Prepare DataFrame for future predictions
        future_dates = pd.date_range(start=last_known_data.index[-1], periods=N+1, closed='right')
        future_df = pd.DataFrame(index=future_dates, columns=self.data.columns)
        future_data = pd.concat([last_known_data, future_df])

        # Iteratively predict each future day
        for future_date in future_df.index:
            # Update SMAs with available 'Close' data
            for sma_period in [5, 20, 60]:
                sma_values = future_data['Close'].rolling(sma_period, min_periods=1).mean()
                future_data.loc[future_date, f'SMA{sma_period}'] = sma_values.iloc[-1]

            # # Ensure there are no NaN values in the input features
            # if future_data.loc[future_date, ['SMA5', 'SMA20', 'SMA60']].isna().any():
            #     continue

            # Prepare the data for the model
            X_future = future_data.loc[future_date, ['SMA5', 'SMA20', 'SMA60']].values.reshape(1, -1)

            # Predict and update 'Close' value
            future_prediction = self.model.predict(X_future)[0]
            future_data.loc[future_date, 'Close'] = future_prediction

        return future_data.loc[future_df.index, 'Close']

    def plot_data_with_future(self, full_data, test_data, predictions, future_predictions, mse, title="Data"):
        plt.figure(figsize=(12, 7))
        
        # Plotting the actual data and predictions
        plt.plot(full_data['Close'], label='Actual Data')
        plt.plot(test_data.index, predictions, color='red', label='Predictions')

        # Plotting future predictions
        future_dates = pd.date_range(start=test_data.index[-1], periods=len(future_predictions)+1, closed='right')
        plt.plot(future_dates, future_predictions, color='orange', label='Future Predictions')

        plt.title(f"{title}\nMean Squared Error: {mse:.2f}")
        plt.xlabel("Time")
        plt.ylabel("Value")
        plt.legend()
        plt.show()

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']

        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        N = 365  # number of days to predict into the future
        future_predictions = self.predict_future(N)

        # Calculate Mean Squared Error
        mse = mean_squared_error(y_test, predictions)

        # Plot the full data, predictions, and future predictions
        self.plot_data_with_future(self.data, self.test_data, predictions, future_predictions, mse)


        return predictions

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions= cp.predict()
    data = cp.data
124/146:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.1):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data
    
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')

        # ax1.plot(test_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # # Adding legends and title
        # ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()
        
    def predict_future(self, N):
        # Ensure there's enough historical data for SMA calculations
        historical_data_length = max(60, N)  # At least as long as the longest SMA period
        last_known_data = self.data.iloc[-historical_data_length:].copy()

        # Prepare DataFrame for future predictions
        future_dates = pd.date_range(start=last_known_data.index[-1], periods=N+1, closed='right')
        future_df = pd.DataFrame(index=future_dates, columns=self.data.columns)
        future_data = pd.concat([last_known_data, future_df])

        # Iteratively predict each future day
        for future_date in future_df.index:
            # Update SMAs with available 'Close' data
            for sma_period in [5, 20, 60]:
                sma_values = future_data['Close'].rolling(sma_period, min_periods=1).mean()
                future_data.loc[future_date, f'SMA{sma_period}'] = sma_values.iloc[-1]
                print(sma_values.iloc[-1])

            # # Ensure there are no NaN values in the input features
            # if future_data.loc[future_date, ['SMA5', 'SMA20', 'SMA60']].isna().any():
            #     continue

            # Prepare the data for the model
            X_future = future_data.loc[future_date, ['SMA5', 'SMA20', 'SMA60']].values.reshape(1, -1)

            # Predict and update 'Close' value
            future_prediction = self.model.predict(X_future)[0]
            future_data.loc[future_date, 'Close'] = future_prediction

        return future_data.loc[future_df.index, 'Close']

    def plot_data_with_future(self, full_data, test_data, predictions, future_predictions, mse, title="Data"):
        plt.figure(figsize=(12, 7))
        
        # Plotting the actual data and predictions
        plt.plot(full_data['Close'], label='Actual Data')
        plt.plot(test_data.index, predictions, color='red', label='Predictions')

        # Plotting future predictions
        future_dates = pd.date_range(start=test_data.index[-1], periods=len(future_predictions)+1, closed='right')
        plt.plot(future_dates, future_predictions, color='orange', label='Future Predictions')

        plt.title(f"{title}\nMean Squared Error: {mse:.2f}")
        plt.xlabel("Time")
        plt.ylabel("Value")
        plt.legend()
        plt.show()

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']

        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        N = 365  # number of days to predict into the future
        future_predictions = self.predict_future(N)

        # Calculate Mean Squared Error
        mse = mean_squared_error(y_test, predictions)

        # Plot the full data, predictions, and future predictions
        self.plot_data_with_future(self.data, self.test_data, predictions, future_predictions, mse)


        return predictions

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions= cp.predict()
    data = cp.data
124/147:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.1):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data
    
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')

        # ax1.plot(test_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # # Adding legends and title
        # ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()
        
    def predict_future(self, N):
        # Ensure there's enough historical data for SMA calculations
        historical_data_length = max(60, N)  # At least as long as the longest SMA period
        last_known_data = self.data.iloc[:-historical_data_length].copy()

        # Prepare DataFrame for future predictions
        future_dates = pd.date_range(start=last_known_data.index[-1], periods=N+1, closed='right')
        future_df = pd.DataFrame(index=future_dates, columns=self.data.columns)
        future_data = pd.concat([last_known_data, future_df])

        # Iteratively predict each future day
        for future_date in future_df.index:
            # Update SMAs with available 'Close' data
            for sma_period in [5, 20, 60]:
                sma_values = future_data['Close'].rolling(sma_period, min_periods=1).mean()
                future_data.loc[future_date, f'SMA{sma_period}'] = sma_values.iloc[-1]
                print(sma_values.iloc[-1])

            # # Ensure there are no NaN values in the input features
            # if future_data.loc[future_date, ['SMA5', 'SMA20', 'SMA60']].isna().any():
            #     continue

            # Prepare the data for the model
            X_future = future_data.loc[future_date, ['SMA5', 'SMA20', 'SMA60']].values.reshape(1, -1)

            # Predict and update 'Close' value
            future_prediction = self.model.predict(X_future)[0]
            future_data.loc[future_date, 'Close'] = future_prediction

        return future_data.loc[future_df.index, 'Close']

    def plot_data_with_future(self, full_data, test_data, predictions, future_predictions, mse, title="Data"):
        plt.figure(figsize=(12, 7))
        
        # Plotting the actual data and predictions
        plt.plot(full_data['Close'], label='Actual Data')
        plt.plot(test_data.index, predictions, color='red', label='Predictions')

        # Plotting future predictions
        future_dates = pd.date_range(start=test_data.index[-1], periods=len(future_predictions)+1, closed='right')
        plt.plot(future_dates, future_predictions, color='orange', label='Future Predictions')

        plt.title(f"{title}\nMean Squared Error: {mse:.2f}")
        plt.xlabel("Time")
        plt.ylabel("Value")
        plt.legend()
        plt.show()

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']

        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        N = 365  # number of days to predict into the future
        future_predictions = self.predict_future(N)

        # Calculate Mean Squared Error
        mse = mean_squared_error(y_test, predictions)

        # Plot the full data, predictions, and future predictions
        self.plot_data_with_future(self.data, self.test_data, predictions, future_predictions, mse)


        return predictions

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions= cp.predict()
    data = cp.data
124/148:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.1):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data
    
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')

        # ax1.plot(test_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # # Adding legends and title
        # ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()
        
    def predict_future(self, N):
        # Ensure there's enough historical data for SMA calculations
        historical_data_length = max(60, N)  # At least as long as the longest SMA period
        last_known_data = self.data.iloc[:-historical_data_length].copy()

        # Prepare DataFrame for future predictions
        future_dates = pd.date_range(start=last_known_data.index[-1], periods=N+1, closed='right')
        future_df = pd.DataFrame(index=future_dates, columns=self.data.columns)
        future_data = pd.concat([last_known_data, future_df])

        # Iteratively predict each future day
        for future_date in future_df.index:
            # Update SMAs with available 'Close' data
            for sma_period in [5, 20, 60]:
                sma_values = future_data['Close'].rolling(sma_period, min_periods=1).mean()
                print(sma_values)
                future_data.loc[future_date, f'SMA{sma_period}'] = sma_values.iloc[-1]
                print(sma_values.iloc[-1])

            # # Ensure there are no NaN values in the input features
            # if future_data.loc[future_date, ['SMA5', 'SMA20', 'SMA60']].isna().any():
            #     continue

            # Prepare the data for the model
            X_future = future_data.loc[future_date, ['SMA5', 'SMA20', 'SMA60']].values.reshape(1, -1)

            # Predict and update 'Close' value
            future_prediction = self.model.predict(X_future)[0]
            future_data.loc[future_date, 'Close'] = future_prediction

        return future_data.loc[future_df.index, 'Close']

    def plot_data_with_future(self, full_data, test_data, predictions, future_predictions, mse, title="Data"):
        plt.figure(figsize=(12, 7))
        
        # Plotting the actual data and predictions
        plt.plot(full_data['Close'], label='Actual Data')
        plt.plot(test_data.index, predictions, color='red', label='Predictions')

        # Plotting future predictions
        future_dates = pd.date_range(start=test_data.index[-1], periods=len(future_predictions)+1, closed='right')
        plt.plot(future_dates, future_predictions, color='orange', label='Future Predictions')

        plt.title(f"{title}\nMean Squared Error: {mse:.2f}")
        plt.xlabel("Time")
        plt.ylabel("Value")
        plt.legend()
        plt.show()

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']

        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        N = 365  # number of days to predict into the future
        future_predictions = self.predict_future(N)

        # Calculate Mean Squared Error
        mse = mean_squared_error(y_test, predictions)

        # Plot the full data, predictions, and future predictions
        self.plot_data_with_future(self.data, self.test_data, predictions, future_predictions, mse)


        return predictions

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions= cp.predict()
    data = cp.data
124/149:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.1):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data
    
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')

        # ax1.plot(test_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # # Adding legends and title
        # ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()
        
    def predict_future(self, N):
        # Ensure there's enough historical data for SMA calculations
        historical_data_length = max(60, N)  # At least as long as the longest SMA period
        last_known_data = self.data.iloc[:-historical_data_length].copy()

        # Prepare DataFrame for future predictions
        future_dates = pd.date_range(start=last_known_data.index[-1], periods=N+1, closed='right')
        future_df = pd.DataFrame(index=future_dates, columns=self.data.columns)
        future_data = pd.concat([last_known_data, future_df])

        # Iteratively predict each future day
        for future_date in future_df.index:
            # Update SMAs with available 'Close' data
            for sma_period in [5, 20, 60]:
                sma_values = future_data['Close'].rolling(sma_period, min_periods=1).mean()
                print(sma_values)
                future_data.loc[future_date, f'SMA{sma_period}'] = sma_values.iloc[-1]
                print(sma_values.iloc[-1])

            # Ensure there are no NaN values in the input features
            if future_data.loc[future_date, ['SMA5', 'SMA20', 'SMA60']].isna().any():
                continue

            # Prepare the data for the model
            X_future = future_data.loc[future_date, ['SMA5', 'SMA20', 'SMA60']].values.reshape(1, -1)

            # Predict and update 'Close' value
            future_prediction = self.model.predict(X_future)[0]
            future_data.loc[future_date, 'Close'] = future_prediction

        return future_data.loc[future_df.index, 'Close']

    def plot_data_with_future(self, full_data, test_data, predictions, future_predictions, mse, title="Data"):
        plt.figure(figsize=(12, 7))
        
        # Plotting the actual data and predictions
        plt.plot(full_data['Close'], label='Actual Data')
        plt.plot(test_data.index, predictions, color='red', label='Predictions')

        # Plotting future predictions
        future_dates = pd.date_range(start=test_data.index[-1], periods=len(future_predictions)+1, closed='right')
        plt.plot(future_dates, future_predictions, color='orange', label='Future Predictions')

        plt.title(f"{title}\nMean Squared Error: {mse:.2f}")
        plt.xlabel("Time")
        plt.ylabel("Value")
        plt.legend()
        plt.show()

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']

        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        N = 365  # number of days to predict into the future
        future_predictions = self.predict_future(N)

        # Calculate Mean Squared Error
        mse = mean_squared_error(y_test, predictions)

        # Plot the full data, predictions, and future predictions
        self.plot_data_with_future(self.data, self.test_data, predictions, future_predictions, mse)


        return predictions

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions= cp.predict()
    data = cp.data
124/150:
s = data.filter(['Close'])
t = pd.concat([s, pd.DataFrame(predictions, columns=['Close'])])
t = t.reset_index()
#plt.plot(t)
#plt.plot(data)
plt.show()
124/151: t
124/152:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.1):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data
    
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')

        # ax1.plot(test_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # # Adding legends and title
        # ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()
        
    def predict_future(self, N):
        # Ensure there's enough historical data for SMA calculations
        historical_data_length = max(60, N)  # At least as long as the longest SMA period
        last_known_data = self.data.iloc[:-historical_data_length].copy()

        # Prepare DataFrame for future predictions
        future_dates = pd.date_range(start=last_known_data.index[-1], periods=N+1, closed='right')
        future_df = pd.DataFrame(index=future_dates, columns=self.data.columns)
        future_data = pd.concat([last_known_data, future_df])

        # Iteratively predict each future day
        for future_date in future_df.index:
            # Update SMAs with available 'Close' data
            for sma_period in [5, 20, 60]:
                sma_values = future_data['Close'].rolling(sma_period, min_periods=1).mean()
                # print(sma_values)
                future_data.loc[future_date, f'SMA{sma_period}'] = sma_values.iloc[-1]
                # print(sma_values.iloc[-1])

            # Ensure there are no NaN values in the input features
            if future_data.loc[future_date, ['SMA5', 'SMA20', 'SMA60']].isna().any():
                continue

            # Prepare the data for the model
            X_future = future_data.loc[future_date, ['SMA5', 'SMA20', 'SMA60']].values.reshape(1, -1)

            # Predict and update 'Close' value
            future_prediction = self.model.predict(X_future)[0]
            future_data.loc[future_date, 'Close'] = future_prediction

        return future_data.loc[future_df.index, 'Close']

    def plot_data_with_future(self, full_data, test_data, predictions, future_predictions, mse, title="Data"):
        plt.figure(figsize=(12, 7))
        
        # Plotting the actual data and predictions
        plt.plot(full_data['Close'], label='Actual Data')
        plt.plot(test_data.index, predictions, color='red', label='Predictions')

        # Plotting future predictions
        future_dates = pd.date_range(start=test_data.index[-1], periods=len(future_predictions)+1, closed='right')
        plt.plot(future_dates, future_predictions, color='orange', label='Future Predictions')

        plt.title(f"{title}\nMean Squared Error: {mse:.2f}")
        plt.xlabel("Time")
        plt.ylabel("Value")
        plt.legend()
        plt.show()

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']

        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        N = 365  # number of days to predict into the future
        future_predictions = self.predict_future(N)

        # Calculate Mean Squared Error
        mse = mean_squared_error(y_test, predictions)

        # Plot the full data, predictions, and future predictions
        self.plot_data_with_future(self.data, self.test_data, predictions, future_predictions, mse)


        return predictions

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions= cp.predict()
    data = cp.data
124/153:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data
    
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')

        # ax1.plot(test_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # # Adding legends and title
        # ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()
        
    def predict_future(self, N):
        # Ensure there's enough historical data for SMA calculations
        historical_data_length = max(60, N)  # At least as long as the longest SMA period
        last_known_data = self.data.iloc[:-historical_data_length].copy()

        # Prepare DataFrame for future predictions
        future_dates = pd.date_range(start=last_known_data.index[-1], periods=N+1, closed='right')
        future_df = pd.DataFrame(index=future_dates, columns=self.data.columns)
        future_data = pd.concat([last_known_data, future_df])

        # Iteratively predict each future day
        for future_date in future_df.index:
            # Update SMAs with available 'Close' data
            for sma_period in [5, 20, 60]:
                sma_values = future_data['Close'].rolling(sma_period, min_periods=1).mean()
                # print(sma_values)
                future_data.loc[future_date, f'SMA{sma_period}'] = sma_values.iloc[-1]
                # print(sma_values.iloc[-1])

            # Ensure there are no NaN values in the input features
            if future_data.loc[future_date, ['SMA5', 'SMA20', 'SMA60']].isna().any():
                continue

            # Prepare the data for the model
            X_future = future_data.loc[future_date, ['SMA5', 'SMA20', 'SMA60']].values.reshape(1, -1)

            # Predict and update 'Close' value
            future_prediction = self.model.predict(X_future)[0]
            future_data.loc[future_date, 'Close'] = future_prediction

        return future_data.loc[future_df.index, 'Close']

    def plot_data_with_future(self, full_data, test_data, predictions, future_predictions, mse, title="Data"):
        plt.figure(figsize=(12, 7))
        
        # Plotting the actual data and predictions
        plt.plot(full_data['Close'], label='Actual Data')
        plt.plot(test_data.index, predictions, color='red', label='Predictions')

        # Plotting future predictions
        future_dates = pd.date_range(start=test_data.index[-1], periods=len(future_predictions)+1, closed='right')
        plt.plot(future_dates, future_predictions, color='orange', label='Future Predictions')

        plt.title(f"{title}\nMean Squared Error: {mse:.2f}")
        plt.xlabel("Time")
        plt.ylabel("Value")
        plt.legend()
        plt.show()

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']

        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        N = 365  # number of days to predict into the future
        future_predictions = self.predict_future(N)

        # Calculate Mean Squared Error
        mse = mean_squared_error(y_test, predictions)

        # Plot the full data, predictions, and future predictions
        self.plot_data_with_future(self.data, self.test_data, predictions, future_predictions, mse)


        return predictions

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions= cp.predict()
    data = cp.data
124/154:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data
    
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')

        # ax1.plot(test_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # # Adding legends and title
        # ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()
        
    def predict_future(self, N):
        # Ensure there's enough historical data for SMA calculations
        historical_data_length = max(60, N)  # At least as long as the longest SMA period
        last_known_data = self.data.iloc[:-historical_data_length].copy()

        # Prepare DataFrame for future predictions
        future_dates = pd.date_range(start=last_known_data.index[-1], periods=N+1, closed='right')
        future_df = pd.DataFrame(index=future_dates, columns=self.data.columns)
        future_data = pd.concat([last_known_data, future_df])

        # Iteratively predict each future day
        for future_date in future_df.index:
            # Update SMAs with available 'Close' data
            for sma_period in [5, 20, 60]:
                sma_values = future_data['Close'].rolling(sma_period, min_periods=1).mean()
                # print(sma_values)
                future_data.loc[future_date, f'SMA{sma_period}'] = sma_values.iloc[-1]
                # print(sma_values.iloc[-1])

            # Ensure there are no NaN values in the input features
            if future_data.loc[future_date, ['SMA5', 'SMA20', 'SMA60']].isna().any():
                continue

            # Prepare the data for the model
            X_future = future_data.loc[future_date, ['SMA5', 'SMA20', 'SMA60']].values.reshape(1, -1)

            # Predict and update 'Close' value
            future_prediction = self.model.predict(X_future)[0]
            future_data.loc[future_date, 'Close'] = future_prediction

        return future_data.loc[future_df.index, 'Close']

    def plot_data_with_future(self, full_data, test_data, predictions, future_predictions, mse, title="Data"):
        plt.figure(figsize=(12, 7))
        
        # Plotting the actual data and predictions
        plt.plot(full_data['Close'], label='Actual Data')
        plt.plot(test_data.index, predictions, color='red', label='Predictions')

        # Plotting future predictions
        future_dates = pd.date_range(start=test_data.index[-1], periods=len(future_predictions)+1, closed='right')
        plt.plot(future_dates, future_predictions, color='orange', label='Future Predictions')

        plt.title(f"{title}\nMean Squared Error: {mse:.2f}")
        plt.xlabel("Time")
        plt.ylabel("Value")
        plt.legend()
        plt.show()

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']

        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        N = 365  # number of days to predict into the future
        future_predictions = self.predict_future(N)

        # Calculate Mean Squared Error
        mse = mean_squared_error(y_test, predictions)

        # Plot the full data, predictions, and future predictions
        self.plot_data_with_future(self.data, self.test_data, predictions, future_predictions, mse)


        return predictions

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions= cp.predict()
    data = cp.data
124/155:
s = data.filter(['Close'])
t = pd.concat([s, pd.DataFrame(predictions, columns=['Close'])])
t = t.reset_index()
#plt.plot(t)
#plt.plot(data)
plt.show()
124/156:
s = data.filter(['Close'])
t = pd.concat([s, pd.DataFrame(predictions, columns=['Close'])])
t = t.reset_index()
#plt.plot(t)
#plt.plot(data)
plt.show()
124/157:
s = data.filter(['Close'])
t = pd.concat([s, pd.DataFrame(predictions, columns=['Close'])])
t = t.reset_index()
plt.plot(t)
#plt.plot(data)
plt.show()
124/158:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data
    
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(test_data.index,full_data['Close'], label='Actual Data', color='blue')

        # ax1.plot(test_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # # Adding legends and title
        # ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()
        
    def predict_future(self, N):
        # Ensure there's enough historical data for SMA calculations
        historical_data_length = max(60, N)  # At least as long as the longest SMA period
        last_known_data = self.data.iloc[:-historical_data_length].copy()

        # Prepare DataFrame for future predictions
        future_dates = pd.date_range(start=last_known_data.index[-1], periods=N+1, closed='right')
        future_df = pd.DataFrame(index=future_dates, columns=self.data.columns)
        future_data = pd.concat([last_known_data, future_df])

        # Iteratively predict each future day
        for future_date in future_df.index:
            # Update SMAs with available 'Close' data
            for sma_period in [5, 20, 60]:
                sma_values = future_data['Close'].rolling(sma_period, min_periods=1).mean()
                # print(sma_values)
                future_data.loc[future_date, f'SMA{sma_period}'] = sma_values.iloc[-1]
                # print(sma_values.iloc[-1])

            # Ensure there are no NaN values in the input features
            if future_data.loc[future_date, ['SMA5', 'SMA20', 'SMA60']].isna().any():
                continue

            # Prepare the data for the model
            X_future = future_data.loc[future_date, ['SMA5', 'SMA20', 'SMA60']].values.reshape(1, -1)

            # Predict and update 'Close' value
            future_prediction = self.model.predict(X_future)[0]
            future_data.loc[future_date, 'Close'] = future_prediction

        return future_data.loc[future_df.index, 'Close']

    def plot_data_with_future(self, full_data, test_data, predictions, future_predictions, mse, title="Data"):
        plt.figure(figsize=(12, 7))
        
        # Plotting the actual data and predictions
        plt.plot(full_data['Close'], label='Actual Data')
        plt.plot(test_data.index, predictions, color='red', label='Predictions')

        # Plotting future predictions
        future_dates = pd.date_range(start=test_data.index[-1], periods=len(future_predictions)+1, closed='right')
        plt.plot(future_dates, future_predictions, color='orange', label='Future Predictions')

        plt.title(f"{title}\nMean Squared Error: {mse:.2f}")
        plt.xlabel("Time")
        plt.ylabel("Value")
        plt.legend()
        plt.show()

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']

        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        N = 365  # number of days to predict into the future
        future_predictions = self.predict_future(N)

        # Calculate Mean Squared Error
        mse = mean_squared_error(y_test, predictions)

        # Plot the full data, predictions, and future predictions
        self.plot_data_with_future(self.data, self.test_data, predictions, future_predictions, mse)


        return predictions

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions= cp.predict()
    data = cp.data
124/159:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data
    
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')

        # ax1.plot(test_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # # Adding legends and title
        # ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()
        
    def predict_future(self, N):
        # Ensure there's enough historical data for SMA calculations
        historical_data_length = max(60, N)  # At least as long as the longest SMA period
        last_known_data = self.data.iloc[:-historical_data_length].copy()

        # Prepare DataFrame for future predictions
        future_dates = pd.date_range(start=last_known_data.index[-1], periods=N+1, closed='right')
        future_df = pd.DataFrame(index=future_dates, columns=self.data.columns)
        future_data = pd.concat([last_known_data, future_df])

        # Iteratively predict each future day
        for future_date in future_df.index:
            # Update SMAs with available 'Close' data
            for sma_period in [5, 20, 60]:
                sma_values = future_data['Close'].rolling(sma_period, min_periods=1).mean()
                # print(sma_values)
                future_data.loc[future_date, f'SMA{sma_period}'] = sma_values.iloc[-1]
                # print(sma_values.iloc[-1])

            # Ensure there are no NaN values in the input features
            if future_data.loc[future_date, ['SMA5', 'SMA20', 'SMA60']].isna().any():
                continue

            # Prepare the data for the model
            X_future = future_data.loc[future_date, ['SMA5', 'SMA20', 'SMA60']].values.reshape(1, -1)

            # Predict and update 'Close' value
            future_prediction = self.model.predict(X_future)[0]
            future_data.loc[future_date, 'Close'] = future_prediction

        return future_data.loc[future_df.index, 'Close']

    def plot_data_with_future(self, full_data, test_data, predictions, future_predictions, mse, title="Data"):
        plt.figure(figsize=(12, 7))
        
        # Plotting the actual data and predictions
        plt.plot(full_data['Close'], label='Actual Data')
        plt.plot(test_data.index, predictions, color='red', label='Predictions')

        # Plotting future predictions
        future_dates = pd.date_range(start=test_data.index[-1], periods=len(future_predictions)+1, closed='right')
        plt.plot(future_dates, future_predictions, color='orange', label='Future Predictions')

        plt.title(f"{title}\nMean Squared Error: {mse:.2f}")
        plt.xlabel("Time")
        plt.ylabel("Value")
        plt.legend()
        plt.show()

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']

        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        N = 365  # number of days to predict into the future
        future_predictions = self.predict_future(N)

        # Calculate Mean Squared Error
        mse = mean_squared_error(y_test, predictions)

        # Plot the full data, predictions, and future predictions
        self.plot_data_with_future(self.data, self.test_data, predictions, future_predictions, mse)


        return predictions

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions= cp.predict()
    data = cp.data
124/160:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data
    
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')

        # ax1.plot(test_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # # Adding legends and title
        # ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()
        
    def predict_future(self, N):
        # Ensure there's enough historical data for SMA calculations
        historical_data_length = max(60, N)  # At least as long as the longest SMA period
        last_known_data = self.data.iloc[:-historical_data_length].copy()

        # Prepare DataFrame for future predictions
        future_dates = pd.date_range(start=last_known_data.index[-1], periods=N+1, closed='right')
        future_df = pd.DataFrame(index=future_dates, columns=self.data.columns)
        future_data = pd.concat([last_known_data, future_df])

        # Iteratively predict each future day
        for future_date in future_df.index:
            # Update SMAs with available 'Close' data
            for sma_period in [60]:
                sma_values = future_data['Close'].rolling(sma_period, min_periods=1).mean()
                # print(sma_values)
                future_data.loc[future_date, f'SMA{sma_period}'] = sma_values.iloc[-1]
                # print(sma_values.iloc[-1])

            # Ensure there are no NaN values in the input features
            if future_data.loc[future_date, ['SMA5', 'SMA20', 'SMA60']].isna().any():
                continue

            # Prepare the data for the model
            X_future = future_data.loc[future_date, ['SMA5', 'SMA20', 'SMA60']].values.reshape(1, -1)

            # Predict and update 'Close' value
            future_prediction = self.model.predict(X_future)[0]
            future_data.loc[future_date, 'Close'] = future_prediction

        return future_data.loc[future_df.index, 'Close']

    def plot_data_with_future(self, full_data, test_data, predictions, future_predictions, mse, title="Data"):
        plt.figure(figsize=(12, 7))
        
        # Plotting the actual data and predictions
        plt.plot(full_data['Close'], label='Actual Data')
        plt.plot(test_data.index, predictions, color='red', label='Predictions')

        # Plotting future predictions
        future_dates = pd.date_range(start=test_data.index[-1], periods=len(future_predictions)+1, closed='right')
        plt.plot(future_dates, future_predictions, color='orange', label='Future Predictions')

        plt.title(f"{title}\nMean Squared Error: {mse:.2f}")
        plt.xlabel("Time")
        plt.ylabel("Value")
        plt.legend()
        plt.show()

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']

        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        N = 365  # number of days to predict into the future
        future_predictions = self.predict_future(N)

        # Calculate Mean Squared Error
        mse = mean_squared_error(y_test, predictions)

        # Plot the full data, predictions, and future predictions
        self.plot_data_with_future(self.data, self.test_data, predictions, future_predictions, mse)


        return predictions

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions= cp.predict()
    data = cp.data
124/161:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data
    
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')

        # ax1.plot(test_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # # Adding legends and title
        # ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()
        
    def predict_future(self, N):
        # Ensure there's enough historical data for SMA calculations
        historical_data_length = max(60, N)  # At least as long as the longest SMA period
        last_known_data = self.data.iloc[:-historical_data_length].copy()

        # Prepare DataFrame for future predictions
        future_dates = pd.date_range(start=last_known_data.index[-1], periods=N+1, closed='right')
        future_df = pd.DataFrame(index=future_dates, columns=self.data.columns)
        future_data = pd.concat([last_known_data, future_df])

        # Iteratively predict each future day
        for future_date in future_df.index:
            # Update SMAs with available 'Close' data
            for sma_period in [60]:
                sma_values = future_data['Close'].rolling(sma_period, min_periods=1).mean()
                # print(sma_values)
                future_data.loc[future_date, f'SMA{sma_period}'] = sma_values.iloc[-1]
                # print(sma_values.iloc[-1])

            # Ensure there are no NaN values in the input features
            if future_data.loc[future_date, ['SMA5', 'SMA20', 'SMA60']].isna().any():
                continue

            # Prepare the data for the model
            X_future = future_data.loc[future_date, ['SMA5', 'SMA20', 'SMA60']].values.reshape(1, -1)

            # Predict and update 'Close' value
            future_prediction = self.model.predict(X_future)[0]
            future_data.loc[future_date, 'Close'] = future_prediction

        return future_data.loc[future_df.index, 'Close']

    def plot_data_with_future(self, full_data, test_data, predictions, future_predictions, mse, title="Data"):
        plt.figure(figsize=(12, 7))
        
        # Plotting the actual data and predictions
        plt.plot(full_data['Close'], label='Actual Data')
        plt.plot(test_data.index, predictions, color='red', label='Predictions')

        # Plotting future predictions
        future_dates = pd.date_range(start=test_data.index[-1], periods=len(future_predictions)+1, closed='right')
        plt.plot(future_dates, future_predictions, color='orange', label='Future Predictions')

        plt.title(f"{title}\nMean Squared Error: {mse:.2f}")
        plt.xlabel("Time")
        plt.ylabel("Value")
        plt.legend()
        plt.show()

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']

        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        N = 365  # number of days to predict into the future
        future_predictions = self.predict_future(N)

        # Calculate Mean Squared Error
        mse = mean_squared_error(y_test, predictions)

        # Plot the full data, predictions, and future predictions
        self.plot_data_with_future(self.data, self.test_data, predictions, future_predictions, mse)


        return predictions

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions= cp.predict()
    data = cp.data
124/162:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data
    
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')

        # ax1.plot(test_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # # Adding legends and title
        # ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()
        
    def predict_future(self, N):
        # Ensure there's enough historical data for SMA calculations
        historical_data_length = max(60, N)  # At least as long as the longest SMA period
        last_known_data = self.data.iloc[:-historical_data_length].copy()

        # Prepare DataFrame for future predictions
        future_dates = pd.date_range(start=last_known_data.index[-1], periods=N+1, closed='right')
        future_df = pd.DataFrame(index=future_dates, columns=self.data.columns)
        future_data = pd.concat([last_known_data, future_df])

        # Iteratively predict each future day
        for future_date in future_df.index:
            # Update SMAs with available 'Close' data
            for sma_period in [60]:
                sma_values = future_data['Close'].rolling(sma_period, min_periods=1).mean()
                # print(sma_values)
                future_data.loc[future_date, f'SMA{sma_period}'] = sma_values.iloc[-1]
                print(sma_values.iloc[-1])

            # Ensure there are no NaN values in the input features
            if future_data.loc[future_date, ['SMA5', 'SMA20', 'SMA60']].isna().any():
                continue

            # Prepare the data for the model
            X_future = future_data.loc[future_date, ['SMA5', 'SMA20', 'SMA60']].values.reshape(1, -1)

            # Predict and update 'Close' value
            future_prediction = self.model.predict(X_future)[0]
            future_data.loc[future_date, 'Close'] = future_prediction

        return future_data.loc[future_df.index, 'Close']

    def plot_data_with_future(self, full_data, test_data, predictions, future_predictions, mse, title="Data"):
        plt.figure(figsize=(12, 7))
        
        # Plotting the actual data and predictions
        plt.plot(full_data['Close'], label='Actual Data')
        plt.plot(test_data.index, predictions, color='red', label='Predictions')

        # Plotting future predictions
        future_dates = pd.date_range(start=test_data.index[-1], periods=len(future_predictions)+1, closed='right')
        plt.plot(future_dates, future_predictions, color='orange', label='Future Predictions')

        plt.title(f"{title}\nMean Squared Error: {mse:.2f}")
        plt.xlabel("Time")
        plt.ylabel("Value")
        plt.legend()
        plt.show()

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']

        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        N = 365  # number of days to predict into the future
        future_predictions = self.predict_future(N)

        # Calculate Mean Squared Error
        mse = mean_squared_error(y_test, predictions)

        # Plot the full data, predictions, and future predictions
        self.plot_data_with_future(self.data, self.test_data, predictions, future_predictions, mse)


        return predictions

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions= cp.predict()
    data = cp.data
124/163:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data
    
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')

        # ax1.plot(test_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # # Adding legends and title
        # ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()
        
    def predict_future(self, N):
        # Initialize the future DataFrame with the latest actual data
        last_known_data = self.data.iloc[-60:].copy()  # using 60 days to ensure SMA60 can be calculated
        future_dates = pd.date_range(start=last_known_data.index[-1], periods=N+1, closed='right')
        future_df = pd.DataFrame(index=future_dates, columns=self.data.columns)
        future_data = pd.concat([last_known_data, future_df])

        # Iteratively predict each day and use that prediction for subsequent calculations
        for future_date in future_df.index:
            for sma_period in [60]:
                # Calculate SMA values, using available 'Close' values
                sma_values = future_data['Close'].rolling(sma_period, min_periods=1).mean()
                future_data.loc[future_date, f'SMA{sma_period}'] = sma_values.iloc[-1]

            # Prepare the data for the model
            X_future = future_data.loc[future_date, ['SMA5', 'SMA20', 'SMA60']].values.reshape(1, -1)

            # Predict
            future_prediction = self.model.predict(X_future)[0]

            # Use the prediction as the 'Close' value for the next prediction
            future_data.loc[future_date, 'Close'] = future_prediction

        return future_data.loc[future_df.index, 'Close']

    def plot_data_with_future(self, full_data, test_data, predictions, future_predictions, mse, title="Data"):
        plt.figure(figsize=(12, 7))
        
        # Plotting the actual data and predictions
        plt.plot(full_data['Close'], label='Actual Data')
        plt.plot(test_data.index, predictions, color='red', label='Predictions')

        # Plotting future predictions
        future_dates = pd.date_range(start=test_data.index[-1], periods=len(future_predictions)+1, closed='right')
        plt.plot(future_dates, future_predictions, color='orange', label='Future Predictions')

        plt.title(f"{title}\nMean Squared Error: {mse:.2f}")
        plt.xlabel("Time")
        plt.ylabel("Value")
        plt.legend()
        plt.show()

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']

        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        N = 365  # number of days to predict into the future
        future_predictions = self.predict_future(N)

        # Calculate Mean Squared Error
        mse = mean_squared_error(y_test, predictions)

        # Plot the full data, predictions, and future predictions
        self.plot_data_with_future(self.data, self.test_data, predictions, future_predictions, mse)


        return predictions

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions= cp.predict()
    data = cp.data
124/164:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data
    
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')

        # ax1.plot(test_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # # Adding legends and title
        # ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()
        
    def predict_future(self, N):
        # Initialize the future DataFrame with the latest actual data
        last_known_data = self.data.iloc[-60:].copy()  # using 60 days to ensure SMA60 can be calculated
        future_dates = pd.date_range(start=last_known_data.index[-1], periods=N+1, closed='right')
        future_df = pd.DataFrame(index=future_dates, columns=self.data.columns)
        future_data = pd.concat([last_known_data, future_df])

        # Iteratively predict each day and use that prediction for subsequent calculations
        for future_date in future_df.index:
            for sma_period in [60]:
                # Calculate SMA values, using available 'Close' values
                sma_values = future_data['Close'].rolling(sma_period, min_periods=1).mean()
                future_data.loc[future_date, f'SMA{sma_period}'] = sma_values.iloc[-1]
                print(sma_values.iloc[-1])

            # Prepare the data for the model
            X_future = future_data.loc[future_date, ['SMA5', 'SMA20', 'SMA60']].values.reshape(1, -1)

            # Predict
            future_prediction = self.model.predict(X_future)[0]

            # Use the prediction as the 'Close' value for the next prediction
            future_data.loc[future_date, 'Close'] = future_prediction

        return future_data.loc[future_df.index, 'Close']

    def plot_data_with_future(self, full_data, test_data, predictions, future_predictions, mse, title="Data"):
        plt.figure(figsize=(12, 7))
        
        # Plotting the actual data and predictions
        plt.plot(full_data['Close'], label='Actual Data')
        plt.plot(test_data.index, predictions, color='red', label='Predictions')

        # Plotting future predictions
        future_dates = pd.date_range(start=test_data.index[-1], periods=len(future_predictions)+1, closed='right')
        plt.plot(future_dates, future_predictions, color='orange', label='Future Predictions')

        plt.title(f"{title}\nMean Squared Error: {mse:.2f}")
        plt.xlabel("Time")
        plt.ylabel("Value")
        plt.legend()
        plt.show()

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']

        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        N = 365  # number of days to predict into the future
        future_predictions = self.predict_future(N)

        # Calculate Mean Squared Error
        mse = mean_squared_error(y_test, predictions)

        # Plot the full data, predictions, and future predictions
        self.plot_data_with_future(self.data, self.test_data, predictions, future_predictions, mse)


        return predictions

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions= cp.predict()
    data = cp.data
124/165:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data
    
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')

        # ax1.plot(test_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # # Adding legends and title
        # ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()
        
    def predict_future(self, N):
        # Initialize the future DataFrame with the latest actual data
        last_known_data = self.data.iloc[-60:].copy()  # using 60 days to ensure SMA60 can be calculated
        future_dates = pd.date_range(start=last_known_data.index[-1], periods=N+1, closed='right')
        future_df = pd.DataFrame(index=future_dates, columns=self.data.columns)
        future_data = pd.concat([last_known_data, future_df])

        # Iteratively predict each day and use that prediction for subsequent calculations
        for future_date in future_df.index:
            for sma_period in [5, 20, 60]:
                # Calculate SMA values, using available 'Close' values
                sma_values = future_data['Close'].rolling(sma_period, min_periods=1).mean()
                future_data.loc[future_date, f'SMA{sma_period}'] = sma_values.iloc[-1]
                print(sma_values.iloc[-1])

            # Prepare the data for the model
            X_future = future_data.loc[future_date, ['SMA5', 'SMA20', 'SMA60']].values.reshape(1, -1)

            # Predict
            future_prediction = self.model.predict(X_future)[0]

            # Use the prediction as the 'Close' value for the next prediction
            future_data.loc[future_date, 'Close'] = future_prediction

        return future_data.loc[future_df.index, 'Close']

    def plot_data_with_future(self, full_data, test_data, predictions, future_predictions, mse, title="Data"):
        plt.figure(figsize=(12, 7))
        
        # Plotting the actual data and predictions
        plt.plot(full_data['Close'], label='Actual Data')
        plt.plot(test_data.index, predictions, color='red', label='Predictions')

        # Plotting future predictions
        future_dates = pd.date_range(start=test_data.index[-1], periods=len(future_predictions)+1, closed='right')
        plt.plot(future_dates, future_predictions, color='orange', label='Future Predictions')

        plt.title(f"{title}\nMean Squared Error: {mse:.2f}")
        plt.xlabel("Time")
        plt.ylabel("Value")
        plt.legend()
        plt.show()

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']

        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        N = 365  # number of days to predict into the future
        future_predictions = self.predict_future(N)

        # Calculate Mean Squared Error
        mse = mean_squared_error(y_test, predictions)

        # Plot the full data, predictions, and future predictions
        self.plot_data_with_future(self.data, self.test_data, predictions, future_predictions, mse)


        return predictions

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions= cp.predict()
    data = cp.data
129/1:
import pandas as pd
import yfinance as yf
from sklearn.linear_model import LinearRegression
from sklearn.model_selection import train_test_split
import matplotlib.pyplot as plt
from sklearn.metrics import mean_squared_error
129/2:
def download_data(ticker, start_date, end_date):
    data = yf.download(ticker, start=start_date, end=end_date, progress=False)
    data.drop(['Adj Close'], axis=1, inplace=True)
    return data

btc_data = download_data('BTC-USD', '2018-01-01', '2023-12-07')
ada_data = download_data('ADA-USD', '2018-01-01', '2023-12-07')
129/3:
btc_data['SMA5'] = btc_data['Close'].rolling(5).mean()
btc_data['SMA20'] = btc_data['Close'].rolling(20).mean()
btc_data['SMA60'] = btc_data['Close'].rolling(60).mean()

ada_data['SMA5'] = ada_data['Close'].rolling(5).mean()
ada_data['SMA20'] = ada_data['Close'].rolling(20).mean()
ada_data['SMA60'] = ada_data['Close'].rolling(60).mean()

btc_data = btc_data.dropna()
ada_data = ada_data.dropna()

# Create a new DataFrame with the last N rows for the testing set
btc_test = btc_data.iloc[-N:]
ada_test = ada_data.iloc[-N:]

# Create a new DataFrame with all rows except the last N rows for the training set
btc_train = btc_data.iloc[:-N]
ada_train = ada_data.iloc[:-N]
129/4:
plt.plot(X_btc_train, y_btc_train, 'b.', label='Training Data')
plt.plot(X_btc_test, y_btc_test, 'r.', label='Test Data')
plt.plot(X_btc_test, btc_pred, 'g.', label='Predictions')
plt.legend()
plt.show()

plt.plot(y_ada_train, label='Actual ADA')
plt.plot(ada_pred, label='Predicted ADA')
plt.legend()
plt.show()
129/5:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data
    
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')

        # ax1.plot(test_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # # Adding legends and title
        # ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()
        
    def predict_future(self, N):
        # Initialize the future DataFrame with the latest actual data
        last_known_data = self.data.iloc[-60:].copy()  # using 60 days to ensure SMA60 can be calculated
        future_dates = pd.date_range(start=last_known_data.index[-1], periods=N+1, closed='right')
        future_df = pd.DataFrame(index=future_dates, columns=self.data.columns)
        future_data = pd.concat([last_known_data, future_df])

        # Iteratively predict each day and use that prediction for subsequent calculations
        for future_date in future_df.index:
            for sma_period in [60]:
                # Calculate SMA values, using available 'Close' values
                sma_values = future_data['Close'].rolling(sma_period, min_periods=1).mean()
                future_data.loc[future_date, f'SMA{sma_period}'] = sma_values.iloc[-1]
                print(sma_values.iloc[-1])

            # Prepare the data for the model
            X_future = future_data.loc[future_date, ['SMA5', 'SMA20', 'SMA60']].values.reshape(1, -1)

            # Predict
            future_prediction = self.model.predict(X_future)[0]

            # Use the prediction as the 'Close' value for the next prediction
            future_data.loc[future_date, 'Close'] = future_prediction

        return future_data.loc[future_df.index, 'Close']

    def plot_data_with_future(self, full_data, test_data, predictions, future_predictions, mse, title="Data"):
        plt.figure(figsize=(12, 7))
        
        # Plotting the actual data and predictions
        plt.plot(full_data['Close'], label='Actual Data')
        plt.plot(test_data.index, predictions, color='red', label='Predictions')

        # Plotting future predictions
        future_dates = pd.date_range(start=test_data.index[-1], periods=len(future_predictions)+1, closed='right')
        plt.plot(future_dates, future_predictions, color='orange', label='Future Predictions')

        plt.title(f"{title}\nMean Squared Error: {mse:.2f}")
        plt.xlabel("Time")
        plt.ylabel("Value")
        plt.legend()
        plt.show()

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']

        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        N = 365  # number of days to predict into the future
        future_predictions = self.predict_future(N)

        # Calculate Mean Squared Error
        mse = mean_squared_error(y_test, predictions)

        # Plot the full data, predictions, and future predictions
        self.plot_data_with_future(self.data, self.test_data, predictions, future_predictions, mse)


        return predictions

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions= cp.predict()
    data = cp.data
129/6:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data
    
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')

        # ax1.plot(test_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # # Adding legends and title
        # ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()
        
    def predict_future(self, N):
        # Initialize the future DataFrame with the latest actual data
        last_known_data = self.data.iloc[-60:].copy()  # using 60 days to ensure SMA60 can be calculated
        future_dates = pd.date_range(start=last_known_data.index[-1], periods=N+1, closed='right')
        future_df = pd.DataFrame(index=future_dates, columns=self.data.columns)
        future_data = pd.concat([last_known_data, future_df])

        # Iteratively predict each day and use that prediction for subsequent calculations
        for future_date in future_df.index:
            for sma_period in [60]:
                # Calculate SMA values, using available 'Close' values
                sma_values = future_data['Close'].rolling(sma_period, min_periods=1).mean()
                future_data.loc[future_date, f'SMA{sma_period}'] = sma_values.iloc[-1]
                print(sma_values.iloc[-1])

            # Prepare the data for the model
            X_future = future_data.loc[future_date, ['SMA5', 'SMA20', 'SMA60']].values.reshape(1, -1)

            # Predict
            future_prediction = self.model.predict(X_future)[0]

            # Use the prediction as the 'Close' value for the next prediction
            future_data.loc[future_date, 'Close'] = future_prediction

        return future_data.loc[future_df.index, 'Close']

    def plot_data_with_future(self, full_data, test_data, predictions, future_predictions, mse, title="Data"):
        plt.figure(figsize=(12, 7))
        
        # Plotting the actual data and predictions
        plt.plot(full_data['Close'], label='Actual Data')
        plt.plot(test_data.index, predictions, color='red', label='Predictions')

        # Plotting future predictions
        future_dates = pd.date_range(start=test_data.index[-1], periods=len(future_predictions)+1, closed='right')
        plt.plot(future_dates, future_predictions, color='orange', label='Future Predictions')

        plt.title(f"{title}\nMean Squared Error: {mse:.2f}")
        plt.xlabel("Time")
        plt.ylabel("Value")
        plt.legend()
        plt.show()

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']

        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        N = 365  # number of days to predict into the future
        future_predictions = self.predict_future(N)

        # Calculate Mean Squared Error
        mse = mean_squared_error(y_test, predictions)

        # Plot the full data, predictions, and future predictions
        self.plot_data_with_future(self.data, self.test_data, predictions, future_predictions, mse)


        return predictions

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions= cp.predict()
    data = cp.data
129/7: t
129/8:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data
    
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')

        # ax1.plot(test_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # # Adding legends and title
        # ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()
        
    def predict_future(self, N):
        # Initialize the future DataFrame with the latest actual data
        last_known_data = self.data.iloc[-60:].copy()  # using 60 days to ensure SMA60 can be calculated
        future_dates = pd.date_range(start=last_known_data.index[-1], periods=N+1, closed='right')
        future_df = pd.DataFrame(index=future_dates, columns=self.data.columns)
        future_data = pd.concat([last_known_data, future_df])

        # Iteratively predict each day and use that prediction for subsequent calculations
        for future_date in future_df.index:
            for sma_period in [60]:
                # Calculate SMA values, using available 'Close' values
                sma_values = future_data['Close'].rolling(sma_period, min_periods=1).mean()
                future_data.loc[future_date, f'SMA{sma_period}'] = sma_values.iloc[-1]
                print(sma_values.iloc[-1])

            # Prepare the data for the model
            X_future = future_data.loc[future_date, ['SMA5', 'SMA20', 'SMA60']].values.reshape(1, -1)

            # Predict
            future_prediction = self.model.predict(X_future)[0]

            # Use the prediction as the 'Close' value for the next prediction
            future_data.loc[future_date, 'Close'] = future_prediction

        return future_data.loc[future_df.index, 'Close']

    def plot_data_with_future(self, full_data, test_data, predictions, future_predictions, mse, title="Data"):
        plt.figure(figsize=(12, 7))
        
        # Plotting the actual data and predictions
        plt.plot(full_data['Close'], label='Actual Data')
        plt.plot(test_data.index, predictions, color='red', label='Predictions')

        # Plotting future predictions
        future_dates = pd.date_range(start=test_data.index[-1], periods=len(future_predictions)+1, closed='right')
        plt.plot(future_dates, future_predictions, color='orange', label='Future Predictions')

        plt.title(f"{title}\nMean Squared Error: {mse:.2f}")
        plt.xlabel("Time")
        plt.ylabel("Value")
        plt.legend()
        plt.show()

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']

        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        return predictions

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions= cp.predict()
    data = cp.data
129/9: cp.forecast()
129/10:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data
    
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')

        # ax1.plot(test_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # # Adding legends and title
        # ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()
        
    def predict_future(self, N):
        # Initialize the future DataFrame with the latest actual data
        last_known_data = self.data.iloc[-60:].copy()  # using 60 days to ensure SMA60 can be calculated
        future_dates = pd.date_range(start=last_known_data.index[-1], periods=N+1, closed='right')
        future_df = pd.DataFrame(index=future_dates, columns=self.data.columns)
        future_data = pd.concat([last_known_data, future_df])

        # Iteratively predict each day and use that prediction for subsequent calculations
        for future_date in future_df.index:
            for sma_period in [60]:
                # Calculate SMA values, using available 'Close' values
                sma_values = future_data['Close'].rolling(sma_period, min_periods=1).mean()
                future_data.loc[future_date, f'SMA{sma_period}'] = sma_values.iloc[-1]
                print(sma_values.iloc[-1])

            # Prepare the data for the model
            X_future = future_data.loc[future_date, ['SMA5', 'SMA20', 'SMA60']].values.reshape(1, -1)

            # Predict
            future_prediction = self.model.predict(X_future)[0]

            # Use the prediction as the 'Close' value for the next prediction
            future_data.loc[future_date, 'Close'] = future_prediction

        return future_data.loc[future_df.index, 'Close']

    def plot_data_with_future(self, full_data, test_data, predictions, future_predictions, title="Data"):
        plt.figure(figsize=(12, 7))
        
        # Plotting the actual data and predictions
        plt.plot(full_data['Close'], label='Actual Data')
        plt.plot(test_data.index, predictions, color='red', label='Predictions')

        # Plotting future predictions
        future_dates = pd.date_range(start=test_data.index[-1], periods=len(future_predictions)+1, closed='right')
        plt.plot(future_dates, future_predictions, color='orange', label='Future Predictions')

        plt.title(f"{title}\nMean Squared Error: {mse:.2f}")
        plt.xlabel("Time")
        plt.ylabel("Value")
        plt.legend()
        plt.show()

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']

        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        return predictions

    def forecast(self):
        N = 365  # number of days to predict into the future
        future_predictions = self.predict_future(N)

        # Plot the full data, predictions, and future predictions
        self.plot_data_with_future(self.data, self.test_data, predictions, future_predictions)


if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions= cp.predict()
    data = cp.data
129/11: cp.forecast()
129/12:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data
    
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')

        # ax1.plot(test_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # # Adding legends and title
        # ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()
        
    def predict_future(self, N):
        # Initialize the future DataFrame with the latest actual data
        last_known_data = self.data #.iloc[-60:].copy()  # using 60 days to ensure SMA60 can be calculated
        future_dates = pd.date_range(start=last_known_data.index[-1], periods=N+1, closed='right')
        future_df = pd.DataFrame(index=future_dates, columns=self.data.columns)
        future_data = pd.concat([last_known_data, future_df])

        # Iteratively predict each day and use that prediction for subsequent calculations
        for future_date in future_df.index:
            for sma_period in [60]:
                # Calculate SMA values, using available 'Close' values
                sma_values = future_data['Close'].rolling(sma_period, min_periods=1).mean()
                future_data.loc[future_date, f'SMA{sma_period}'] = sma_values.iloc[-1]
                print(sma_values.iloc[-1])

            # Prepare the data for the model
            X_future = future_data.loc[future_date, ['SMA5', 'SMA20', 'SMA60']].values.reshape(1, -1)

            # Predict
            future_prediction = self.model.predict(X_future)[0]

            # Use the prediction as the 'Close' value for the next prediction
            future_data.loc[future_date, 'Close'] = future_prediction

        return future_data.loc[future_df.index, 'Close']

    def plot_data_with_future(self, full_data, test_data, predictions, future_predictions, title="Data"):
        plt.figure(figsize=(12, 7))
        
        # Plotting the actual data and predictions
        plt.plot(full_data['Close'], label='Actual Data')
        plt.plot(test_data.index, predictions, color='red', label='Predictions')

        # Plotting future predictions
        future_dates = pd.date_range(start=test_data.index[-1], periods=len(future_predictions)+1, closed='right')
        plt.plot(future_dates, future_predictions, color='orange', label='Future Predictions')

        plt.title(f"{title}\nMean Squared Error: {mse:.2f}")
        plt.xlabel("Time")
        plt.ylabel("Value")
        plt.legend()
        plt.show()

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']

        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        return predictions

    def forecast(self):
        N = 365  # number of days to predict into the future
        future_predictions = self.predict_future(N)

        # Plot the full data, predictions, and future predictions
        self.plot_data_with_future(self.data, self.test_data, predictions, future_predictions)


if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions= cp.predict()
    data = cp.data
129/13: cp.forecast()
129/14:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data
    
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')

        # ax1.plot(test_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # # Adding legends and title
        # ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()
        
    def predict_future(self, N):
        # Initialize the future DataFrame with the latest actual data
        last_known_data = self.data #.iloc[-60:].copy()  # using 60 days to ensure SMA60 can be calculated
        future_dates = pd.date_range(start=last_known_data.index[-1], periods=N+1, closed='right')
        future_df = pd.DataFrame(index=future_dates, columns=self.data.columns)
        future_data = pd.concat([last_known_data, future_df])

        # Iteratively predict each day and use that prediction for subsequent calculations
        for future_date in future_df.index:
            for sma_period in [60]:
                # Calculate SMA values, using available 'Close' values
                sma_values = future_data['Close'].rolling(sma_period).mean()
                future_data.loc[future_date, f'SMA{sma_period}'] = sma_values.iloc[-1]
                print(sma_values.iloc[-1])

            # Prepare the data for the model
            X_future = future_data.loc[future_date, ['SMA5', 'SMA20', 'SMA60']].values.reshape(1, -1)

            # Predict
            future_prediction = self.model.predict(X_future)[0]

            # Use the prediction as the 'Close' value for the next prediction
            future_data.loc[future_date, 'Close'] = future_prediction

        return future_data.loc[future_df.index, 'Close']

    def plot_data_with_future(self, full_data, test_data, predictions, future_predictions, title="Data"):
        plt.figure(figsize=(12, 7))
        
        # Plotting the actual data and predictions
        plt.plot(full_data['Close'], label='Actual Data')
        plt.plot(test_data.index, predictions, color='red', label='Predictions')

        # Plotting future predictions
        future_dates = pd.date_range(start=test_data.index[-1], periods=len(future_predictions)+1, closed='right')
        plt.plot(future_dates, future_predictions, color='orange', label='Future Predictions')

        plt.title(f"{title}\nMean Squared Error: {mse:.2f}")
        plt.xlabel("Time")
        plt.ylabel("Value")
        plt.legend()
        plt.show()

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']

        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        return predictions

    def forecast(self):
        N = 365  # number of days to predict into the future
        future_predictions = self.predict_future(N)

        # Plot the full data, predictions, and future predictions
        self.plot_data_with_future(self.data, self.test_data, predictions, future_predictions)


if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions= cp.predict()
    data = cp.data
129/15: cp.forecast()
129/16:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data
    
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')

        # ax1.plot(test_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # # Adding legends and title
        # ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()
        
    def predict_future(self, N):
        # Initialize the future DataFrame with the latest actual data
        last_known_data = self.data #.iloc[-60:].copy()  # using 60 days to ensure SMA60 can be calculated
        future_dates = pd.date_range(start=last_known_data.index[-1], periods=N+1, closed='right')
        future_df = pd.DataFrame(index=future_dates, columns=self.data.columns)
        future_data = pd.concat([last_known_data, future_df])

        # Iteratively predict each day and use that prediction for subsequent calculations
        for future_date in future_df.index:
            for sma_period in [60]:
                # Calculate SMA values, using available 'Close' values
                sma_values = future_data['Close'].rolling(sma_period).mean()
                print(sma_values[-1])
                future_data.loc[future_date, f'SMA{sma_period}'] = sma_values.iloc[-1]
                print(sma_values.iloc[-1])

            # Prepare the data for the model
            X_future = future_data.loc[future_date, ['SMA5', 'SMA20', 'SMA60']].values.reshape(1, -1)

            # Predict
            future_prediction = self.model.predict(X_future)[0]

            # Use the prediction as the 'Close' value for the next prediction
            future_data.loc[future_date, 'Close'] = future_prediction

        return future_data.loc[future_df.index, 'Close']

    def plot_data_with_future(self, full_data, test_data, predictions, future_predictions, title="Data"):
        plt.figure(figsize=(12, 7))
        
        # Plotting the actual data and predictions
        plt.plot(full_data['Close'], label='Actual Data')
        plt.plot(test_data.index, predictions, color='red', label='Predictions')

        # Plotting future predictions
        future_dates = pd.date_range(start=test_data.index[-1], periods=len(future_predictions)+1, closed='right')
        plt.plot(future_dates, future_predictions, color='orange', label='Future Predictions')

        plt.title(f"{title}\nMean Squared Error: {mse:.2f}")
        plt.xlabel("Time")
        plt.ylabel("Value")
        plt.legend()
        plt.show()

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']

        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        return predictions

    def forecast(self):
        N = 365  # number of days to predict into the future
        future_predictions = self.predict_future(N)

        # Plot the full data, predictions, and future predictions
        self.plot_data_with_future(self.data, self.test_data, predictions, future_predictions)


if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions= cp.predict()
    data = cp.data
129/17: cp.forecast()
129/18:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data
    
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')

        # ax1.plot(test_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # # Adding legends and title
        # ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()
        
    def predict_future(self, N):
        # Initialize the future DataFrame with the latest actual data
        last_known_data = self.data #.iloc[-60:].copy()  # using 60 days to ensure SMA60 can be calculated
        future_dates = pd.date_range(start=last_known_data.index[-1], periods=N+1, closed='right')
        future_df = pd.DataFrame(index=future_dates, columns=self.data.columns)
        future_data = pd.concat([last_known_data, future_df])

        # Iteratively predict each day and use that prediction for subsequent calculations
        for future_date in future_df.index:
            for sma_period in [5, 20, 60]:
                # Calculate SMA values, using available 'Close' values
                sma_values = future_data['Close'].rolling(sma_period).mean()
                print(sma_values[-1])
                future_data.loc[future_date, f'SMA{sma_period}'] = sma_values.iloc[-1]
                print(sma_values.iloc[-1])

            # Prepare the data for the model
            X_future = future_data.loc[future_date, ['SMA5', 'SMA20', 'SMA60']].values.reshape(1, -1)

            # Predict
            future_prediction = self.model.predict(X_future)[0]

            # Use the prediction as the 'Close' value for the next prediction
            future_data.loc[future_date, 'Close'] = future_prediction

        return future_data.loc[future_df.index, 'Close']

    def plot_data_with_future(self, full_data, test_data, predictions, future_predictions, title="Data"):
        plt.figure(figsize=(12, 7))
        
        # Plotting the actual data and predictions
        plt.plot(full_data['Close'], label='Actual Data')
        plt.plot(test_data.index, predictions, color='red', label='Predictions')

        # Plotting future predictions
        future_dates = pd.date_range(start=test_data.index[-1], periods=len(future_predictions)+1, closed='right')
        plt.plot(future_dates, future_predictions, color='orange', label='Future Predictions')

        plt.title(f"{title}\nMean Squared Error: {mse:.2f}")
        plt.xlabel("Time")
        plt.ylabel("Value")
        plt.legend()
        plt.show()

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']

        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        return predictions

    def forecast(self):
        N = 365  # number of days to predict into the future
        future_predictions = self.predict_future(N)

        # Plot the full data, predictions, and future predictions
        self.plot_data_with_future(self.data, self.test_data, predictions, future_predictions)


if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions= cp.predict()
    data = cp.data
129/19: cp.forecast()
129/20:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data
    
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')

        # ax1.plot(test_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # # Adding legends and title
        # ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()
        
    def predict_future(self, N):
        # Initialize the future DataFrame with the latest actual data
        last_known_data = self.data #.iloc[-60:].copy()  # using 60 days to ensure SMA60 can be calculated
        future_dates = pd.date_range(start=last_known_data.index[-1], periods=N+1, closed='right')
        future_df = pd.DataFrame(index=future_dates, columns=self.data.columns)
        future_data = pd.concat([last_known_data, future_df])

        # Iteratively predict each day and use that prediction for subsequent calculations
        for index, future_date in future_df.iterrows():
            for sma_period in [5, 20, 60]:
                # Calculate SMA values, using available 'Close' values
                sma_values = future_data['Close'].rolling(sma_period).mean()
                print(sma_values[-1])
                future_data.loc[future_date, f'SMA{sma_period}'] = sma_values.iloc[-1]
                print(sma_values.iloc[-1])

            # Prepare the data for the model
            X_future = future_data.loc[future_date, ['SMA5', 'SMA20', 'SMA60']].values.reshape(1, -1)

            # Predict
            future_prediction = self.model.predict(X_future)[0]

            # Use the prediction as the 'Close' value for the next prediction
            future_data.loc[future_date, 'Close'] = future_prediction

        return future_data.loc[future_df.index, 'Close']

    def plot_data_with_future(self, full_data, test_data, predictions, future_predictions, title="Data"):
        plt.figure(figsize=(12, 7))
        
        # Plotting the actual data and predictions
        plt.plot(full_data['Close'], label='Actual Data')
        plt.plot(test_data.index, predictions, color='red', label='Predictions')

        # Plotting future predictions
        future_dates = pd.date_range(start=test_data.index[-1], periods=len(future_predictions)+1, closed='right')
        plt.plot(future_dates, future_predictions, color='orange', label='Future Predictions')

        plt.title(f"{title}\nMean Squared Error: {mse:.2f}")
        plt.xlabel("Time")
        plt.ylabel("Value")
        plt.legend()
        plt.show()

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']

        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        return predictions

    def forecast(self):
        N = 365  # number of days to predict into the future
        future_predictions = self.predict_future(N)

        # Plot the full data, predictions, and future predictions
        self.plot_data_with_future(self.data, self.test_data, predictions, future_predictions)


if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions= cp.predict()
    data = cp.data
129/21: cp.forecast()
129/22:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data
    
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')

        # ax1.plot(test_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # # Adding legends and title
        # ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()
        
    def predict_future(self, N):
        # Initialize the future DataFrame with the latest actual data
        last_known_data = self.data #.iloc[-60:].copy()  # using 60 days to ensure SMA60 can be calculated
        future_dates = pd.date_range(start=last_known_data.index[-1], periods=N+1, closed='right')
        future_df = pd.DataFrame(index=future_dates, columns=self.data.columns)
        future_data = pd.concat([last_known_data, future_df])

        # Iteratively predict each day and use that prediction for subsequent calculations
        for index, future_date in future_df.iterrows():
            for sma_period in [5, 20, 60]:
                # Calculate SMA values, using available 'Close' values
                sma_values = future_data['Close'].rolling(sma_period).mean()
                print(sma_values[-1], future_data['Close'])
                future_data.loc[future_date, f'SMA{sma_period}'] = sma_values.iloc[-1]
                print(sma_values.iloc[-1])

            # Prepare the data for the model
            X_future = future_data.loc[future_date, ['SMA5', 'SMA20', 'SMA60']].values.reshape(1, -1)

            # Predict
            future_prediction = self.model.predict(X_future)[0]

            # Use the prediction as the 'Close' value for the next prediction
            future_data.loc[future_date, 'Close'] = future_prediction

        return future_data.loc[future_df.index, 'Close']

    def plot_data_with_future(self, full_data, test_data, predictions, future_predictions, title="Data"):
        plt.figure(figsize=(12, 7))
        
        # Plotting the actual data and predictions
        plt.plot(full_data['Close'], label='Actual Data')
        plt.plot(test_data.index, predictions, color='red', label='Predictions')

        # Plotting future predictions
        future_dates = pd.date_range(start=test_data.index[-1], periods=len(future_predictions)+1, closed='right')
        plt.plot(future_dates, future_predictions, color='orange', label='Future Predictions')

        plt.title(f"{title}\nMean Squared Error: {mse:.2f}")
        plt.xlabel("Time")
        plt.ylabel("Value")
        plt.legend()
        plt.show()

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']

        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        return predictions

    def forecast(self):
        N = 365  # number of days to predict into the future
        future_predictions = self.predict_future(N)

        # Plot the full data, predictions, and future predictions
        self.plot_data_with_future(self.data, self.test_data, predictions, future_predictions)


if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions= cp.predict()
    data = cp.data
129/23: cp.forecast()
129/24:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data
    
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')

        # ax1.plot(test_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # # Adding legends and title
        # ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()
        
    def predict_future(self, N):
        # Initialize the future DataFrame with the latest actual data
        last_known_data = self.data.iloc[-60:].copy()  # using 60 days to ensure SMA60 can be calculated
        future_dates = pd.date_range(start=last_known_data.index[-1], periods=N+1, closed='right')
        future_df = pd.DataFrame(index=future_dates, columns=self.data.columns)
        future_data = pd.concat([last_known_data, future_df])

        # Iteratively predict each day and use that prediction for subsequent calculations
        for index, future_date in future_df.iterrows():
            for sma_period in [5, 20, 60]:
                # Calculate SMA values, using available 'Close' values
                sma_values = future_data['Close'].rolling(sma_period).mean()
                print(sma_values[-1], future_data['Close'])
                future_data.loc[future_date, f'SMA{sma_period}'] = sma_values.iloc[-1]
                print(sma_values.iloc[-1])

            # Prepare the data for the model
            X_future = future_data.loc[future_date, ['SMA5', 'SMA20', 'SMA60']].values.reshape(1, -1)

            # Predict
            future_prediction = self.model.predict(X_future)[0]

            # Use the prediction as the 'Close' value for the next prediction
            future_data.loc[future_date, 'Close'] = future_prediction

        return future_data.loc[future_df.index, 'Close']

    def plot_data_with_future(self, full_data, test_data, predictions, future_predictions, title="Data"):
        plt.figure(figsize=(12, 7))
        
        # Plotting the actual data and predictions
        plt.plot(full_data['Close'], label='Actual Data')
        plt.plot(test_data.index, predictions, color='red', label='Predictions')

        # Plotting future predictions
        future_dates = pd.date_range(start=test_data.index[-1], periods=len(future_predictions)+1, closed='right')
        plt.plot(future_dates, future_predictions, color='orange', label='Future Predictions')

        plt.title(f"{title}\nMean Squared Error: {mse:.2f}")
        plt.xlabel("Time")
        plt.ylabel("Value")
        plt.legend()
        plt.show()

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']

        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        return predictions

    def forecast(self):
        N = 365  # number of days to predict into the future
        future_predictions = self.predict_future(N)

        # Plot the full data, predictions, and future predictions
        self.plot_data_with_future(self.data, self.test_data, predictions, future_predictions)


if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions= cp.predict()
    data = cp.data
129/25: cp.forecast()
129/26:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data
    
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')

        # ax1.plot(test_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # # Adding legends and title
        # ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()
        
    def predict_future(self, N):
        # Initialize the future DataFrame with the latest actual data
        last_known_data = self.data.iloc[-60:].copy()  # using 60 days to ensure SMA60 can be calculated
        future_dates = pd.date_range(start=last_known_data.index[-1], periods=N+1, closed='right')
        future_df = pd.DataFrame(index=future_dates, columns=self.data.columns)
        future_data = pd.concat([last_known_data, future_df])

        # Iteratively predict each day and use that prediction for subsequent calculations
        for index, future_date in future_df.iterrows():
            for sma_period in [5, 20, 60]:
                # Calculate SMA values, using available 'Close' values
                sma_values = future_data['Close'].rolling(sma_period).mean()
                print(sma_values[-1], future_data['Close'])
                future_data.loc[future_date, f'SMA{sma_period}'] = sma_values.iloc[-1]
                print(sma_values.iloc[-1])

            # Prepare the data for the model
            X_future = future_data.loc[future_date, ['SMA5', 'SMA20', 'SMA60']].values.reshape(1, -1)

            # Predict
            future_prediction = self.model.predict(X_future)[0]

            # Use the prediction as the 'Close' value for the next prediction
            future_data.loc[future_date, 'Close'] = future_prediction

        return future_data.loc[future_df.index, 'Close']

    def plot_data_with_future(self, full_data, test_data, predictions, future_predictions, title="Data"):
        plt.figure(figsize=(12, 7))
        
        # Plotting the actual data and predictions
        plt.plot(full_data['Close'], label='Actual Data')
        plt.plot(test_data.index, predictions, color='red', label='Predictions')

        # Plotting future predictions
        future_dates = pd.date_range(start=test_data.index[-1], periods=len(future_predictions)+1, closed='right')
        plt.plot(future_dates, future_predictions, color='orange', label='Future Predictions')

        plt.title(f"{title}\nMean Squared Error: {mse:.2f}")
        plt.xlabel("Time")
        plt.ylabel("Value")
        plt.legend()
        plt.show()

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']

        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        return predictions

    def forecast(self):
        N = 365  # number of days to predict into the future
        future_predictions = self.predict_future(N)

        # Plot the full data, predictions, and future predictions
        self.plot_data_with_future(self.data, self.test_data, predictions, future_predictions)

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 1))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()

        return predicted_data


if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions= cp.predict()
    data = cp.data
129/27:
future_predictions = cp.predict_future(window=30)
print(future_predictions)
129/28:
import pandas as pd
import yfinance as yf
from sklearn.linear_model import LinearRegression
from sklearn.model_selection import train_test_split
import matplotlib.pyplot as plt
from sklearn.metrics import mean_squared_error
from datetime import datetime, timedelta
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
129/29:
def download_data(ticker, start_date, end_date):
    data = yf.download(ticker, start=start_date, end=end_date, progress=False)
    data.drop(['Adj Close'], axis=1, inplace=True)
    return data

btc_data = download_data('BTC-USD', '2018-01-01', '2023-12-07')
ada_data = download_data('ADA-USD', '2018-01-01', '2023-12-07')
129/30:


class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data
    
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')

        # ax1.plot(test_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # # Adding legends and title
        # ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()
        
    def predict_future(self, N):
        # Initialize the future DataFrame with the latest actual data
        last_known_data = self.data.iloc[-60:].copy()  # using 60 days to ensure SMA60 can be calculated
        future_dates = pd.date_range(start=last_known_data.index[-1], periods=N+1, closed='right')
        future_df = pd.DataFrame(index=future_dates, columns=self.data.columns)
        future_data = pd.concat([last_known_data, future_df])

        # Iteratively predict each day and use that prediction for subsequent calculations
        for index, future_date in future_df.iterrows():
            for sma_period in [5, 20, 60]:
                # Calculate SMA values, using available 'Close' values
                sma_values = future_data['Close'].rolling(sma_period).mean()
                print(sma_values[-1], future_data['Close'])
                future_data.loc[future_date, f'SMA{sma_period}'] = sma_values.iloc[-1]
                print(sma_values.iloc[-1])

            # Prepare the data for the model
            X_future = future_data.loc[future_date, ['SMA5', 'SMA20', 'SMA60']].values.reshape(1, -1)

            # Predict
            future_prediction = self.model.predict(X_future)[0]

            # Use the prediction as the 'Close' value for the next prediction
            future_data.loc[future_date, 'Close'] = future_prediction

        return future_data.loc[future_df.index, 'Close']

    def plot_data_with_future(self, full_data, test_data, predictions, future_predictions, title="Data"):
        plt.figure(figsize=(12, 7))
        
        # Plotting the actual data and predictions
        plt.plot(full_data['Close'], label='Actual Data')
        plt.plot(test_data.index, predictions, color='red', label='Predictions')

        # Plotting future predictions
        future_dates = pd.date_range(start=test_data.index[-1], periods=len(future_predictions)+1, closed='right')
        plt.plot(future_dates, future_predictions, color='orange', label='Future Predictions')

        plt.title(f"{title}\nMean Squared Error: {mse:.2f}")
        plt.xlabel("Time")
        plt.ylabel("Value")
        plt.legend()
        plt.show()

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']

        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        return predictions

    def forecast(self):
        N = 365  # number of days to predict into the future
        future_predictions = self.predict_future(N)

        # Plot the full data, predictions, and future predictions
        self.plot_data_with_future(self.data, self.test_data, predictions, future_predictions)

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 1))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()

        return predicted_data


if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions= cp.predict()
    data = cp.data
129/31:
future_predictions = cp.predict_future(window=30)
print(future_predictions)
129/32:
import pandas as pd
import yfinance as yf
import numpy as np
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
129/33:
def download_data(ticker, start_date, end_date):
    data = yf.download(ticker, start=start_date, end=end_date, progress=False)
    data.drop(['Adj Close'], axis=1, inplace=True)
    return data

btc_data = download_data('BTC-USD', '2018-01-01', '2023-12-07')
ada_data = download_data('ADA-USD', '2018-01-01', '2023-12-07')
129/34:


class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data
    
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')

        # ax1.plot(test_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # # Adding legends and title
        # ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()
        
    def predict_future(self, N):
        # Initialize the future DataFrame with the latest actual data
        last_known_data = self.data.iloc[-60:].copy()  # using 60 days to ensure SMA60 can be calculated
        future_dates = pd.date_range(start=last_known_data.index[-1], periods=N+1, closed='right')
        future_df = pd.DataFrame(index=future_dates, columns=self.data.columns)
        future_data = pd.concat([last_known_data, future_df])

        # Iteratively predict each day and use that prediction for subsequent calculations
        for index, future_date in future_df.iterrows():
            for sma_period in [5, 20, 60]:
                # Calculate SMA values, using available 'Close' values
                sma_values = future_data['Close'].rolling(sma_period).mean()
                print(sma_values[-1], future_data['Close'])
                future_data.loc[future_date, f'SMA{sma_period}'] = sma_values.iloc[-1]
                print(sma_values.iloc[-1])

            # Prepare the data for the model
            X_future = future_data.loc[future_date, ['SMA5', 'SMA20', 'SMA60']].values.reshape(1, -1)

            # Predict
            future_prediction = self.model.predict(X_future)[0]

            # Use the prediction as the 'Close' value for the next prediction
            future_data.loc[future_date, 'Close'] = future_prediction

        return future_data.loc[future_df.index, 'Close']

    def plot_data_with_future(self, full_data, test_data, predictions, future_predictions, title="Data"):
        plt.figure(figsize=(12, 7))
        
        # Plotting the actual data and predictions
        plt.plot(full_data['Close'], label='Actual Data')
        plt.plot(test_data.index, predictions, color='red', label='Predictions')

        # Plotting future predictions
        future_dates = pd.date_range(start=test_data.index[-1], periods=len(future_predictions)+1, closed='right')
        plt.plot(future_dates, future_predictions, color='orange', label='Future Predictions')

        plt.title(f"{title}\nMean Squared Error: {mse:.2f}")
        plt.xlabel("Time")
        plt.ylabel("Value")
        plt.legend()
        plt.show()

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']

        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        return predictions

    def forecast(self):
        N = 365  # number of days to predict into the future
        future_predictions = self.predict_future(N)

        # Plot the full data, predictions, and future predictions
        self.plot_data_with_future(self.data, self.test_data, predictions, future_predictions)

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 1))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()

        return predicted_data


if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions= cp.predict()
    data = cp.data
129/35:
future_predictions = cp.predict_future(window=30)
print(future_predictions)
129/36:


class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data
    
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')

        # ax1.plot(test_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # # Adding legends and title
        # ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()
        
    def predict_future(self, N):
        # Initialize the future DataFrame with the latest actual data
        last_known_data = self.data.iloc[-60:].copy()  # using 60 days to ensure SMA60 can be calculated
        future_dates = pd.date_range(start=last_known_data.index[-1], periods=N+1, closed='right')
        future_df = pd.DataFrame(index=future_dates, columns=self.data.columns)
        future_data = pd.concat([last_known_data, future_df])

        # Iteratively predict each day and use that prediction for subsequent calculations
        for index, future_date in future_df.iterrows():
            for sma_period in [5, 20, 60]:
                # Calculate SMA values, using available 'Close' values
                sma_values = future_data['Close'].rolling(sma_period).mean()
                print(sma_values[-1], future_data['Close'])
                future_data.loc[future_date, f'SMA{sma_period}'] = sma_values.iloc[-1]
                print(sma_values.iloc[-1])

            # Prepare the data for the model
            X_future = future_data.loc[future_date, ['SMA5', 'SMA20', 'SMA60']].values.reshape(1, -1)

            # Predict
            future_prediction = self.model.predict(X_future)[0]

            # Use the prediction as the 'Close' value for the next prediction
            future_data.loc[future_date, 'Close'] = future_prediction

        return future_data.loc[future_df.index, 'Close']

    def plot_data_with_future(self, full_data, test_data, predictions, future_predictions, title="Data"):
        plt.figure(figsize=(12, 7))
        
        # Plotting the actual data and predictions
        plt.plot(full_data['Close'], label='Actual Data')
        plt.plot(test_data.index, predictions, color='red', label='Predictions')

        # Plotting future predictions
        future_dates = pd.date_range(start=test_data.index[-1], periods=len(future_predictions)+1, closed='right')
        plt.plot(future_dates, future_predictions, color='orange', label='Future Predictions')

        plt.title(f"{title}\nMean Squared Error: {mse:.2f}")
        plt.xlabel("Time")
        plt.ylabel("Value")
        plt.legend()
        plt.show()

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']

        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        return predictions

    def forecast(self):
        N = 365  # number of days to predict into the future
        future_predictions = self.predict_future(N)

        # Plot the full data, predictions, and future predictions
        self.plot_data_with_future(self.data, self.test_data, predictions, future_predictions)

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 1))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()

        return predicted_data
129/37:
# Example usage
crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
cp = CryptoPrediction(crypto_symbol)
predictions= cp.predict()
data = cp.data
129/38:
future_predictions = cp.predict_future(window=30)
print(future_predictions)
129/39:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data

    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']

        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 1))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()

        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions = cp.predict()
    data = cp.data

    future_predictions = cp.predict_future(window=30)
    print(future_predictions)
129/40:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data

    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']

        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()

        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions = cp.predict()
    data = cp.data

    future_predictions = cp.predict_future(window=30)
    print(future_predictions)
129/41:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data

    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()

    def predict_next_close(window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array([x[-1]]))

    return next_close_pred

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']

        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions = cp.predict()
    data = cp.data

    future_predictions = cp.predict_future(window=30)
    print(future_predictions)
129/42:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data

    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()

    def predict_next_close(window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array([x[-1]]))

        return next_close_pred

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']

        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions = cp.predict()
    data = cp.data

    future_predictions = cp.predict_future(window=30)
    print(future_predictions)
129/43: cp.predict_next_close
129/44: cp.predict_next_close()
129/45:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data

    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array([x[-1]]))

        return next_close_pred

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']

        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions = cp.predict()
    data = cp.data

    future_predictions = cp.predict_future(window=30)
    print(future_predictions)
129/46: cp.predict_next_close()
129/47:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data

    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array([x))

        return next_close_pred

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']

        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions = cp.predict()
    data = cp.data

    future_predictions = cp.predict_future(window=30)
    print(future_predictions)
129/48:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data

    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']

        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions = cp.predict()
    data = cp.data

    future_predictions = cp.predict_future(window=30)
    print(future_predictions)
129/49: cp.predict_next_close()
129/50:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2020-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data

    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']

        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions = cp.predict()
    data = cp.data

    future_predictions = cp.predict_future(window=30)
    print(future_predictions)
129/51:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data

    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']

        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions = cp.predict()
    data = cp.data

    future_predictions = cp.predict_future(window=30)
    print(future_predictions)
129/52:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data

    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(test_data.index, label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']

        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions = cp.predict()
    data = cp.data

    future_predictions = cp.predict_future(window=30)
    print(future_predictions)
129/53:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data

    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')

        # Creating a secondary y-axis for the error plot
        ax2 = ax1.twinx()  
        error = (test_data['Close'] - predictions) / 100
        ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        ax2.set_ylabel('Error', color='green')  
        ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']

        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions = cp.predict()
    data = cp.data

    future_predictions = cp.predict_future(window=30)
    print(future_predictions)
129/54:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2022-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data

    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')

        # Creating a secondary y-axis for the error plot
        ax2 = ax1.twinx()  
        error = (test_data['Close'] - predictions) / 100
        ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        ax2.set_ylabel('Error', color='green')  
        ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']

        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "ETH-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions = cp.predict()
    data = cp.data

    future_predictions = cp.predict_future(window=30)
    print(future_predictions)
129/55:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2022-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data

    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        ax1.set_xlim(0, 2 * np.pi)
        ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        ax2 = ax1.twinx()  
        error = (test_data['Close'] - predictions) / 100
        ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        ax2.set_ylabel('Error', color='green')  
        ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']

        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "ETH-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions = cp.predict()
    data = cp.data

    future_predictions = cp.predict_future(window=30)
    print(future_predictions)
129/56:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2022-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data

    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(0, 2 * np.pi)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        ax2 = ax1.twinx()  
        error = (test_data['Close'] - predictions) / 100
        ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        ax2.set_ylabel('Error', color='green')  
        ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']

        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "ETH-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions = cp.predict()
    data = cp.data

    future_predictions = cp.predict_future(window=30)
    print(future_predictions)
129/57:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2022-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data

    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        ax1.set_xlim(2023, :)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        ax2 = ax1.twinx()  
        error = (test_data['Close'] - predictions) / 100
        ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        ax2.set_ylabel('Error', color='green')  
        ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']

        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "ETH-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions = cp.predict()
    data = cp.data

    future_predictions = cp.predict_future(window=30)
    print(future_predictions)
129/58:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2022-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data

    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        ax2 = ax1.twinx()  
        error = (test_data['Close'] - predictions) / 100
        ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        ax2.set_ylabel('Error', color='green')  
        ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']

        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "ETH-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions = cp.predict()
    data = cp.data

    future_predictions = cp.predict_future(window=30)
    print(future_predictions)
129/59:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2022-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data

    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        # ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        ax2 = ax1.twinx()  
        error = (test_data['Close'] - predictions) / 100
        ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        ax2.set_ylabel('Error', color='green')  
        ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']

        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "ETH-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions = cp.predict()
    data = cp.data

    future_predictions = cp.predict_future(window=30)
    print(future_predictions)
129/60:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2022-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data

    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        # ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        ax2 = ax1.twinx()  
        error = (test_data['Close'] - predictions) / 100
        ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        ax2.set_ylabel('Error', color='green')  
        ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']

        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "ETH-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions = cp.predict()
    data = cp.data

    future_predictions = cp.predict_future(window=30)
    print(future_predictions)
129/61:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2022-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data

    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        ax2 = ax1.twinx()  
        error = (test_data['Close'] - predictions) / 100
        ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        ax2.set_ylabel('Error', color='green')  
        ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        # Create the sliders and button
        ax_xlim = plt.axes([0.25, 0.05, 0.5, 0.03])
        ax_ylim = plt.axes([0.25, 0.01, 0.5, 0.03])
        slider_xlim = Slider(ax_xlim, 'xlim', 0, 2 * np.pi, valinit=ax.get_xlim())
        slider_ylim = Slider(ax_ylim, 'ylim', -1, 1, valinit=ax.get_ylim())
        reset_button = plt.axes([0.8, 0.025, 0.1, 0.04])
        button = plt.Button(reset_button, 'Reset', hovercolor='0.975')
        
        # Update the plot when the sliders are changed
        def update(val):
            ax.set_xlim(slider_xlim.val)
            ax.set_ylim(slider_ylim.val)
            fig.canvas.draw_idle()
        
        slider_xlim.on_changed(update)
        slider_ylim.on_changed(update)
        
        # Reset the view limits when the button is clicked
        def reset(event):
            slider_xlim.reset()
            slider_ylim.reset()
        
        button.on_clicked(reset)

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']

        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "ETH-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions = cp.predict()
    data = cp.data

    future_predictions = cp.predict_future(window=30)
    print(future_predictions)
129/62:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2022-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data

    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        ax2 = ax1.twinx()  
        error = (test_data['Close'] - predictions) / 100
        ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        ax2.set_ylabel('Error', color='green')  
        ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        # Create the sliders and button
        ax_xlim = plt.axes([0.25, 0.05, 0.5, 0.03])
        ax_ylim = plt.axes([0.25, 0.01, 0.5, 0.03])
        slider_xlim = Slider(ax_xlim, 'xlim', 0, 2 * np.pi, valinit=ax.get_xlim())
        slider_ylim = Slider(ax_ylim, 'ylim', -1, 1, valinit=ax.get_ylim())
        reset_button = plt.axes([0.8, 0.025, 0.1, 0.04])
        button = plt.Button(reset_button, 'Reset', hovercolor='0.975')
        
        # Update the plot when the sliders are changed
        def update(val):
            ax.set_xlim(slider_xlim.val)
            ax.set_ylim(slider_ylim.val)
            fig.canvas.draw_idle()
        
        slider_xlim.on_changed(update)
        slider_ylim.on_changed(update)
        
        # Reset the view limits when the button is clicked
        def reset(event):
            slider_xlim.reset()
            slider_ylim.reset()
        
        button.on_clicked(reset)

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']

        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "ETH-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions = cp.predict()
    data = cp.data

    future_predictions = cp.predict_future(window=30)
    print(future_predictions)
129/63:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2022-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data

    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        ax2 = ax1.twinx()  
        error = (test_data['Close'] - predictions) / 100
        ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        ax2.set_ylabel('Error', color='green')  
        ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        # Create the sliders and button
        ax_xlim = plt.axes([0.25, 0.05, 0.5, 0.03])
        ax_ylim = plt.axes([0.25, 0.01, 0.5, 0.03])
        slider_xlim = Slider(ax_xlim, 'xlim', 0, 2 * np.pi, valinit=ax.get_xlim())
        slider_ylim = Slider(ax_ylim, 'ylim', -1, 1, valinit=ax.get_ylim())
        reset_button = plt.axes([0.8, 0.025, 0.1, 0.04])
        button = plt.Button(reset_button, 'Reset', hovercolor='0.975')
        
        # Update the plot when the sliders are changed
        def update(val):
            ax1.set_xlim(slider_xlim.val)
            ax.1set_ylim(slider_ylim.val)
            fig.canvas.draw_idle()
        
        slider_xlim.on_changed(update)
        slider_ylim.on_changed(update)
        
        # Reset the view limits when the button is clicked
        def reset(event):
            slider_xlim.reset()
            slider_ylim.reset()
        
        button.on_clicked(reset)

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']

        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "ETH-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions = cp.predict()
    data = cp.data

    future_predictions = cp.predict_future(window=30)
    print(future_predictions)
129/64:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2022-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data

    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        ax2 = ax1.twinx()  
        error = (test_data['Close'] - predictions) / 100
        ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        ax2.set_ylabel('Error', color='green')  
        ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        # Create the sliders and button
        ax_xlim = plt.axes([0.25, 0.05, 0.5, 0.03])
        ax_ylim = plt.axes([0.25, 0.01, 0.5, 0.03])
        slider_xlim = Slider(ax_xlim, 'xlim', 0, 2 * np.pi, valinit=ax.get_xlim())
        slider_ylim = Slider(ax_ylim, 'ylim', -1, 1, valinit=ax.get_ylim())
        reset_button = plt.axes([0.8, 0.025, 0.1, 0.04])
        button = plt.Button(reset_button, 'Reset', hovercolor='0.975')
        
        # Update the plot when the sliders are changed
        def update(val):
            ax1.set_xlim(slider_xlim.val)
            ax1.set_ylim(slider_ylim.val)
            fig.canvas.draw_idle()
        
        slider_xlim.on_changed(update)
        slider_ylim.on_changed(update)
        
        # Reset the view limits when the button is clicked
        def reset(event):
            slider_xlim.reset()
            slider_ylim.reset()
        
        button.on_clicked(reset)

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']

        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "ETH-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions = cp.predict()
    data = cp.data

    future_predictions = cp.predict_future(window=30)
    print(future_predictions)
129/65:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2022-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data

    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        ax2 = ax1.twinx()  
        error = (test_data['Close'] - predictions) / 100
        ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        ax2.set_ylabel('Error', color='green')  
        ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        # Create the sliders and button
        ax_xlim = plt.axes([0.25, 0.05, 0.5, 0.03])
        ax_ylim = plt.axes([0.25, 0.01, 0.5, 0.03])
        slider_xlim = Slider(ax_xlim, 'xlim', 0, 2 * np.pi, valinit=ax1.get_xlim())
        slider_ylim = Slider(ax_ylim, 'ylim', -1, 1, valinit=ax1.get_ylim())
        reset_button = plt.axes([0.8, 0.025, 0.1, 0.04])
        button = plt.Button(reset_button, 'Reset', hovercolor='0.975')
        
        # Update the plot when the sliders are changed
        def update(val):
            ax1.set_xlim(slider_xlim.val)
            ax1.set_ylim(slider_ylim.val)
            fig.canvas.draw_idle()
        
        slider_xlim.on_changed(update)
        slider_ylim.on_changed(update)
        
        # Reset the view limits when the button is clicked
        def reset(event):
            slider_xlim.reset()
            slider_ylim.reset()
        
        button.on_clicked(reset)

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']

        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "ETH-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions = cp.predict()
    data = cp.data

    future_predictions = cp.predict_future(window=30)
    print(future_predictions)
129/66:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2022-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data

    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        ax2 = ax1.twinx()  
        error = (test_data['Close'] - predictions) / 100
        ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        ax2.set_ylabel('Error', color='green')  
        ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']

        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "ETH-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions = cp.predict()
    data = cp.data

    future_predictions = cp.predict_future(window=30)
    print(future_predictions)
129/67:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2022-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.2):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data

    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        ax2 = ax1.twinx()  
        error = (test_data['Close'] - predictions) / 100
        ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        ax2.set_ylabel('Error', color='green')  
        ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']

        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "ETH-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions = cp.predict()
    data = cp.data

    future_predictions = cp.predict_future(window=30)
    print(future_predictions)
129/68:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2023-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.2):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data

    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        ax2 = ax1.twinx()  
        error = (test_data['Close'] - predictions) / 100
        ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        ax2.set_ylabel('Error', color='green')  
        ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']

        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "ETC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions = cp.predict()
    data = cp.data

    future_predictions = cp.predict_future(window=30)
    print(future_predictions)
129/69:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2023-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.2):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data

    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']

        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "ETC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions = cp.predict()
    data = cp.data

    future_predictions = cp.predict_future(window=30)
    print(future_predictions)
129/70:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2023-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.5):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data

    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']

        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "ETC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions = cp.predict()
    data = cp.data

    future_predictions = cp.predict_future(window=30)
    print(future_predictions)
129/71:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2023-01-01', '2023-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.5):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data

    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']

        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "ETH-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions = cp.predict()
    data = cp.data

    future_predictions = cp.predict_future(window=30)
    print(future_predictions)
129/72:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        
        self.train_data, self.test_data = self.split_data(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2022-01-01', '2022-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, data, train_ratio=0.5):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]
        return train_data, test_data

    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        X_train = self.train_data[['SMA5', 'SMA20', 'SMA60']]
        y_train = self.train_data['Close']
        X_test = self.test_data[['SMA5', 'SMA20', 'SMA60']]
        y_test = self.test_data['Close']

        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "ETH-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions = cp.predict()
    data = cp.data

    future_predictions = cp.predict_future(window=30)
    print(future_predictions)
129/73:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2022-01-01', '2022-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)
        return data.dropna(inplace=True)
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.5):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        X_train = train_data.drop(columns=[target])
        y_train = train_data.Close_Tomorrow

        X_test = test_data.drop(columns=[target])
        y_test = test_data.Close_Tomorrow
        
        return X_train, y_train, X_test, y_test

    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        X_train, y_train, X_test, y_test = self.split_data(self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "ETH-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions = cp.predict()
    data = cp.data

    future_predictions = cp.predict_future(window=30)
    print(future_predictions)
129/74:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2022-01-01', '2022-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)
        return data.dropna(inplace=True)
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.5):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        X_train = train_data.drop(columns=[target])
        y_train = train_data.Close_Tomorrow

        X_test = test_data.drop(columns=[target])
        y_test = test_data.Close_Tomorrow
        
        return X_train, y_train, X_test, y_test

    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "ETH-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions = cp.predict()
    data = cp.data

    future_predictions = cp.predict_future(window=30)
    print(future_predictions)
129/75:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2022-01-01', '2022-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)
        return data.dropna(inplace=True)
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.5):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        X_train = train_data.drop(columns=[target])
        y_train = train_data.Close_Tomorrow

        X_test = test_data.drop(columns=[target])
        y_test = test_data.Close_Tomorrow
        
        return X_train, y_train, X_test, y_test

    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "ETH-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions = cp.predict()
    data = cp.data

    future_predictions = cp.predict_future(window=30)
    print(future_predictions)
129/76:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        print(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2022-01-01', '2022-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)
        return data.dropna(inplace=True)
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.5):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        X_train = train_data.drop(columns=[target])
        y_train = train_data.Close_Tomorrow

        X_test = test_data.drop(columns=[target])
        y_test = test_data.Close_Tomorrow
        
        return X_train, y_train, X_test, y_test

    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "ETH-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions = cp.predict()
    data = cp.data

    future_predictions = cp.predict_future(window=30)
    print(future_predictions)
129/77:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        print(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2022-01-01', '2022-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)
        return data.dropna(inplace=True)
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.5):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        X_train = train_data.drop(columns=[target])
        y_train = train_data.Close_Tomorrow

        X_test = test_data.drop(columns=[target])
        y_test = test_data.Close_Tomorrow
        
        return X_train, y_train, X_test, y_test

    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "ETC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions = cp.predict()
    data = cp.data

    future_predictions = cp.predict_future(window=30)
    print(future_predictions)
129/78:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        print(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2022-01-01', '2022-12-07')
        print(data)
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)
        return data.dropna(inplace=True)
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.5):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        X_train = train_data.drop(columns=[target])
        y_train = train_data.Close_Tomorrow

        X_test = test_data.drop(columns=[target])
        y_test = test_data.Close_Tomorrow
        
        return X_train, y_train, X_test, y_test

    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "ETC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions = cp.predict()
    data = cp.data

    future_predictions = cp.predict_future(window=30)
    print(future_predictions)
129/79:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        print(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2022-01-01', '2022-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)
        print(data)
        return data.dropna(inplace=True)
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.5):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        X_train = train_data.drop(columns=[target])
        y_train = train_data.Close_Tomorrow

        X_test = test_data.drop(columns=[target])
        y_test = test_data.Close_Tomorrow
        
        return X_train, y_train, X_test, y_test

    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "ETC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions = cp.predict()
    data = cp.data

    future_predictions = cp.predict_future(window=30)
    print(future_predictions)
129/80:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        print(self.data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2022-01-01', '2022-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)
        print(data)
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.5):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        X_train = train_data.drop(columns=[target])
        y_train = train_data.Close_Tomorrow

        X_test = test_data.drop(columns=[target])
        y_test = test_data.Close_Tomorrow
        
        return X_train, y_train, X_test, y_test

    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "ETC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions = cp.predict()
    data = cp.data

    future_predictions = cp.predict_future(window=30)
    print(future_predictions)
129/81:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2022-01-01', '2022-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.5):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[target])
        y_train = train_data.Close_Tomorrow

        X_test = test_data.drop(columns=[target])
        y_test = test_data.Close_Tomorrow
        
        return X_train, y_train, X_test, y_test

    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "ETC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions = cp.predict()
    data = cp.data

    future_predictions = cp.predict_future(window=30)
    print(future_predictions)
129/82:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2022-01-01', '2022-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.5):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[target])
        y_train = train_data.Close_Tomorrow

        X_test = test_data.drop(columns=[target])
        y_test = test_data.Close_Tomorrow
        
        return X_train, y_train, X_test, y_test

    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "ETC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions = cp.predict()
    data = cp.data

    # future_predictions = cp.predict_future(window=30)
    # print(future_predictions)
129/83:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2022-01-01', '2022-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.5):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[target])
        y_train = train_data.Close_Tomorrow

        X_test = test_data.drop(columns=[target])
        y_test = test_data.Close_Tomorrow
        
        return X_train, y_train, X_test, y_test

    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions = cp.predict()
    data = cp.data

    # future_predictions = cp.predict_future(window=30)
    # print(future_predictions)
129/84:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2022-05-01', '2022-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.5):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[target])
        y_train = train_data.Close_Tomorrow

        X_test = test_data.drop(columns=[target])
        y_test = test_data.Close_Tomorrow
        
        return X_train, y_train, X_test, y_test

    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions = cp.predict()
    data = cp.data

    # future_predictions = cp.predict_future(window=30)
    # print(future_predictions)
129/85:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2020-05-01', '2022-12-07')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.5):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[target])
        y_train = train_data.Close_Tomorrow

        X_test = test_data.drop(columns=[target])
        y_test = test_data.Close_Tomorrow
        
        return X_train, y_train, X_test, y_test

    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions = cp.predict()
    data = cp.data

    # future_predictions = cp.predict_future(window=30)
    # print(future_predictions)
129/86:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2020-05-01', '2022-12-07')
        return data

    def add_features(self, data, window=10):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.5, window_size=10):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(window=10):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data, window_size=window)
        models = []
        for i in range(window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        # Visualize the predictions
        for i in range(window_size):
            plt.figure(figsize=(10, 5))
            plt.title(f"Day {i+1} Prediction")
            plt.plot(y_test.index, y_test[f'Close_{i+1}'], label='Actual')
            plt.plot(y_test.index, y_preds[i], label='Predicted', linestyle='--')
            plt.legend()
            plt.xlabel('Date')
            plt.ylabel('Closing Price')
            plt.grid(True)
            plt.show()

    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions = cp.predict_windows()
    data = cp.data

    # future_predictions = cp.predict_future(window=30)
    # print(future_predictions)
129/87:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2020-05-01', '2022-12-07')
        return data

    def add_features(self, data, window=10):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.5, window_size=10):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(window_size=10):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data, window_size=window_size)
        models = []
        for i in range(window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        # Visualize the predictions
        for i in range(window_size):
            plt.figure(figsize=(10, 5))
            plt.title(f"Day {i+1} Prediction")
            plt.plot(y_test.index, y_test[f'Close_{i+1}'], label='Actual')
            plt.plot(y_test.index, y_preds[i], label='Predicted', linestyle='--')
            plt.legend()
            plt.xlabel('Date')
            plt.ylabel('Closing Price')
            plt.grid(True)
            plt.show()

    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions = cp.predict_windows()
    data = cp.data

    # future_predictions = cp.predict_future(window=30)
    # print(future_predictions)
129/88:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2020-05-01', '2022-12-07')
        return data

    def add_features(self, data, window=10):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.5, window_size=10):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(window_size=10):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data, window_size=window_size)
        models = []
        for i in range(window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        # Visualize the predictions
        for i in range(window_size):
            plt.figure(figsize=(10, 5))
            plt.title(f"Day {i+1} Prediction")
            plt.plot(y_test.index, y_test[f'Close_{i+1}'], label='Actual')
            plt.plot(y_test.index, y_preds[i], label='Predicted', linestyle='--')
            plt.legend()
            plt.xlabel('Date')
            plt.ylabel('Closing Price')
            plt.grid(True)
            plt.show()

    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions = cp.predict_windows()
    data = cp.data

    # future_predictions = cp.predict_future(window=30)
    # print(future_predictions)
129/89:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2020-05-01', '2022-12-07')
        return data

    def add_features(self, data, window=10):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.5, window_size=10):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(window_size=10):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data, window_size=window_size)
        models = []
        for i in range(window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        # Visualize the predictions
        for i in range(window_size):
            plt.figure(figsize=(10, 5))
            plt.title(f"Day {i+1} Prediction")
            plt.plot(y_test.index, y_test[f'Close_{i+1}'], label='Actual')
            plt.plot(y_test.index, y_preds[i], label='Predicted', linestyle='--')
            plt.legend()
            plt.xlabel('Date')
            plt.ylabel('Closing Price')
            plt.grid(True)
            plt.show()

    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions = cp.predict_windows()
    data = cp.data

    # future_predictions = cp.predict_future(window=30)
    # print(future_predictions)
129/90:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2020-05-01', '2022-12-07')
        return data

    def add_features(self, data, window_size=10):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.5, window_size=10):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(window_size=10):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data, window_size=window_size)
        models = []
        for i in range(window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        # Visualize the predictions
        for i in range(window_size):
            plt.figure(figsize=(10, 5))
            plt.title(f"Day {i+1} Prediction")
            plt.plot(y_test.index, y_test[f'Close_{i+1}'], label='Actual')
            plt.plot(y_test.index, y_preds[i], label='Predicted', linestyle='--')
            plt.legend()
            plt.xlabel('Date')
            plt.ylabel('Closing Price')
            plt.grid(True)
            plt.show()

    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions = cp.predict_windows()
    data = cp.data

    # future_predictions = cp.predict_future(window=30)
    # print(future_predictions)
129/91:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2020-05-01', '2022-12-07')
        return data

    def add_features(self, data, window_size=10):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.5, window_size=10):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=10):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data, window_size=window_size)
        models = []
        for i in range(window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        # Visualize the predictions
        for i in range(window_size):
            plt.figure(figsize=(10, 5))
            plt.title(f"Day {i+1} Prediction")
            plt.plot(y_test.index, y_test[f'Close_{i+1}'], label='Actual')
            plt.plot(y_test.index, y_preds[i], label='Predicted', linestyle='--')
            plt.legend()
            plt.xlabel('Date')
            plt.ylabel('Closing Price')
            plt.grid(True)
            plt.show()

    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions = cp.predict_windows()
    data = cp.data

    # future_predictions = cp.predict_future(window=30)
    # print(future_predictions)
129/92:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2020-05-01', '2022-12-07')
        return data

    def add_features(self, data, window_size=10):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.5, window_size=10):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=10):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data, window_size=window_size)
        models = []
        for i in range(window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        # Visualize the predictions
        # for i in range(window_size):
        #     plt.figure(figsize=(10, 5))
        #     plt.title(f"Day {i+1} Prediction")
        #     plt.plot(y_test.index, y_test[f'Close_{i+1}'], label='Actual')
        #     plt.plot(y_test.index, y_preds[i], label='Predicted', linestyle='--')
        #     plt.legend()
        #     plt.xlabel('Date')
        #     plt.ylabel('Closing Price')
        #     plt.grid(True)
        #     plt.show()

        # Create a single plot to visualize all predictions and the true closing prices
        plt.figure(figsize=(12, 6))
        plt.title('Predicted vs. True Closing Prices for Each Day in the Window')
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        
        # Plot the true closing prices
        for i in range(window_size):
            plt.plot(y_test.index, y_test[f'Close_{i+1}'], label=f'Day {i+1} True', linestyle='-', alpha=0.7)
        
        # Plot the corresponding predictions
        for i in range(window_size):
            plt.plot(y_test.index, y_preds[i], label=f'Day {i+1} Predicted', linestyle='--', alpha=0.7)
        
        plt.legend()
        plt.show()
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions = cp.predict_windows()
    data = cp.data

    # future_predictions = cp.predict_future(window=30)
    # print(future_predictions)
129/93:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2022-05-01', '2022-12-07')
        return data

    def add_features(self, data, window_size=10):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.5, window_size=10):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=10):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data, window_size=window_size)
        models = []
        for i in range(window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        # Visualize the predictions
        # for i in range(window_size):
        #     plt.figure(figsize=(10, 5))
        #     plt.title(f"Day {i+1} Prediction")
        #     plt.plot(y_test.index, y_test[f'Close_{i+1}'], label='Actual')
        #     plt.plot(y_test.index, y_preds[i], label='Predicted', linestyle='--')
        #     plt.legend()
        #     plt.xlabel('Date')
        #     plt.ylabel('Closing Price')
        #     plt.grid(True)
        #     plt.show()

        # Create a single plot to visualize all predictions and the true closing prices
        plt.figure(figsize=(12, 6))
        plt.title('Predicted vs. True Closing Prices for Each Day in the Window')
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        
        # Plot the true closing prices
        for i in range(window_size):
            plt.plot(y_test.index, y_test[f'Close_{i+1}'], label=f'Day {i+1} True', linestyle='-', alpha=0.7)
        
        # Plot the corresponding predictions
        for i in range(window_size):
            plt.plot(y_test.index, y_preds[i], label=f'Day {i+1} Predicted', linestyle='--', alpha=0.7)
        
        plt.legend()
        plt.show()
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions = cp.predict_windows()
    data = cp.data

    # future_predictions = cp.predict_future(window=30)
    # print(future_predictions)
129/94:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2022-05-01', '2022-12-07')
        return data

    def add_features(self, data, window_size=10):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.5, window_size=10):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=10):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data, window_size=window_size)
        models = []
        for i in range(window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        # Visualize the predictions
        # for i in range(window_size):
        #     plt.figure(figsize=(10, 5))
        #     plt.title(f"Day {i+1} Prediction")
        #     plt.plot(y_test.index, y_test[f'Close_{i+1}'], label='Actual')
        #     plt.plot(y_test.index, y_preds[i], label='Predicted', linestyle='--')
        #     plt.legend()
        #     plt.xlabel('Date')
        #     plt.ylabel('Closing Price')
        #     plt.grid(True)
        #     plt.show()

        # Create a single plot to visualize all predictions and the true closing prices
        plt.figure(figsize=(12, 6))
        plt.title('Predicted vs. True Closing Prices for Each Day in the Window')
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        
        # Plot the true closing prices
        for i in range(window_size):
            plt.plot(y_test.index, y_test[f'Close_{i+1}'], label=f'Day {i+1} True', linestyle='-', alpha=0.7)
            break
        
        # Plot the corresponding predictions
        for i in range(window_size):
            plt.plot(y_test.index, y_preds[i], label=f'Day {i+1} Predicted', linestyle='--', alpha=0.7)
        
        plt.legend()
        plt.show()
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions = cp.predict_windows()
    data = cp.data

    # future_predictions = cp.predict_future(window=30)
    # print(future_predictions)
129/95:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2022-05-01', '2022-12-07')
        return data

    def add_features(self, data, window_size=10):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.5, window_size=10):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=10):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data, window_size=window_size)
        models = []
        for i in range(window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        # Visualize the predictions
        # for i in range(window_size):
        #     plt.figure(figsize=(10, 5))
        #     plt.title(f"Day {i+1} Prediction")
        #     plt.plot(y_test.index, y_test[f'Close_{i+1}'], label='Actual')
        #     plt.plot(y_test.index, y_preds[i], label='Predicted', linestyle='--')
        #     plt.legend()
        #     plt.xlabel('Date')
        #     plt.ylabel('Closing Price')
        #     plt.grid(True)
        #     plt.show()

        # Create a single plot to visualize all predictions and the true closing prices
        plt.figure(figsize=(12, 6))
        plt.title('Predicted vs. True Closing Prices for Each Day in the Window')
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        
        # Plot the true closing prices
        for i in range(window_size):
            plt.plot(y_test.index, y_test[f'Close_{i+1}'], label=f'Day {i+1} True', alpha=1)
            break
        
        # Plot the corresponding predictions
        for i in range(window_size):
            plt.plot(y_test.index, y_preds[i], label=f'Day {i+1} Predicted', linestyle='--', alpha=0.7)
        
        plt.legend()
        plt.show()
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions = cp.predict_windows()
    data = cp.data

    # future_predictions = cp.predict_future(window=30)
    # print(future_predictions)
129/96:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2022-05-01', '2022-12-07')
        return data

    def add_features(self, data, window_size=10):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.5, window_size=10):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=10):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data, window_size=window_size)
        models = []
        for i in range(window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        # Visualize the predictions
        # for i in range(window_size):
        #     plt.figure(figsize=(10, 5))
        #     plt.title(f"Day {i+1} Prediction")
        #     plt.plot(y_test.index, y_test[f'Close_{i+1}'], label='Actual')
        #     plt.plot(y_test.index, y_preds[i], label='Predicted', linestyle='--')
        #     plt.legend()
        #     plt.xlabel('Date')
        #     plt.ylabel('Closing Price')
        #     plt.grid(True)
        #     plt.show()

        # Create a single plot to visualize all predictions and the true closing prices
        plt.figure(figsize=(12, 6))
        plt.title('Predicted vs. True Closing Prices for Each Day in the Window')
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        
        # Plot the true closing prices
        for i in range(window_size):
            plt.plot(y_test.index, y_test[f'Close_{i+1}'], label=f'Day {i+1} True', alpha=1)
            # break
        
        # Plot the corresponding predictions
        for i in range(window_size):
            plt.plot(y_test.index, y_preds[i], label=f'Day {i+1} Predicted', linestyle='--', alpha=0.7)
        
        plt.legend()
        plt.show()
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions = cp.predict_windows()
    data = cp.data

    # future_predictions = cp.predict_future(window=30)
    # print(future_predictions)
129/97:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2022-05-01', '2022-12-07')
        return data

    def add_features(self, data, window_size=10):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.5, window_size=10):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=10):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data, window_size=window_size)
        models = []
        for i in range(window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        # Visualize the predictions
        # for i in range(window_size):
        #     plt.figure(figsize=(10, 5))
        #     plt.title(f"Day {i+1} Prediction")
        #     plt.plot(y_test.index, y_test[f'Close_{i+1}'], label='Actual')
        #     plt.plot(y_test.index, y_preds[i], label='Predicted', linestyle='--')
        #     plt.legend()
        #     plt.xlabel('Date')
        #     plt.ylabel('Closing Price')
        #     plt.grid(True)
        #     plt.show()

        # Create a single plot to visualize all predictions and the true closing prices
        plt.figure(figsize=(12, 6))
        plt.title('Predicted vs. True Closing Prices for Each Day in the Window')
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        
        # Plot the true closing prices
        for i in range(window_size):
            plt.plot(y_test.index, y_test[f'Close_{i+1}'], label=f'Day {i+1} True', alpha=1)
            break
        
        # Plot the corresponding predictions
        for i in range(window_size):
            plt.plot(y_test.index, y_preds[i], label=f'Day {i+1} Predicted', linestyle='--', alpha=0.4)
        
        plt.legend()
        plt.show()
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions = cp.predict_windows()
    data = cp.data

    # future_predictions = cp.predict_future(window=30)
    # print(future_predictions)
129/98:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2022-05-01', '2022-12-07')
        return data

    def add_features(self, data, window_size=10):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.5, window_size=10):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=10):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data, window_size=window_size)
        models = []
        for i in range(window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        # Visualize the predictions
        # for i in range(window_size):
        #     plt.figure(figsize=(10, 5))
        #     plt.title(f"Day {i+1} Prediction")
        #     plt.plot(y_test.index, y_test[f'Close_{i+1}'], label='Actual')
        #     plt.plot(y_test.index, y_preds[i], label='Predicted', linestyle='--')
        #     plt.legend()
        #     plt.xlabel('Date')
        #     plt.ylabel('Closing Price')
        #     plt.grid(True)
        #     plt.show()

        # Create a single plot to visualize all predictions and the true closing prices
        plt.figure(figsize=(12, 6))
        plt.title('Predicted vs. True Closing Prices for Each Day in the Window')
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        
        # Plot the true closing prices
        for i in range(window_size):
            plt.plot(y_test.index, y_test[f'Close_{i+1}'], label=f'Day {i+1} True', alpha=1)
            break
        
        # Plot the corresponding predictions
        for i in range(window_size):
            plt.plot(y_test.index, y_preds[i], label=f'Day {i+1} Predicted', linestyle='--', alpha=0.6)
        
        plt.legend()
        plt.show()
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions = cp.predict_windows()
    data = cp.data

    # future_predictions = cp.predict_future(window=30)
    # print(future_predictions)
129/99:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2022-05-01', '2022-12-08')
        return data

    def add_features(self, data, window_size=10):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.5, window_size=10):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=10):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data, window_size=window_size)
        models = []
        for i in range(window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        # Visualize the predictions
        # for i in range(window_size):
        #     plt.figure(figsize=(10, 5))
        #     plt.title(f"Day {i+1} Prediction")
        #     plt.plot(y_test.index, y_test[f'Close_{i+1}'], label='Actual')
        #     plt.plot(y_test.index, y_preds[i], label='Predicted', linestyle='--')
        #     plt.legend()
        #     plt.xlabel('Date')
        #     plt.ylabel('Closing Price')
        #     plt.grid(True)
        #     plt.show()

        # Create a single plot to visualize all predictions and the true closing prices
        plt.figure(figsize=(12, 6))
        plt.title('Predicted vs. True Closing Prices for Each Day in the Window')
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        
        # Plot the true closing prices
        for i in range(window_size):
            plt.plot(y_test.index, y_test[f'Close_{i+1}'], label=f'Day {i+1} True', alpha=1)
            break
        
        # Plot the corresponding predictions
        for i in range(window_size):
            plt.plot(y_test.index, y_preds[i], label=f'Day {i+1} Predicted', linestyle='--', alpha=0.6)
        
        plt.legend()
        plt.show()
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions = cp.predict_windows()
    data = cp.data

    # future_predictions = cp.predict_future(window=30)
    # print(future_predictions)
129/100:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2022-05-01', '2023-12-08')
        return data

    def add_features(self, data, window_size=10):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.5, window_size=10):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=10):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data, window_size=window_size)
        models = []
        for i in range(window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        # Visualize the predictions
        # for i in range(window_size):
        #     plt.figure(figsize=(10, 5))
        #     plt.title(f"Day {i+1} Prediction")
        #     plt.plot(y_test.index, y_test[f'Close_{i+1}'], label='Actual')
        #     plt.plot(y_test.index, y_preds[i], label='Predicted', linestyle='--')
        #     plt.legend()
        #     plt.xlabel('Date')
        #     plt.ylabel('Closing Price')
        #     plt.grid(True)
        #     plt.show()

        # Create a single plot to visualize all predictions and the true closing prices
        plt.figure(figsize=(12, 6))
        plt.title('Predicted vs. True Closing Prices for Each Day in the Window')
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        
        # Plot the true closing prices
        for i in range(window_size):
            plt.plot(y_test.index, y_test[f'Close_{i+1}'], label=f'Day {i+1} True', alpha=1)
            break
        
        # Plot the corresponding predictions
        for i in range(window_size):
            plt.plot(y_test.index, y_preds[i], label=f'Day {i+1} Predicted', linestyle='--', alpha=0.6)
        
        plt.legend()
        plt.show()
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions = cp.predict_windows()
    data = cp.data

    # future_predictions = cp.predict_future(window=30)
    # print(future_predictions)
129/101:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2023-05-01', '2023-12-08')
        return data

    def add_features(self, data, window_size=10):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.5, window_size=10):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=10):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data, window_size=window_size)
        models = []
        for i in range(window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        # Visualize the predictions
        # for i in range(window_size):
        #     plt.figure(figsize=(10, 5))
        #     plt.title(f"Day {i+1} Prediction")
        #     plt.plot(y_test.index, y_test[f'Close_{i+1}'], label='Actual')
        #     plt.plot(y_test.index, y_preds[i], label='Predicted', linestyle='--')
        #     plt.legend()
        #     plt.xlabel('Date')
        #     plt.ylabel('Closing Price')
        #     plt.grid(True)
        #     plt.show()

        # Create a single plot to visualize all predictions and the true closing prices
        plt.figure(figsize=(12, 6))
        plt.title('Predicted vs. True Closing Prices for Each Day in the Window')
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        
        # Plot the true closing prices
        for i in range(window_size):
            plt.plot(y_test.index, y_test[f'Close_{i+1}'], label=f'Day {i+1} True', alpha=1)
            break
        
        # Plot the corresponding predictions
        for i in range(window_size):
            plt.plot(y_test.index, y_preds[i], label=f'Day {i+1} Predicted', linestyle='--', alpha=0.6)
        
        plt.legend()
        plt.show()
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions = cp.predict_windows()
    data = cp.data

    # future_predictions = cp.predict_future(window=30)
    # print(future_predictions)
129/102:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2022-05-01', '2023-12-08')
        return data

    def add_features(self, data, window_size=10):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.5, window_size=10):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=10):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data, window_size=window_size)
        models = []
        for i in range(window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        # Visualize the predictions
        # for i in range(window_size):
        #     plt.figure(figsize=(10, 5))
        #     plt.title(f"Day {i+1} Prediction")
        #     plt.plot(y_test.index, y_test[f'Close_{i+1}'], label='Actual')
        #     plt.plot(y_test.index, y_preds[i], label='Predicted', linestyle='--')
        #     plt.legend()
        #     plt.xlabel('Date')
        #     plt.ylabel('Closing Price')
        #     plt.grid(True)
        #     plt.show()

        # Create a single plot to visualize all predictions and the true closing prices
        plt.figure(figsize=(12, 6))
        plt.title('Predicted vs. True Closing Prices for Each Day in the Window')
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        
        # Plot the true closing prices
        for i in range(window_size):
            plt.plot(y_test.index, y_test[f'Close_{i+1}'], label=f'Day {i+1} True', alpha=1)
            break
        
        # Plot the corresponding predictions
        for i in range(window_size):
            plt.plot(y_test.index, y_preds[i], label=f'Day {i+1} Predicted', linestyle='--', alpha=0.6)
        
        plt.legend()
        plt.show()
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions = cp.predict_windows()
    data = cp.data

    # future_predictions = cp.predict_future(window=30)
    # print(future_predictions)
129/103:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-05-01', '2023-12-08')
        return data

    def add_features(self, data, window_size=10):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.5, window_size=10):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=10):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data, window_size=window_size)
        models = []
        for i in range(window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        # Visualize the predictions
        # for i in range(window_size):
        #     plt.figure(figsize=(10, 5))
        #     plt.title(f"Day {i+1} Prediction")
        #     plt.plot(y_test.index, y_test[f'Close_{i+1}'], label='Actual')
        #     plt.plot(y_test.index, y_preds[i], label='Predicted', linestyle='--')
        #     plt.legend()
        #     plt.xlabel('Date')
        #     plt.ylabel('Closing Price')
        #     plt.grid(True)
        #     plt.show()

        # Create a single plot to visualize all predictions and the true closing prices
        plt.figure(figsize=(12, 6))
        plt.title('Predicted vs. True Closing Prices for Each Day in the Window')
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        
        # Plot the true closing prices
        for i in range(window_size):
            plt.plot(y_test.index, y_test[f'Close_{i+1}'], label=f'Day {i+1} True', alpha=1)
            break
        
        # Plot the corresponding predictions
        for i in range(window_size):
            plt.plot(y_test.index, y_preds[i], label=f'Day {i+1} Predicted', linestyle='--', alpha=0.6)
        
        plt.legend()
        plt.show()
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions = cp.predict_windows()
    data = cp.data

    # future_predictions = cp.predict_future(window=30)
    # print(future_predictions)
129/104:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-05-01', '2023-12-08')
        return data

    def add_features(self, data, window_size=10):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.5, window_size=10):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data, window_size=window_size)
        models = []
        for i in range(window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        # Visualize the predictions
        # for i in range(window_size):
        #     plt.figure(figsize=(10, 5))
        #     plt.title(f"Day {i+1} Prediction")
        #     plt.plot(y_test.index, y_test[f'Close_{i+1}'], label='Actual')
        #     plt.plot(y_test.index, y_preds[i], label='Predicted', linestyle='--')
        #     plt.legend()
        #     plt.xlabel('Date')
        #     plt.ylabel('Closing Price')
        #     plt.grid(True)
        #     plt.show()

        # Create a single plot to visualize all predictions and the true closing prices
        plt.figure(figsize=(12, 6))
        plt.title('Predicted vs. True Closing Prices for Each Day in the Window')
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        
        # Plot the true closing prices
        for i in range(window_size):
            plt.plot(y_test.index, y_test[f'Close_{i+1}'], label=f'Day {i+1} True', alpha=1)
            break
        
        # Plot the corresponding predictions
        for i in range(window_size):
            plt.plot(y_test.index, y_preds[i], label=f'Day {i+1} Predicted', linestyle='--', alpha=0.6)
        
        plt.legend()
        plt.show()
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions = cp.predict_windows()
    data = cp.data

    # future_predictions = cp.predict_future(window=30)
    # print(future_predictions)
129/105:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-05-01', '2023-12-08')
        return data

    def add_features(self, data, window_size=10):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.5, window_size=30):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data, window_size=window_size)
        models = []
        for i in range(window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        # Visualize the predictions
        # for i in range(window_size):
        #     plt.figure(figsize=(10, 5))
        #     plt.title(f"Day {i+1} Prediction")
        #     plt.plot(y_test.index, y_test[f'Close_{i+1}'], label='Actual')
        #     plt.plot(y_test.index, y_preds[i], label='Predicted', linestyle='--')
        #     plt.legend()
        #     plt.xlabel('Date')
        #     plt.ylabel('Closing Price')
        #     plt.grid(True)
        #     plt.show()

        # Create a single plot to visualize all predictions and the true closing prices
        plt.figure(figsize=(12, 6))
        plt.title('Predicted vs. True Closing Prices for Each Day in the Window')
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        
        # Plot the true closing prices
        for i in range(window_size):
            plt.plot(y_test.index, y_test[f'Close_{i+1}'], label=f'Day {i+1} True', alpha=1)
            break
        
        # Plot the corresponding predictions
        for i in range(window_size):
            plt.plot(y_test.index, y_preds[i], label=f'Day {i+1} Predicted', linestyle='--', alpha=0.6)
        
        plt.legend()
        plt.show()
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions = cp.predict_windows()
    data = cp.data

    # future_predictions = cp.predict_future(window=30)
    # print(future_predictions)
129/106:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-05-01', '2023-12-08')
        return data

    def add_features(self, data, window_size=10):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.5, window_size=30):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        print(train_data.columns)
        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data, window_size=window_size)
        models = []
        for i in range(window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        # Visualize the predictions
        # for i in range(window_size):
        #     plt.figure(figsize=(10, 5))
        #     plt.title(f"Day {i+1} Prediction")
        #     plt.plot(y_test.index, y_test[f'Close_{i+1}'], label='Actual')
        #     plt.plot(y_test.index, y_preds[i], label='Predicted', linestyle='--')
        #     plt.legend()
        #     plt.xlabel('Date')
        #     plt.ylabel('Closing Price')
        #     plt.grid(True)
        #     plt.show()

        # Create a single plot to visualize all predictions and the true closing prices
        plt.figure(figsize=(12, 6))
        plt.title('Predicted vs. True Closing Prices for Each Day in the Window')
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        
        # Plot the true closing prices
        for i in range(window_size):
            plt.plot(y_test.index, y_test[f'Close_{i+1}'], label=f'Day {i+1} True', alpha=1)
            break
        
        # Plot the corresponding predictions
        for i in range(window_size):
            plt.plot(y_test.index, y_preds[i], label=f'Day {i+1} Predicted', linestyle='--', alpha=0.6)
        
        plt.legend()
        plt.show()
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions = cp.predict_windows()
    data = cp.data

    # future_predictions = cp.predict_future(window=30)
    # print(future_predictions)
129/107:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-05-01', '2023-12-08')
        return data

    def add_features(self, data, window_size=10):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.5, window_size=30):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        print(train_data.columns, window_size)
        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data, window_size=window_size)
        models = []
        for i in range(window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        # Visualize the predictions
        # for i in range(window_size):
        #     plt.figure(figsize=(10, 5))
        #     plt.title(f"Day {i+1} Prediction")
        #     plt.plot(y_test.index, y_test[f'Close_{i+1}'], label='Actual')
        #     plt.plot(y_test.index, y_preds[i], label='Predicted', linestyle='--')
        #     plt.legend()
        #     plt.xlabel('Date')
        #     plt.ylabel('Closing Price')
        #     plt.grid(True)
        #     plt.show()

        # Create a single plot to visualize all predictions and the true closing prices
        plt.figure(figsize=(12, 6))
        plt.title('Predicted vs. True Closing Prices for Each Day in the Window')
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        
        # Plot the true closing prices
        for i in range(window_size):
            plt.plot(y_test.index, y_test[f'Close_{i+1}'], label=f'Day {i+1} True', alpha=1)
            break
        
        # Plot the corresponding predictions
        for i in range(window_size):
            plt.plot(y_test.index, y_preds[i], label=f'Day {i+1} Predicted', linestyle='--', alpha=0.6)
        
        plt.legend()
        plt.show()
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions = cp.predict_windows()
    data = cp.data

    # future_predictions = cp.predict_future(window=30)
    # print(future_predictions)
129/108:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        self.window_size = window_size

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-05-01', '2023-12-08')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.5, window_size=30):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        print(train_data.columns, window_size)
        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data, window_size=window_size)
        models = []
        for i in range(window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        # Visualize the predictions
        # for i in range(window_size):
        #     plt.figure(figsize=(10, 5))
        #     plt.title(f"Day {i+1} Prediction")
        #     plt.plot(y_test.index, y_test[f'Close_{i+1}'], label='Actual')
        #     plt.plot(y_test.index, y_preds[i], label='Predicted', linestyle='--')
        #     plt.legend()
        #     plt.xlabel('Date')
        #     plt.ylabel('Closing Price')
        #     plt.grid(True)
        #     plt.show()

        # Create a single plot to visualize all predictions and the true closing prices
        plt.figure(figsize=(12, 6))
        plt.title('Predicted vs. True Closing Prices for Each Day in the Window')
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        
        # Plot the true closing prices
        for i in range(window_size):
            plt.plot(y_test.index, y_test[f'Close_{i+1}'], label=f'Day {i+1} True', alpha=1)
            break
        
        # Plot the corresponding predictions
        for i in range(window_size):
            plt.plot(y_test.index, y_preds[i], label=f'Day {i+1} Predicted', linestyle='--', alpha=0.6)
        
        plt.legend()
        plt.show()
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions = cp.predict_windows()
    data = cp.data

    # future_predictions = cp.predict_future(window=30)
    # print(future_predictions)
129/109:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        self.window_size = window_size

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-05-01', '2023-12-08')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.5, window_size=30):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        print(train_data.columns, window_size)
        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data, window_size=window_size)
        models = []
        for i in range(window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        # Visualize the predictions
        # for i in range(window_size):
        #     plt.figure(figsize=(10, 5))
        #     plt.title(f"Day {i+1} Prediction")
        #     plt.plot(y_test.index, y_test[f'Close_{i+1}'], label='Actual')
        #     plt.plot(y_test.index, y_preds[i], label='Predicted', linestyle='--')
        #     plt.legend()
        #     plt.xlabel('Date')
        #     plt.ylabel('Closing Price')
        #     plt.grid(True)
        #     plt.show()

        # Create a single plot to visualize all predictions and the true closing prices
        plt.figure(figsize=(12, 6))
        plt.title('Predicted vs. True Closing Prices for Each Day in the Window')
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        
        # Plot the true closing prices
        for i in range(window_size):
            plt.plot(y_test.index, y_test[f'Close_{i+1}'], label=f'Day {i+1} True', alpha=1)
            break
        
        # Plot the corresponding predictions
        for i in range(window_size):
            plt.plot(y_test.index, y_preds[i], label=f'Day {i+1} Predicted', linestyle='--', alpha=0.6)
        
        plt.legend()
        plt.show()
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol)
    predictions = cp.predict_windows()
    data = cp.data

    # future_predictions = cp.predict_future(window=30)
    # print(future_predictions)
129/110:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        self.window_size = window_size

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-05-01', '2023-12-08')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.5, window_size=30):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        print(train_data.columns, window_size)
        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data, window_size=window_size)
        models = []
        for i in range(window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        # Visualize the predictions
        # for i in range(window_size):
        #     plt.figure(figsize=(10, 5))
        #     plt.title(f"Day {i+1} Prediction")
        #     plt.plot(y_test.index, y_test[f'Close_{i+1}'], label='Actual')
        #     plt.plot(y_test.index, y_preds[i], label='Predicted', linestyle='--')
        #     plt.legend()
        #     plt.xlabel('Date')
        #     plt.ylabel('Closing Price')
        #     plt.grid(True)
        #     plt.show()

        # Create a single plot to visualize all predictions and the true closing prices
        plt.figure(figsize=(12, 6))
        plt.title('Predicted vs. True Closing Prices for Each Day in the Window')
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        
        # Plot the true closing prices
        for i in range(window_size):
            plt.plot(y_test.index, y_test[f'Close_{i+1}'], label=f'Day {i+1} True', alpha=1)
            break
        
        # Plot the corresponding predictions
        for i in range(window_size):
            plt.plot(y_test.index, y_preds[i], label=f'Day {i+1} Predicted', linestyle='--', alpha=0.6)
        
        plt.legend()
        plt.show()
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol, 30)
    predictions = cp.predict_windows()
    data = cp.data

    # future_predictions = cp.predict_future(window=30)
    # print(future_predictions)
129/111:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        self.window_size = window_size

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-05-01', '2023-12-08')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.5, window_size=30):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        print(train_data.columns, window_size)
        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data, window_size=window_size)
        models = []
        for i in range(window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        # Visualize the predictions
        # for i in range(window_size):
        #     plt.figure(figsize=(10, 5))
        #     plt.title(f"Day {i+1} Prediction")
        #     plt.plot(y_test.index, y_test[f'Close_{i+1}'], label='Actual')
        #     plt.plot(y_test.index, y_preds[i], label='Predicted', linestyle='--')
        #     plt.legend()
        #     plt.xlabel('Date')
        #     plt.ylabel('Closing Price')
        #     plt.grid(True)
        #     plt.show()

        # Create a single plot to visualize all predictions and the true closing prices
        plt.figure(figsize=(12, 6))
        plt.title('Predicted vs. True Closing Prices for Each Day in the Window')
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        
        # Plot the true closing prices
        for i in range(window_size):
            plt.plot(y_test.index, y_test[f'Close_{i+1}'], label=f'Day {i+1} True', alpha=1)
            break
        
        # Plot the corresponding predictions
        for i in range(window_size):
            plt.plot(y_test.index, y_preds[i], label=f'Day {i+1} Predicted', linestyle='--', alpha=0.6)
        
        plt.legend()
        plt.show()
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol, 30)
    predictions = cp.predict_windows()
    data = cp.data

    # future_predictions = cp.predict_future(window=30)
    # print(future_predictions)
132/1:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        self.window_size = window_size

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-05-01', '2023-12-08')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.5, window_size=30):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        print(train_data.columns, window_size)
        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data, window_size=window_size)
        models = []
        for i in range(window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        # Visualize the predictions
        # for i in range(window_size):
        #     plt.figure(figsize=(10, 5))
        #     plt.title(f"Day {i+1} Prediction")
        #     plt.plot(y_test.index, y_test[f'Close_{i+1}'], label='Actual')
        #     plt.plot(y_test.index, y_preds[i], label='Predicted', linestyle='--')
        #     plt.legend()
        #     plt.xlabel('Date')
        #     plt.ylabel('Closing Price')
        #     plt.grid(True)
        #     plt.show()

        # Create a single plot to visualize all predictions and the true closing prices
        plt.figure(figsize=(12, 6))
        plt.title('Predicted vs. True Closing Prices for Each Day in the Window')
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        
        # Plot the true closing prices
        for i in range(window_size):
            plt.plot(y_test.index, y_test[f'Close_{i+1}'], label=f'Day {i+1} True', alpha=1)
            break
        
        # Plot the corresponding predictions
        for i in range(window_size):
            plt.plot(y_test.index, y_preds[i], label=f'Day {i+1} Predicted', linestyle='--', alpha=0.6)
        
        plt.legend()
        plt.show()
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol, 30)
    predictions = cp.predict_windows()
    data = cp.data

    # future_predictions = cp.predict_future(window=30)
    # print(future_predictions)
132/2:
import pandas as pd
import yfinance as yf
import numpy as np
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
132/3:
def download_data(ticker, start_date, end_date):
    data = yf.download(ticker, start=start_date, end=end_date, progress=False)
    data.drop(['Adj Close'], axis=1, inplace=True)
    return data

btc_data = download_data('BTC-USD', '2018-01-01', '2023-12-07')
ada_data = download_data('ADA-USD', '2018-01-01', '2023-12-07')
132/4:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        self.window_size = window_size

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-05-01', '2023-12-08')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.5, window_size=30):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        print(train_data.columns, window_size)
        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data, window_size=window_size)
        models = []
        for i in range(window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        # Visualize the predictions
        # for i in range(window_size):
        #     plt.figure(figsize=(10, 5))
        #     plt.title(f"Day {i+1} Prediction")
        #     plt.plot(y_test.index, y_test[f'Close_{i+1}'], label='Actual')
        #     plt.plot(y_test.index, y_preds[i], label='Predicted', linestyle='--')
        #     plt.legend()
        #     plt.xlabel('Date')
        #     plt.ylabel('Closing Price')
        #     plt.grid(True)
        #     plt.show()

        # Create a single plot to visualize all predictions and the true closing prices
        plt.figure(figsize=(12, 6))
        plt.title('Predicted vs. True Closing Prices for Each Day in the Window')
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        
        # Plot the true closing prices
        for i in range(window_size):
            plt.plot(y_test.index, y_test[f'Close_{i+1}'], label=f'Day {i+1} True', alpha=1)
            break
        
        # Plot the corresponding predictions
        for i in range(window_size):
            plt.plot(y_test.index, y_preds[i], label=f'Day {i+1} Predicted', linestyle='--', alpha=0.6)
        
        plt.legend()
        plt.show()
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol, 30)
    predictions = cp.predict_windows()
    data = cp.data

    # future_predictions = cp.predict_future(window=30)
    # print(future_predictions)
132/5:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.data = self.add_features(data)
        self.window_size = window_size
        print(self.window_size)

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-05-01', '2023-12-08')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.5, window_size=30):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        print(train_data.columns, window_size)
        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data, window_size=window_size)
        models = []
        for i in range(window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        # Visualize the predictions
        # for i in range(window_size):
        #     plt.figure(figsize=(10, 5))
        #     plt.title(f"Day {i+1} Prediction")
        #     plt.plot(y_test.index, y_test[f'Close_{i+1}'], label='Actual')
        #     plt.plot(y_test.index, y_preds[i], label='Predicted', linestyle='--')
        #     plt.legend()
        #     plt.xlabel('Date')
        #     plt.ylabel('Closing Price')
        #     plt.grid(True)
        #     plt.show()

        # Create a single plot to visualize all predictions and the true closing prices
        plt.figure(figsize=(12, 6))
        plt.title('Predicted vs. True Closing Prices for Each Day in the Window')
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        
        # Plot the true closing prices
        for i in range(window_size):
            plt.plot(y_test.index, y_test[f'Close_{i+1}'], label=f'Day {i+1} True', alpha=1)
            break
        
        # Plot the corresponding predictions
        for i in range(window_size):
            plt.plot(y_test.index, y_preds[i], label=f'Day {i+1} Predicted', linestyle='--', alpha=0.6)
        
        plt.legend()
        plt.show()
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol, 30)
    predictions = cp.predict_windows()
    data = cp.data

    # future_predictions = cp.predict_future(window=30)
    # print(future_predictions)
132/6:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.window_size = window_size
        self.data = self.add_features(data)
        
       

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-05-01', '2023-12-08')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.5, window_size=30):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        print(train_data.columns, window_size)
        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data, window_size=window_size)
        models = []
        for i in range(window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        # Visualize the predictions
        # for i in range(window_size):
        #     plt.figure(figsize=(10, 5))
        #     plt.title(f"Day {i+1} Prediction")
        #     plt.plot(y_test.index, y_test[f'Close_{i+1}'], label='Actual')
        #     plt.plot(y_test.index, y_preds[i], label='Predicted', linestyle='--')
        #     plt.legend()
        #     plt.xlabel('Date')
        #     plt.ylabel('Closing Price')
        #     plt.grid(True)
        #     plt.show()

        # Create a single plot to visualize all predictions and the true closing prices
        plt.figure(figsize=(12, 6))
        plt.title('Predicted vs. True Closing Prices for Each Day in the Window')
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        
        # Plot the true closing prices
        for i in range(window_size):
            plt.plot(y_test.index, y_test[f'Close_{i+1}'], label=f'Day {i+1} True', alpha=1)
            break
        
        # Plot the corresponding predictions
        for i in range(window_size):
            plt.plot(y_test.index, y_preds[i], label=f'Day {i+1} Predicted', linestyle='--', alpha=0.6)
        
        plt.legend()
        plt.show()
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol, 30)
    predictions = cp.predict_windows()
    data = cp.data

    # future_predictions = cp.predict_future(window=30)
    # print(future_predictions)
132/7:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.window_size = window_size
        self.data = self.add_features(data)
        
       

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-05-01', '2023-12-08')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.5, window_size=30):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        print(train_data.columns, window_size)
        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data, window_size=window_size)
        models = []
        for i in range(window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        # Visualize the predictions
        # for i in range(window_size):
        #     plt.figure(figsize=(10, 5))
        #     plt.title(f"Day {i+1} Prediction")
        #     plt.plot(y_test.index, y_test[f'Close_{i+1}'], label='Actual')
        #     plt.plot(y_test.index, y_preds[i], label='Predicted', linestyle='--')
        #     plt.legend()
        #     plt.xlabel('Date')
        #     plt.ylabel('Closing Price')
        #     plt.grid(True)
        #     plt.show()

        # Create a single plot to visualize all predictions and the true closing prices
        plt.figure(figsize=(12, 6))
        plt.title('Predicted vs. True Closing Prices for Each Day in the Window')
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        
        # Plot the true closing prices
        # for i in range(window_size):
        #     plt.plot(y_test.index, y_test[f'Close_{i+1}'], label=f'Day {i+1} True', alpha=1)
        #     break
        
        # # Plot the corresponding predictions
        # for i in range(window_size):
        #     plt.plot(y_test.index, y_preds[i], label=f'Day {i+1} Predicted', linestyle='--', alpha=0.6)
        start_index = 100  # Replace with your desired starting index
        end_index = 200    # Replace with your desired ending index
        
        # Create separate plots for the true closing prices and predictions for each day in the window
        for i in range(window_size):
            plt.figure(figsize=(12, 6))
            plt.title(f'Day {i+1} - True vs. Predicted Closing Prices')
            plt.xlabel('Date')
            plt.ylabel('Closing Price')
            plt.grid(True)
        
            # Plot the true closing prices for the specific range
            plt.plot(y_test.index[start_index:end_index], y_test[f'Close_{i+1}'].iloc[start_index:end_index], label='True', linestyle='-')
        
            # Plot the corresponding predictions for the specific range
            plt.plot(y_test.index[start_index:end_index], y_preds[i][start_index:end_index], label='Predicted', linestyle='--')

   
        plt.legend()
        plt.show()
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol, 30)
    predictions = cp.predict_windows()
    data = cp.data

    # future_predictions = cp.predict_future(window=30)
    # print(future_predictions)
132/8:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.window_size = window_size
        self.data = self.add_features(data)
        
       

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-05-01', '2023-12-08')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.5, window_size=30):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        print(train_data.columns, window_size)
        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data, window_size=window_size)
        models = []
        for i in range(window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        # Visualize the predictions
        # for i in range(window_size):
        #     plt.figure(figsize=(10, 5))
        #     plt.title(f"Day {i+1} Prediction")
        #     plt.plot(y_test.index, y_test[f'Close_{i+1}'], label='Actual')
        #     plt.plot(y_test.index, y_preds[i], label='Predicted', linestyle='--')
        #     plt.legend()
        #     plt.xlabel('Date')
        #     plt.ylabel('Closing Price')
        #     plt.grid(True)
        #     plt.show()

        # Create a single plot to visualize all predictions and the true closing prices
        plt.figure(figsize=(12, 6))
        plt.title('Predicted vs. True Closing Prices for Each Day in the Window')
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        
        # Plot the true closing prices
        # for i in range(window_size):
        #     plt.plot(y_test.index, y_test[f'Close_{i+1}'], label=f'Day {i+1} True', alpha=1)
        #     break
        
        # # Plot the corresponding predictions
        # for i in range(window_size):
        #     plt.plot(y_test.index, y_preds[i], label=f'Day {i+1} Predicted', linestyle='--', alpha=0.6)
        start_index = 100  # Replace with your desired starting index
        end_index = 200    # Replace with your desired ending index
        
        # Create separate plots for the true closing prices and predictions for each day in the window
        for i in range(window_size):
            # plt.figure(figsize=(12, 6))
            # plt.title(f'Day {i+1} - True vs. Predicted Closing Prices')
            # plt.xlabel('Date')
            # plt.ylabel('Closing Price')
            # plt.grid(True)
        
            # Plot the true closing prices for the specific range
            plt.plot(y_test.index[start_index:end_index], y_test[f'Close_{i+1}'].iloc[start_index:end_index], label='True', linestyle='-')
        
            # Plot the corresponding predictions for the specific range
            plt.plot(y_test.index[start_index:end_index], y_preds[i][start_index:end_index], label='Predicted', linestyle='--')

   
        plt.legend()
        plt.show()
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol, 30)
    predictions = cp.predict_windows()
    data = cp.data

    # future_predictions = cp.predict_future(window=30)
    # print(future_predictions)
132/9:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.window_size = window_size
        self.data = self.add_features(data)
        
       

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-05-01', '2023-12-08')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.5, window_size=30):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        print(train_data.columns, window_size)
        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data, window_size=window_size)
        models = []
        for i in range(window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        # Visualize the predictions
        # for i in range(window_size):
        #     plt.figure(figsize=(10, 5))
        #     plt.title(f"Day {i+1} Prediction")
        #     plt.plot(y_test.index, y_test[f'Close_{i+1}'], label='Actual')
        #     plt.plot(y_test.index, y_preds[i], label='Predicted', linestyle='--')
        #     plt.legend()
        #     plt.xlabel('Date')
        #     plt.ylabel('Closing Price')
        #     plt.grid(True)
        #     plt.show()

        # Create a single plot to visualize all predictions and the true closing prices
        plt.figure(figsize=(12, 6))
        plt.title('Predicted vs. True Closing Prices for Each Day in the Window')
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        
        # Plot the true closing prices
        # for i in range(window_size):
        #     plt.plot(y_test.index, y_test[f'Close_{i+1}'], label=f'Day {i+1} True', alpha=1)
        #     break
        
        # # Plot the corresponding predictions
        # for i in range(window_size):
        #     plt.plot(y_test.index, y_preds[i], label=f'Day {i+1} Predicted', linestyle='--', alpha=0.6)
        start_index = 100  # Replace with your desired starting index
        end_index = 200    # Replace with your desired ending index
        
        # Create separate plots for the true closing prices and predictions for each day in the window
        for i in range(window_size):
            # plt.figure(figsize=(12, 6))
            # plt.title(f'Day {i+1} - True vs. Predicted Closing Prices')
            # plt.xlabel('Date')
            # plt.ylabel('Closing Price')
            # plt.grid(True)
        
            # Plot the true closing prices for the specific range
            plt.plot(y_test.index[start_index:end_index], y_test[f'Close_{i+1}'].iloc[start_index:end_index], label='True', linestyle='-')
        
            # Plot the corresponding predictions for the specific range
            plt.plot(y_test.index[start_index:end_index], y_preds[i][start_index:end_index], label='Predicted', linestyle='--')

   
        plt.legend()
        plt.show()
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol, 10)
    predictions = cp.predict_windows()
    data = cp.data

    # future_predictions = cp.predict_future(window=30)
    # print(future_predictions)
132/10:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.window_size = window_size
        self.data = self.add_features(data)
        
       

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-05-01', '2023-12-08')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.5):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        # Visualize the predictions
        # for i in range(window_size):
        #     plt.figure(figsize=(10, 5))
        #     plt.title(f"Day {i+1} Prediction")
        #     plt.plot(y_test.index, y_test[f'Close_{i+1}'], label='Actual')
        #     plt.plot(y_test.index, y_preds[i], label='Predicted', linestyle='--')
        #     plt.legend()
        #     plt.xlabel('Date')
        #     plt.ylabel('Closing Price')
        #     plt.grid(True)
        #     plt.show()

        # Create a single plot to visualize all predictions and the true closing prices
        plt.figure(figsize=(12, 6))
        plt.title('Predicted vs. True Closing Prices for Each Day in the Window')
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        
        # Plot the true closing prices
        # for i in range(window_size):
        #     plt.plot(y_test.index, y_test[f'Close_{i+1}'], label=f'Day {i+1} True', alpha=1)
        #     break
        
        # # Plot the corresponding predictions
        # for i in range(window_size):
        #     plt.plot(y_test.index, y_preds[i], label=f'Day {i+1} Predicted', linestyle='--', alpha=0.6)
        start_index = 100  # Replace with your desired starting index
        end_index = 200    # Replace with your desired ending index
        
        # Create separate plots for the true closing prices and predictions for each day in the window
        for i in range(self.window_size):
            # plt.figure(figsize=(12, 6))
            # plt.title(f'Day {i+1} - True vs. Predicted Closing Prices')
            # plt.xlabel('Date')
            # plt.ylabel('Closing Price')
            # plt.grid(True)
        
            # Plot the true closing prices for the specific range
            plt.plot(y_test.index[start_index:end_index], y_test[f'Close_{i+1}'].iloc[start_index:end_index], label='True', linestyle='-')
        
            # Plot the corresponding predictions for the specific range
            plt.plot(y_test.index[start_index:end_index], y_preds[i][start_index:end_index], label='Predicted', linestyle='--')

   
        plt.legend()
        plt.show()
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol, 10)
    predictions = cp.predict_windows()
    data = cp.data

    # future_predictions = cp.predict_future(window=30)
    # print(future_predictions)
132/11:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.window_size = window_size
        self.data = self.add_features(data)
        
       

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-05-01', '2023-12-08')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.5):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        # Visualize the predictions
        # for i in range(window_size):
        #     plt.figure(figsize=(10, 5))
        #     plt.title(f"Day {i+1} Prediction")
        #     plt.plot(y_test.index, y_test[f'Close_{i+1}'], label='Actual')
        #     plt.plot(y_test.index, y_preds[i], label='Predicted', linestyle='--')
        #     plt.legend()
        #     plt.xlabel('Date')
        #     plt.ylabel('Closing Price')
        #     plt.grid(True)
        #     plt.show()

        # Create a single plot to visualize all predictions and the true closing prices
        plt.figure(figsize=(12, 6))
        plt.title('Predicted vs. True Closing Prices for Each Day in the Window')
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        
        # Plot the true closing prices
        # for i in range(window_size):
        #     plt.plot(y_test.index, y_test[f'Close_{i+1}'], label=f'Day {i+1} True', alpha=1)
        #     break
        
        # # Plot the corresponding predictions
        # for i in range(window_size):
        #     plt.plot(y_test.index, y_preds[i], label=f'Day {i+1} Predicted', linestyle='--', alpha=0.6)
        start_index = 100  # Replace with your desired starting index
        end_index = 200    # Replace with your desired ending index
        
        # Create separate plots for the true closing prices and predictions for each day in the window
        for i in range(self.window_size):
            # plt.figure(figsize=(12, 6))
            # plt.title(f'Day {i+1} - True vs. Predicted Closing Prices')
            # plt.xlabel('Date')
            # plt.ylabel('Closing Price')
            # plt.grid(True)
        
            # Plot the true closing prices for the specific range
            plt.plot(y_test.index[start_index:end_index], y_test[f'Close_{i+1}'].iloc[start_index:end_index], label='True', linestyle='-')
        
            # Plot the corresponding predictions for the specific range
            plt.plot(y_test.index[start_index:end_index], y_preds[i][start_index:end_index], label='Predicted', linestyle='--')

   
        plt.legend()
        plt.show()
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol, 10)
    predictions = cp.predict_windows()
    data = cp.data

    # future_predictions = cp.predict_future(window=30)
    # print(future_predictions)
132/12:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.window_size = window_size
        self.data = self.add_features(data)
        
       

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-05-01', '2023-12-08')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.5):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        # Visualize the predictions
        # for i in range(window_size):
        #     plt.figure(figsize=(10, 5))
        #     plt.title(f"Day {i+1} Prediction")
        #     plt.plot(y_test.index, y_test[f'Close_{i+1}'], label='Actual')
        #     plt.plot(y_test.index, y_preds[i], label='Predicted', linestyle='--')
        #     plt.legend()
        #     plt.xlabel('Date')
        #     plt.ylabel('Closing Price')
        #     plt.grid(True)
        #     plt.show()

        # Create a single plot to visualize all predictions and the true closing prices
        plt.figure(figsize=(12, 6))
        plt.title('Predicted vs. True Closing Prices for Each Day in the Window')
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        
        # Plot the true closing prices
        # for i in range(window_size):
        #     plt.plot(y_test.index, y_test[f'Close_{i+1}'], label=f'Day {i+1} True', alpha=1)
        #     break
        
        # # Plot the corresponding predictions
        # for i in range(window_size):
        #     plt.plot(y_test.index, y_preds[i], label=f'Day {i+1} Predicted', linestyle='--', alpha=0.6)
        start_index = 100  # Replace with your desired starting index
        end_index = 200    # Replace with your desired ending index
        
        # Create separate plots for the true closing prices and predictions for each day in the window
        for i in range(self.window_size):
            # plt.figure(figsize=(12, 6))
            # plt.title(f'Day {i+1} - True vs. Predicted Closing Prices')
            # plt.xlabel('Date')
            # plt.ylabel('Closing Price')
            # plt.grid(True)
        
            # Plot the true closing prices for the specific range
            if i == 0:
                plt.plot(y_test.index[start_index:end_index], y_test[f'Close_{i+1}'].iloc[start_index:end_index], label='True', linestyle='-')
        
            # Plot the corresponding predictions for the specific range
            plt.plot(y_test.index[start_index:end_index], y_preds[i][start_index:end_index], label='Predicted', linestyle='--')

   
        plt.legend()
        plt.show()
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol, 10)
    predictions = cp.predict_windows()
    data = cp.data

    # future_predictions = cp.predict_future(window=30)
    # print(future_predictions)
132/13:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.window_size = window_size
        self.data = self.add_features(data)
        
       

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-05-01', '2023-12-08')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.5):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        # Visualize the predictions
        # for i in range(window_size):
        #     plt.figure(figsize=(10, 5))
        #     plt.title(f"Day {i+1} Prediction")
        #     plt.plot(y_test.index, y_test[f'Close_{i+1}'], label='Actual')
        #     plt.plot(y_test.index, y_preds[i], label='Predicted', linestyle='--')
        #     plt.legend()
        #     plt.xlabel('Date')
        #     plt.ylabel('Closing Price')
        #     plt.grid(True)
        #     plt.show()

        # Create a single plot to visualize all predictions and the true closing prices
        plt.figure(figsize=(12, 6))
        plt.title('Predicted vs. True Closing Prices for Each Day in the Window')
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        
        # Plot the true closing prices
        # for i in range(window_size):
        #     plt.plot(y_test.index, y_test[f'Close_{i+1}'], label=f'Day {i+1} True', alpha=1)
        #     break
        
        # # Plot the corresponding predictions
        # for i in range(window_size):
        #     plt.plot(y_test.index, y_preds[i], label=f'Day {i+1} Predicted', linestyle='--', alpha=0.6)
        start_index = -300  # Replace with your desired starting index
        end_index = -1    # Replace with your desired ending index
        
        # Create separate plots for the true closing prices and predictions for each day in the window
        for i in range(self.window_size):
            # plt.figure(figsize=(12, 6))
            # plt.title(f'Day {i+1} - True vs. Predicted Closing Prices')
            # plt.xlabel('Date')
            # plt.ylabel('Closing Price')
            # plt.grid(True)
        
            # Plot the true closing prices for the specific range
            if i == 0:
                plt.plot(y_test.index[start_index:end_index], y_test[f'Close_{i+1}'].iloc[start_index:end_index], label='True', linestyle='-')
        
            # Plot the corresponding predictions for the specific range
            plt.plot(y_test.index[start_index:end_index], y_preds[i][start_index:end_index], label='Predicted', linestyle='--')

   
        plt.legend()
        plt.show()
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol, 10)
    predictions = cp.predict_windows()
    data = cp.data

    # future_predictions = cp.predict_future(window=30)
    # print(future_predictions)
132/14:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.window_size = window_size
        self.data = self.add_features(data)
        
       

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-05-01', '2023-12-08')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.5):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        # Visualize the predictions
        # for i in range(window_size):
        #     plt.figure(figsize=(10, 5))
        #     plt.title(f"Day {i+1} Prediction")
        #     plt.plot(y_test.index, y_test[f'Close_{i+1}'], label='Actual')
        #     plt.plot(y_test.index, y_preds[i], label='Predicted', linestyle='--')
        #     plt.legend()
        #     plt.xlabel('Date')
        #     plt.ylabel('Closing Price')
        #     plt.grid(True)
        #     plt.show()

        # Create a single plot to visualize all predictions and the true closing prices
        plt.figure(figsize=(12, 6))
        plt.title('Predicted vs. True Closing Prices for Each Day in the Window')
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        
        # Plot the true closing prices
        # for i in range(window_size):
        #     plt.plot(y_test.index, y_test[f'Close_{i+1}'], label=f'Day {i+1} True', alpha=1)
        #     break
        
        # # Plot the corresponding predictions
        # for i in range(window_size):
        #     plt.plot(y_test.index, y_preds[i], label=f'Day {i+1} Predicted', linestyle='--', alpha=0.6)
        start_index = -00  # Replace with your desired starting index
        end_index = -1    # Replace with your desired ending index
        
        # Create separate plots for the true closing prices and predictions for each day in the window
        for i in range(self.window_size):
            # plt.figure(figsize=(12, 6))
            # plt.title(f'Day {i+1} - True vs. Predicted Closing Prices')
            # plt.xlabel('Date')
            # plt.ylabel('Closing Price')
            # plt.grid(True)
        
            # Plot the true closing prices for the specific range
            if i == 0:
                plt.plot(y_test.index[start_index:end_index], y_test[f'Close_{i+1}'].iloc[start_index:end_index], label='True', linestyle='-')
        
            # Plot the corresponding predictions for the specific range
            plt.plot(y_test.index[start_index:end_index], y_preds[i][start_index:end_index], label='Predicted', linestyle='--')

   
        plt.legend()
        plt.show()
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol, 10)
    predictions = cp.predict_windows()
    data = cp.data

    # future_predictions = cp.predict_future(window=30)
    # print(future_predictions)
132/15:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.window_size = window_size
        self.data = self.add_features(data)
        
       

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-05-01', '2023-12-08')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.5):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        # Visualize the predictions
        # for i in range(window_size):
        #     plt.figure(figsize=(10, 5))
        #     plt.title(f"Day {i+1} Prediction")
        #     plt.plot(y_test.index, y_test[f'Close_{i+1}'], label='Actual')
        #     plt.plot(y_test.index, y_preds[i], label='Predicted', linestyle='--')
        #     plt.legend()
        #     plt.xlabel('Date')
        #     plt.ylabel('Closing Price')
        #     plt.grid(True)
        #     plt.show()

        # Create a single plot to visualize all predictions and the true closing prices
        plt.figure(figsize=(12, 6))
        plt.title('Predicted vs. True Closing Prices for Each Day in the Window')
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        
        # Plot the true closing prices
        # for i in range(window_size):
        #     plt.plot(y_test.index, y_test[f'Close_{i+1}'], label=f'Day {i+1} True', alpha=1)
        #     break
        
        # # Plot the corresponding predictions
        # for i in range(window_size):
        #     plt.plot(y_test.index, y_preds[i], label=f'Day {i+1} Predicted', linestyle='--', alpha=0.6)
        start_index = -10  # Replace with your desired starting index
        end_index = -1    # Replace with your desired ending index
        
        # Create separate plots for the true closing prices and predictions for each day in the window
        for i in range(self.window_size):
            # plt.figure(figsize=(12, 6))
            # plt.title(f'Day {i+1} - True vs. Predicted Closing Prices')
            # plt.xlabel('Date')
            # plt.ylabel('Closing Price')
            # plt.grid(True)
        
            # Plot the true closing prices for the specific range
            if i == 0:
                plt.plot(y_test.index[start_index:end_index], y_test[f'Close_{i+1}'].iloc[start_index:end_index], label='True', linestyle='-')
        
            # Plot the corresponding predictions for the specific range
            plt.plot(y_test.index[start_index:end_index], y_preds[i][start_index:end_index], label='Predicted', linestyle='--')

   
        plt.legend()
        plt.show()
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol, 10)
    predictions = cp.predict_windows()
    data = cp.data

    # future_predictions = cp.predict_future(window=30)
    # print(future_predictions)
132/16:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.window_size = window_size
        self.data = self.add_features(data)
        
       

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-05-01', '2023-12-08')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.5):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        # Visualize the predictions
        # for i in range(window_size):
        #     plt.figure(figsize=(10, 5))
        #     plt.title(f"Day {i+1} Prediction")
        #     plt.plot(y_test.index, y_test[f'Close_{i+1}'], label='Actual')
        #     plt.plot(y_test.index, y_preds[i], label='Predicted', linestyle='--')
        #     plt.legend()
        #     plt.xlabel('Date')
        #     plt.ylabel('Closing Price')
        #     plt.grid(True)
        #     plt.show()

        # Create a single plot to visualize all predictions and the true closing prices
        plt.figure(figsize=(12, 6))
        plt.title('Predicted vs. True Closing Prices for Each Day in the Window')
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        
        # Plot the true closing prices
        # for i in range(window_size):
        #     plt.plot(y_test.index, y_test[f'Close_{i+1}'], label=f'Day {i+1} True', alpha=1)
        #     break
        
        # # Plot the corresponding predictions
        # for i in range(window_size):
        #     plt.plot(y_test.index, y_preds[i], label=f'Day {i+1} Predicted', linestyle='--', alpha=0.6)
        start_index = -50  # Replace with your desired starting index
        end_index = -1    # Replace with your desired ending index
        
        # Create separate plots for the true closing prices and predictions for each day in the window
        for i in range(self.window_size):
            # plt.figure(figsize=(12, 6))
            # plt.title(f'Day {i+1} - True vs. Predicted Closing Prices')
            # plt.xlabel('Date')
            # plt.ylabel('Closing Price')
            # plt.grid(True)
        
            # Plot the true closing prices for the specific range
            if i == 0:
                plt.plot(y_test.index[start_index:end_index], y_test[f'Close_{i+1}'].iloc[start_index:end_index], label='True', linestyle='-')
        
            # Plot the corresponding predictions for the specific range
            plt.plot(y_test.index[start_index:end_index], y_preds[i][start_index:end_index], label='Predicted', linestyle='--')

   
        plt.legend()
        plt.show()
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol, 10)
    predictions = cp.predict_windows()
    data = cp.data

    # future_predictions = cp.predict_future(window=30)
    # print(future_predictions)
132/17:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.window_size = window_size
        self.data = self.add_features(data)
        
       

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-05-01', '2023-12-08')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.5):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        # Visualize the predictions
        # for i in range(window_size):
        #     plt.figure(figsize=(10, 5))
        #     plt.title(f"Day {i+1} Prediction")
        #     plt.plot(y_test.index, y_test[f'Close_{i+1}'], label='Actual')
        #     plt.plot(y_test.index, y_preds[i], label='Predicted', linestyle='--')
        #     plt.legend()
        #     plt.xlabel('Date')
        #     plt.ylabel('Closing Price')
        #     plt.grid(True)
        #     plt.show()

        # Create a single plot to visualize all predictions and the true closing prices
        plt.figure(figsize=(12, 6))
        plt.title('Predicted vs. True Closing Prices for Each Day in the Window')
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        
        # Plot the true closing prices
        # for i in range(window_size):
        #     plt.plot(y_test.index, y_test[f'Close_{i+1}'], label=f'Day {i+1} True', alpha=1)
        #     break
        
        # # Plot the corresponding predictions
        # for i in range(window_size):
        #     plt.plot(y_test.index, y_preds[i], label=f'Day {i+1} Predicted', linestyle='--', alpha=0.6)
        start_index = -50  # Replace with your desired starting index
        end_index = -1    # Replace with your desired ending index
        
        # Create separate plots for the true closing prices and predictions for each day in the window
        for i in range(self.window_size):
            # plt.figure(figsize=(12, 6))
            # plt.title(f'Day {i+1} - True vs. Predicted Closing Prices')
            # plt.xlabel('Date')
            # plt.ylabel('Closing Price')
            # plt.grid(True)
        
            # Plot the true closing prices for the specific range
            if i == 0:
                plt.plot(y_test.index[start_index:end_index], y_test[f'Close_{i+1}'].iloc[start_index:end_index], label='True', linestyle='-')
        
            # Plot the corresponding predictions for the specific range
            plt.plot(y_test.index[start_index:end_index], y_preds[i][start_index:end_index], label='Predicted', linestyle='--')

   
        plt.legend()
        plt.show()
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol, 30)
    predictions = cp.predict_windows()
    data = cp.data

    # future_predictions = cp.predict_future(window=30)
    # print(future_predictions)
132/18:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.window_size = window_size
        self.data = self.add_features(data)
        
       

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-05-01', '2023-12-08')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.5):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        # Visualize the predictions
        # for i in range(window_size):
        #     plt.figure(figsize=(10, 5))
        #     plt.title(f"Day {i+1} Prediction")
        #     plt.plot(y_test.index, y_test[f'Close_{i+1}'], label='Actual')
        #     plt.plot(y_test.index, y_preds[i], label='Predicted', linestyle='--')
        #     plt.legend()
        #     plt.xlabel('Date')
        #     plt.ylabel('Closing Price')
        #     plt.grid(True)
        #     plt.show()

        # Create a single plot to visualize all predictions and the true closing prices
        plt.figure(figsize=(12, 6))
        plt.title('Predicted vs. True Closing Prices for Each Day in the Window')
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        
        # Plot the true closing prices
        # for i in range(window_size):
        #     plt.plot(y_test.index, y_test[f'Close_{i+1}'], label=f'Day {i+1} True', alpha=1)
        #     break
        
        # # Plot the corresponding predictions
        # for i in range(window_size):
        #     plt.plot(y_test.index, y_preds[i], label=f'Day {i+1} Predicted', linestyle='--', alpha=0.6)
        start_index = -50  # Replace with your desired starting index
        end_index = -1    # Replace with your desired ending index
        
        # Create separate plots for the true closing prices and predictions for each day in the window
        for i in range(self.window_size):
            # plt.figure(figsize=(12, 6))
            # plt.title(f'Day {i+1} - True vs. Predicted Closing Prices')
            # plt.xlabel('Date')
            # plt.ylabel('Closing Price')
            # plt.grid(True)
        
            # Plot the true closing prices for the specific range
            if i == 0:
                plt.plot(y_test.index[start_index:end_index], y_test[f'Close_{i+1}'].iloc[start_index:end_index], label='True', linestyle='-')
        
            # Plot the corresponding predictions for the specific range
            plt.plot(y_test.index[start_index:end_index], y_preds[i][start_index:end_index], label='Predicted', linestyle='--')

   
        plt.legend()
        plt.show()
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol, 10)
    predictions = cp.predict_windows()
    data = cp.data

    # future_predictions = cp.predict_future(window=30)
    # print(future_predictions)
132/19:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.window_size = window_size
        self.data = self.add_features(data)
        
       

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-05-01', '2023-12-08')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        # Visualize the predictions
        # for i in range(window_size):
        #     plt.figure(figsize=(10, 5))
        #     plt.title(f"Day {i+1} Prediction")
        #     plt.plot(y_test.index, y_test[f'Close_{i+1}'], label='Actual')
        #     plt.plot(y_test.index, y_preds[i], label='Predicted', linestyle='--')
        #     plt.legend()
        #     plt.xlabel('Date')
        #     plt.ylabel('Closing Price')
        #     plt.grid(True)
        #     plt.show()

        # Create a single plot to visualize all predictions and the true closing prices
        plt.figure(figsize=(12, 6))
        plt.title('Predicted vs. True Closing Prices for Each Day in the Window')
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        
        # Plot the true closing prices
        # for i in range(window_size):
        #     plt.plot(y_test.index, y_test[f'Close_{i+1}'], label=f'Day {i+1} True', alpha=1)
        #     break
        
        # # Plot the corresponding predictions
        # for i in range(window_size):
        #     plt.plot(y_test.index, y_preds[i], label=f'Day {i+1} Predicted', linestyle='--', alpha=0.6)
        start_index = -50  # Replace with your desired starting index
        end_index = -1    # Replace with your desired ending index
        
        # Create separate plots for the true closing prices and predictions for each day in the window
        for i in range(self.window_size):
            # plt.figure(figsize=(12, 6))
            # plt.title(f'Day {i+1} - True vs. Predicted Closing Prices')
            # plt.xlabel('Date')
            # plt.ylabel('Closing Price')
            # plt.grid(True)
        
            # Plot the true closing prices for the specific range
            if i == 0:
                plt.plot(y_test.index[start_index:end_index], y_test[f'Close_{i+1}'].iloc[start_index:end_index], label='True', linestyle='-')
        
            # Plot the corresponding predictions for the specific range
            plt.plot(y_test.index[start_index:end_index], y_preds[i][start_index:end_index], label='Predicted', linestyle='--')

   
        plt.legend()
        plt.show()
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol, 10)
    predictions = cp.predict_windows()
    data = cp.data

    # future_predictions = cp.predict_future(window=30)
    # print(future_predictions)
132/20:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.window_size = window_size
        self.data = self.add_features(data)
        
       

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-05-01', '2023-12-08')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        # Visualize the predictions
        # for i in range(window_size):
        #     plt.figure(figsize=(10, 5))
        #     plt.title(f"Day {i+1} Prediction")
        #     plt.plot(y_test.index, y_test[f'Close_{i+1}'], label='Actual')
        #     plt.plot(y_test.index, y_preds[i], label='Predicted', linestyle='--')
        #     plt.legend()
        #     plt.xlabel('Date')
        #     plt.ylabel('Closing Price')
        #     plt.grid(True)
        #     plt.show()

        # Create a single plot to visualize all predictions and the true closing prices
        plt.figure(figsize=(12, 6))
        plt.title('Predicted vs. True Closing Prices for Each Day in the Window')
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        
        # Plot the true closing prices
        # for i in range(window_size):
        #     plt.plot(y_test.index, y_test[f'Close_{i+1}'], label=f'Day {i+1} True', alpha=1)
        #     break
        
        # # Plot the corresponding predictions
        # for i in range(window_size):
        #     plt.plot(y_test.index, y_preds[i], label=f'Day {i+1} Predicted', linestyle='--', alpha=0.6)
        start_index = -20  # Replace with your desired starting index
        end_index = -1    # Replace with your desired ending index
        
        # Create separate plots for the true closing prices and predictions for each day in the window
        for i in range(self.window_size):
            # plt.figure(figsize=(12, 6))
            # plt.title(f'Day {i+1} - True vs. Predicted Closing Prices')
            # plt.xlabel('Date')
            # plt.ylabel('Closing Price')
            # plt.grid(True)
        
            # Plot the true closing prices for the specific range
            if i == 0:
                plt.plot(y_test.index[start_index:end_index], y_test[f'Close_{i+1}'].iloc[start_index:end_index], label='True', linestyle='-')
        
            # Plot the corresponding predictions for the specific range
            plt.plot(y_test.index[start_index:end_index], y_preds[i][start_index:end_index], label='Predicted', linestyle='--')

   
        plt.legend()
        plt.show()
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol, 10)
    predictions = cp.predict_windows()
    data = cp.data

    # future_predictions = cp.predict_future(window=30)
    # print(future_predictions)
132/21:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.window_size = window_size
        self.data = self.add_features(data)
        
       

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-05-01', '2023-12-08')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        # Visualize the predictions
        # for i in range(window_size):
        #     plt.figure(figsize=(10, 5))
        #     plt.title(f"Day {i+1} Prediction")
        #     plt.plot(y_test.index, y_test[f'Close_{i+1}'], label='Actual')
        #     plt.plot(y_test.index, y_preds[i], label='Predicted', linestyle='--')
        #     plt.legend()
        #     plt.xlabel('Date')
        #     plt.ylabel('Closing Price')
        #     plt.grid(True)
        #     plt.show()

        # Create a single plot to visualize all predictions and the true closing prices
        plt.figure(figsize=(12, 6))
        plt.title('Predicted vs. True Closing Prices for Each Day in the Window')
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        
        # Plot the true closing prices
        # for i in range(window_size):
        #     plt.plot(y_test.index, y_test[f'Close_{i+1}'], label=f'Day {i+1} True', alpha=1)
        #     break
        
        # # Plot the corresponding predictions
        # for i in range(window_size):
        #     plt.plot(y_test.index, y_preds[i], label=f'Day {i+1} Predicted', linestyle='--', alpha=0.6)
        start_index = -50  # Replace with your desired starting index
        end_index = -1    # Replace with your desired ending index
        
        # Create separate plots for the true closing prices and predictions for each day in the window
        for i in range(self.window_size):
            # plt.figure(figsize=(12, 6))
            # plt.title(f'Day {i+1} - True vs. Predicted Closing Prices')
            # plt.xlabel('Date')
            # plt.ylabel('Closing Price')
            # plt.grid(True)
        
            # Plot the true closing prices for the specific range
            if i == 0:
                plt.plot(y_test.index[start_index:end_index], y_test[f'Close_{i+1}'].iloc[start_index:end_index], label='True', linestyle='-')
        
            # Plot the corresponding predictions for the specific range
            plt.plot(y_test.index[start_index:end_index], y_preds[i][start_index:end_index], label='Predicted', linestyle='--')

   
        plt.legend()
        plt.show()
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol, 10)
    predictions = cp.predict_windows()
    data = cp.data

    # future_predictions = cp.predict_future(window=30)
    # print(future_predictions)
132/22:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.window_size = window_size
        self.data = self.add_features(data)
        
       

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-05-01', '2023-12-08')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        # Visualize the predictions
        # for i in range(window_size):
        #     plt.figure(figsize=(10, 5))
        #     plt.title(f"Day {i+1} Prediction")
        #     plt.plot(y_test.index, y_test[f'Close_{i+1}'], label='Actual')
        #     plt.plot(y_test.index, y_preds[i], label='Predicted', linestyle='--')
        #     plt.legend()
        #     plt.xlabel('Date')
        #     plt.ylabel('Closing Price')
        #     plt.grid(True)
        #     plt.show()

        # Create a single plot to visualize all predictions and the true closing prices
        plt.figure(figsize=(12, 6))
        plt.title('Predicted vs. True Closing Prices for Each Day in the Window')
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        
        # Plot the true closing prices
        # for i in range(window_size):
        #     plt.plot(y_test.index, y_test[f'Close_{i+1}'], label=f'Day {i+1} True', alpha=1)
        #     break
        
        # # Plot the corresponding predictions
        # for i in range(window_size):
        #     plt.plot(y_test.index, y_preds[i], label=f'Day {i+1} Predicted', linestyle='--', alpha=0.6)
        start_index = 0  # Replace with your desired starting index
        end_index = -1    # Replace with your desired ending index
        
        # Create separate plots for the true closing prices and predictions for each day in the window
        for i in range(self.window_size):
            # plt.figure(figsize=(12, 6))
            # plt.title(f'Day {i+1} - True vs. Predicted Closing Prices')
            # plt.xlabel('Date')
            # plt.ylabel('Closing Price')
            # plt.grid(True)
        
            # Plot the true closing prices for the specific range
            if i == 0:
                plt.plot(y_test.index[start_index:end_index], y_test[f'Close_{i+1}'].iloc[start_index:end_index], label='True', linestyle='-')
        
            # Plot the corresponding predictions for the specific range
            plt.plot(y_test.index[start_index:end_index], y_preds[i][start_index:end_index], label='Predicted', linestyle='--')

   
        plt.legend()
        plt.show()
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol, 10)
    predictions = cp.predict_windows()
    data = cp.data

    # future_predictions = cp.predict_future(window=30)
    # print(future_predictions)
132/23:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.window_size = window_size
        self.data = self.add_features(data)
        
       

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-05-01', '2023-12-08')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        # Visualize the predictions
        # for i in range(window_size):
        #     plt.figure(figsize=(10, 5))
        #     plt.title(f"Day {i+1} Prediction")
        #     plt.plot(y_test.index, y_test[f'Close_{i+1}'], label='Actual')
        #     plt.plot(y_test.index, y_preds[i], label='Predicted', linestyle='--')
        #     plt.legend()
        #     plt.xlabel('Date')
        #     plt.ylabel('Closing Price')
        #     plt.grid(True)
        #     plt.show()

        # Create a single plot to visualize all predictions and the true closing prices
        plt.figure(figsize=(12, 6))
        plt.title('Predicted vs. True Closing Prices for Each Day in the Window')
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        
        # Plot the true closing prices
        # for i in range(window_size):
        #     plt.plot(y_test.index, y_test[f'Close_{i+1}'], label=f'Day {i+1} True', alpha=1)
        #     break
        
        # # Plot the corresponding predictions
        # for i in range(window_size):
        #     plt.plot(y_test.index, y_preds[i], label=f'Day {i+1} Predicted', linestyle='--', alpha=0.6)
        start_index = -500  # Replace with your desired starting index
        end_index = -200   # Replace with your desired ending index
        
        # Create separate plots for the true closing prices and predictions for each day in the window
        for i in range(self.window_size):
            # plt.figure(figsize=(12, 6))
            # plt.title(f'Day {i+1} - True vs. Predicted Closing Prices')
            # plt.xlabel('Date')
            # plt.ylabel('Closing Price')
            # plt.grid(True)
        
            # Plot the true closing prices for the specific range
            if i == 0:
                plt.plot(y_test.index[start_index:end_index], y_test[f'Close_{i+1}'].iloc[start_index:end_index], label='True', linestyle='-')
        
            # Plot the corresponding predictions for the specific range
            plt.plot(y_test.index[start_index:end_index], y_preds[i][start_index:end_index], label='Predicted', linestyle='--')

   
        plt.legend()
        plt.show()
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol, 10)
    predictions = cp.predict_windows()
    data = cp.data

    # future_predictions = cp.predict_future(window=30)
    # print(future_predictions)
132/24:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.window_size = window_size
        self.data = self.add_features(data)
        
       

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-05-01', '2023-12-08')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        # Visualize the predictions
        # for i in range(window_size):
        #     plt.figure(figsize=(10, 5))
        #     plt.title(f"Day {i+1} Prediction")
        #     plt.plot(y_test.index, y_test[f'Close_{i+1}'], label='Actual')
        #     plt.plot(y_test.index, y_preds[i], label='Predicted', linestyle='--')
        #     plt.legend()
        #     plt.xlabel('Date')
        #     plt.ylabel('Closing Price')
        #     plt.grid(True)
        #     plt.show()

        # Create a single plot to visualize all predictions and the true closing prices
        plt.figure(figsize=(12, 6))
        plt.title('Predicted vs. True Closing Prices for Each Day in the Window')
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        
        # Plot the true closing prices
        # for i in range(window_size):
        #     plt.plot(y_test.index, y_test[f'Close_{i+1}'], label=f'Day {i+1} True', alpha=1)
        #     break
        
        # # Plot the corresponding predictions
        # for i in range(window_size):
        #     plt.plot(y_test.index, y_preds[i], label=f'Day {i+1} Predicted', linestyle='--', alpha=0.6)
        start_index = -500  # Replace with your desired starting index
        end_index = -200   # Replace with your desired ending index
        
        # Create separate plots for the true closing prices and predictions for each day in the window
        for i in range(self.window_size):
            # plt.figure(figsize=(12, 6))
            # plt.title(f'Day {i+1} - True vs. Predicted Closing Prices')
            # plt.xlabel('Date')
            # plt.ylabel('Closing Price')
            # plt.grid(True)
        
            # Plot the true closing prices for the specific range
            #if i == 0:
            plt.plot(y_test.index[start_index:end_index], y_test[f'Close_{i+1}'].iloc[start_index:end_index], label='True', linestyle='-')
        
            # Plot the corresponding predictions for the specific range
            plt.plot(y_test.index[start_index:end_index], y_preds[i][start_index:end_index], label='Predicted', linestyle='--')

   
        plt.legend()
        plt.show()
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol, 10)
    predictions = cp.predict_windows()
    data = cp.data

    # future_predictions = cp.predict_future(window=30)
    # print(future_predictions)
132/25:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.window_size = window_size
        self.data = self.add_features(data)
        
       

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-05-01', '2023-12-08')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        # Visualize the predictions
        # for i in range(window_size):
        #     plt.figure(figsize=(10, 5))
        #     plt.title(f"Day {i+1} Prediction")
        #     plt.plot(y_test.index, y_test[f'Close_{i+1}'], label='Actual')
        #     plt.plot(y_test.index, y_preds[i], label='Predicted', linestyle='--')
        #     plt.legend()
        #     plt.xlabel('Date')
        #     plt.ylabel('Closing Price')
        #     plt.grid(True)
        #     plt.show()

        # Create a single plot to visualize all predictions and the true closing prices
        plt.figure(figsize=(12, 6))
        plt.title('Predicted vs. True Closing Prices for Each Day in the Window')
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        
        # Plot the true closing prices
        # for i in range(window_size):
        #     plt.plot(y_test.index, y_test[f'Close_{i+1}'], label=f'Day {i+1} True', alpha=1)
        #     break
        
        # # Plot the corresponding predictions
        # for i in range(window_size):
        #     plt.plot(y_test.index, y_preds[i], label=f'Day {i+1} Predicted', linestyle='--', alpha=0.6)
        start_index = -500  # Replace with your desired starting index
        end_index = -200   # Replace with your desired ending index
        
        # Create separate plots for the true closing prices and predictions for each day in the window
        for i in range(self.window_size):
            # plt.figure(figsize=(12, 6))
            # plt.title(f'Day {i+1} - True vs. Predicted Closing Prices')
            # plt.xlabel('Date')
            # plt.ylabel('Closing Price')
            # plt.grid(True)
        
            # Plot the true closing prices for the specific range
            if i == 0:
                plt.plot(y_test.index[start_index:end_index], y_test[f'Close_{i+1}'].iloc[start_index:end_index], label='True', linestyle='-')
        
            # Plot the corresponding predictions for the specific range
            plt.plot(y_test.index[start_index:end_index], y_preds[i][start_index:end_index], label='Predicted', linestyle='--')

   
        plt.legend()
        plt.show()
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol, 10)
    predictions = cp.predict_windows()
    data = cp.data

    # future_predictions = cp.predict_future(window=30)
    # print(future_predictions)
132/26:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.window_size = window_size
        self.data = self.add_features(data)
        
       

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-05-01', '2023-12-08')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        # Visualize the predictions
        # for i in range(window_size):
        #     plt.figure(figsize=(10, 5))
        #     plt.title(f"Day {i+1} Prediction")
        #     plt.plot(y_test.index, y_test[f'Close_{i+1}'], label='Actual')
        #     plt.plot(y_test.index, y_preds[i], label='Predicted', linestyle='--')
        #     plt.legend()
        #     plt.xlabel('Date')
        #     plt.ylabel('Closing Price')
        #     plt.grid(True)
        #     plt.show()

        # Create a single plot to visualize all predictions and the true closing prices
        plt.figure(figsize=(12, 6))
        plt.title('Predicted vs. True Closing Prices for Each Day in the Window')
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        
        # Plot the true closing prices
        # for i in range(window_size):
        #     plt.plot(y_test.index, y_test[f'Close_{i+1}'], label=f'Day {i+1} True', alpha=1)
        #     break
        
        # # Plot the corresponding predictions
        # for i in range(window_size):
        #     plt.plot(y_test.index, y_preds[i], label=f'Day {i+1} Predicted', linestyle='--', alpha=0.6)
        start_index = -500  # Replace with your desired starting index
        end_index = -200   # Replace with your desired ending index
        
        # Create separate plots for the true closing prices and predictions for each day in the window
        for i in range(self.window_size):
            # plt.figure(figsize=(12, 6))
            # plt.title(f'Day {i+1} - True vs. Predicted Closing Prices')
            # plt.xlabel('Date')
            # plt.ylabel('Closing Price')
            # plt.grid(True)
        
            # Plot the true closing prices for the specific range
            if i == 0:
                plt.plot(y_test.index[start_index:end_index], y_test[f'Close_{i+1}'] #.iloc[start_index:end_index],
                         label='True', linestyle='-')
        
            # Plot the corresponding predictions for the specific range
            plt.plot(y_test.index[start_index:end_index], y_preds[i][start_index:end_index], label='Predicted', linestyle='--')

   
        plt.legend()
        plt.show()
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol, 10)
    predictions = cp.predict_windows()
    data = cp.data

    # future_predictions = cp.predict_future(window=30)
    # print(future_predictions)
132/27:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.window_size = window_size
        self.data = self.add_features(data)
        
       

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-05-01', '2023-12-08')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        # Visualize the predictions
        # for i in range(window_size):
        #     plt.figure(figsize=(10, 5))
        #     plt.title(f"Day {i+1} Prediction")
        #     plt.plot(y_test.index, y_test[f'Close_{i+1}'], label='Actual')
        #     plt.plot(y_test.index, y_preds[i], label='Predicted', linestyle='--')
        #     plt.legend()
        #     plt.xlabel('Date')
        #     plt.ylabel('Closing Price')
        #     plt.grid(True)
        #     plt.show()

        # Create a single plot to visualize all predictions and the true closing prices
        plt.figure(figsize=(12, 6))
        plt.title('Predicted vs. True Closing Prices for Each Day in the Window')
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        
        # Plot the true closing prices
        # for i in range(window_size):
        #     plt.plot(y_test.index, y_test[f'Close_{i+1}'], label=f'Day {i+1} True', alpha=1)
        #     break
        
        # # Plot the corresponding predictions
        # for i in range(window_size):
        #     plt.plot(y_test.index, y_preds[i], label=f'Day {i+1} Predicted', linestyle='--', alpha=0.6)
        start_index = -500  # Replace with your desired starting index
        end_index = -200   # Replace with your desired ending index
        
        # Create separate plots for the true closing prices and predictions for each day in the window
        for i in range(self.window_size):
            # plt.figure(figsize=(12, 6))
            # plt.title(f'Day {i+1} - True vs. Predicted Closing Prices')
            # plt.xlabel('Date')
            # plt.ylabel('Closing Price')
            # plt.grid(True)
        
            # Plot the true closing prices for the specific range
            if i == 0:
                plt.plot(y_test.index[start_index:end_index], y_test[f'Close_{i+1}'] #.iloc[start_index:end_index],
                         label='True', linestyle='-')
        
            # Plot the corresponding predictions for the specific range
            plt.plot(y_test.index #[start_index:end_index],
                     y_preds[i] #[start_index:end_index],
                     label='Predicted', linestyle='--')

   
        plt.legend()
        plt.show()
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol, 10)
    predictions = cp.predict_windows()
    data = cp.data

    # future_predictions = cp.predict_future(window=30)
    # print(future_predictions)
132/28:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.window_size = window_size
        self.data = self.add_features(data)
        
       

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-05-01', '2023-12-08')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        # Visualize the predictions
        # for i in range(window_size):
        #     plt.figure(figsize=(10, 5))
        #     plt.title(f"Day {i+1} Prediction")
        #     plt.plot(y_test.index, y_test[f'Close_{i+1}'], label='Actual')
        #     plt.plot(y_test.index, y_preds[i], label='Predicted', linestyle='--')
        #     plt.legend()
        #     plt.xlabel('Date')
        #     plt.ylabel('Closing Price')
        #     plt.grid(True)
        #     plt.show()

        # Create a single plot to visualize all predictions and the true closing prices
        plt.figure(figsize=(12, 6))
        plt.title('Predicted vs. True Closing Prices for Each Day in the Window')
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        
        # Plot the true closing prices
        # for i in range(window_size):
        #     plt.plot(y_test.index, y_test[f'Close_{i+1}'], label=f'Day {i+1} True', alpha=1)
        #     break
        
        # # Plot the corresponding predictions
        # for i in range(window_size):
        #     plt.plot(y_test.index, y_preds[i], label=f'Day {i+1} Predicted', linestyle='--', alpha=0.6)
        start_index = -500  # Replace with your desired starting index
        end_index = -200   # Replace with your desired ending index
        
        # Create separate plots for the true closing prices and predictions for each day in the window
        for i in range(self.window_size):
            # plt.figure(figsize=(12, 6))
            # plt.title(f'Day {i+1} - True vs. Predicted Closing Prices')
            # plt.xlabel('Date')
            # plt.ylabel('Closing Price')
            # plt.grid(True)
        
            # Plot the true closing prices for the specific range
            if i == 0:
                plt.plot(y_test.index #[start_index:end_index],
                         y_test[f'Close_{i+1}'] #.iloc[start_index:end_index],
                         label='True', linestyle='-')
        
            # Plot the corresponding predictions for the specific range
            plt.plot(y_test.index #[start_index:end_index],
                     y_preds[i] #[start_index:end_index],
                     label='Predicted', linestyle='--')

   
        plt.legend()
        plt.show()
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol, 10)
    predictions = cp.predict_windows()
    data = cp.data

    # future_predictions = cp.predict_future(window=30)
    # print(future_predictions)
132/29:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.window_size = window_size
        self.data = self.add_features(data)
        
       

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-05-01', '2023-12-08')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        # Visualize the predictions
        # for i in range(window_size):
        #     plt.figure(figsize=(10, 5))
        #     plt.title(f"Day {i+1} Prediction")
        #     plt.plot(y_test.index, y_test[f'Close_{i+1}'], label='Actual')
        #     plt.plot(y_test.index, y_preds[i], label='Predicted', linestyle='--')
        #     plt.legend()
        #     plt.xlabel('Date')
        #     plt.ylabel('Closing Price')
        #     plt.grid(True)
        #     plt.show()

        # Create a single plot to visualize all predictions and the true closing prices
        plt.figure(figsize=(12, 6))
        plt.title('Predicted vs. True Closing Prices for Each Day in the Window')
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        
        # Plot the true closing prices
        # for i in range(window_size):
        #     plt.plot(y_test.index, y_test[f'Close_{i+1}'], label=f'Day {i+1} True', alpha=1)
        #     break
        
        # # Plot the corresponding predictions
        # for i in range(window_size):
        #     plt.plot(y_test.index, y_preds[i], label=f'Day {i+1} Predicted', linestyle='--', alpha=0.6)
        start_index = -500  # Replace with your desired starting index
        end_index = -200   # Replace with your desired ending index
        
        # Create separate plots for the true closing prices and predictions for each day in the window
        for i in range(self.window_size):
            # plt.figure(figsize=(12, 6))
            # plt.title(f'Day {i+1} - True vs. Predicted Closing Prices')
            # plt.xlabel('Date')
            # plt.ylabel('Closing Price')
            # plt.grid(True)
        
            # Plot the true closing prices for the specific range
            if i == 0:
                plt.plot(y_test.index[:] #[start_index:end_index],
                         y_test[f'Close_{i+1}'] #.iloc[start_index:end_index],
                         label='True', linestyle='-')
        
            # Plot the corresponding predictions for the specific range
            plt.plot(y_test.index #[start_index:end_index],
                     y_preds[i] #[start_index:end_index],
                     label='Predicted', linestyle='--')

   
        plt.legend()
        plt.show()
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol, 10)
    predictions = cp.predict_windows()
    data = cp.data

    # future_predictions = cp.predict_future(window=30)
    # print(future_predictions)
132/30:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.window_size = window_size
        self.data = self.add_features(data)
        
       

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-05-01', '2023-12-08')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        # Visualize the predictions
        # for i in range(window_size):
        #     plt.figure(figsize=(10, 5))
        #     plt.title(f"Day {i+1} Prediction")
        #     plt.plot(y_test.index, y_test[f'Close_{i+1}'], label='Actual')
        #     plt.plot(y_test.index, y_preds[i], label='Predicted', linestyle='--')
        #     plt.legend()
        #     plt.xlabel('Date')
        #     plt.ylabel('Closing Price')
        #     plt.grid(True)
        #     plt.show()

        # Create a single plot to visualize all predictions and the true closing prices
        plt.figure(figsize=(12, 6))
        plt.title('Predicted vs. True Closing Prices for Each Day in the Window')
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        
        # Plot the true closing prices
        # for i in range(window_size):
        #     plt.plot(y_test.index, y_test[f'Close_{i+1}'], label=f'Day {i+1} True', alpha=1)
        #     break
        
        # # Plot the corresponding predictions
        # for i in range(window_size):
        #     plt.plot(y_test.index, y_preds[i], label=f'Day {i+1} Predicted', linestyle='--', alpha=0.6)
        start_index = -500  # Replace with your desired starting index
        end_index = -200   # Replace with your desired ending index
        
        # Create separate plots for the true closing prices and predictions for each day in the window
        for i in range(self.window_size):
            # plt.figure(figsize=(12, 6))
            # plt.title(f'Day {i+1} - True vs. Predicted Closing Prices')
            # plt.xlabel('Date')
            # plt.ylabel('Closing Price')
            # plt.grid(True)
        
            # Plot the true closing prices for the specific range
            if i == 0:
                plt.plot(y_test.index[0:] #[start_index:end_index],
                         y_test[f'Close_{i+1}'] #.iloc[start_index:end_index],
                         label='True', linestyle='-')
        
            # Plot the corresponding predictions for the specific range
            plt.plot(y_test.index #[start_index:end_index],
                     y_preds[i] #[start_index:end_index],
                     label='Predicted', linestyle='--')

   
        plt.legend()
        plt.show()
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol, 10)
    predictions = cp.predict_windows()
    data = cp.data

    # future_predictions = cp.predict_future(window=30)
    # print(future_predictions)
132/31:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.window_size = window_size
        self.data = self.add_features(data)
        
       

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-05-01', '2023-12-08')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        # Visualize the predictions
        # for i in range(window_size):
        #     plt.figure(figsize=(10, 5))
        #     plt.title(f"Day {i+1} Prediction")
        #     plt.plot(y_test.index, y_test[f'Close_{i+1}'], label='Actual')
        #     plt.plot(y_test.index, y_preds[i], label='Predicted', linestyle='--')
        #     plt.legend()
        #     plt.xlabel('Date')
        #     plt.ylabel('Closing Price')
        #     plt.grid(True)
        #     plt.show()

        # Create a single plot to visualize all predictions and the true closing prices
        plt.figure(figsize=(12, 6))
        plt.title('Predicted vs. True Closing Prices for Each Day in the Window')
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        
        # Plot the true closing prices
        # for i in range(window_size):
        #     plt.plot(y_test.index, y_test[f'Close_{i+1}'], label=f'Day {i+1} True', alpha=1)
        #     break
        
        # # Plot the corresponding predictions
        # for i in range(window_size):
        #     plt.plot(y_test.index, y_preds[i], label=f'Day {i+1} Predicted', linestyle='--', alpha=0.6)
        start_index = -500  # Replace with your desired starting index
        end_index = -200   # Replace with your desired ending index
        
        # Create separate plots for the true closing prices and predictions for each day in the window
        for i in range(self.window_size):
            # plt.figure(figsize=(12, 6))
            # plt.title(f'Day {i+1} - True vs. Predicted Closing Prices')
            # plt.xlabel('Date')
            # plt.ylabel('Closing Price')
            # plt.grid(True)
        
            # Plot the true closing prices for the specific range
            if i == 0:
                plt.plot(y_test.index[start_index:end_index], y_test[f'Close_{i+1}'].iloc[start_index:end_index],
                         label='True', linestyle='-')
        
            # Plot the corresponding predictions for the specific range
            plt.plot(y_test.index[start_index:end_index], y_preds[i][start_index:end_index], label='Predicted', linestyle='--')

   
        plt.legend()
        plt.show()
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol, 10)
    predictions = cp.predict_windows()
    data = cp.data

    # future_predictions = cp.predict_future(window=30)
    # print(future_predictions)
132/32:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.window_size = window_size
        self.data = self.add_features(data)
        
       

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-05-01', '2023-12-08')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        # Visualize the predictions
        # for i in range(window_size):
        #     plt.figure(figsize=(10, 5))
        #     plt.title(f"Day {i+1} Prediction")
        #     plt.plot(y_test.index, y_test[f'Close_{i+1}'], label='Actual')
        #     plt.plot(y_test.index, y_preds[i], label='Predicted', linestyle='--')
        #     plt.legend()
        #     plt.xlabel('Date')
        #     plt.ylabel('Closing Price')
        #     plt.grid(True)
        #     plt.show()

        # Create a single plot to visualize all predictions and the true closing prices
        plt.figure(figsize=(12, 6))
        plt.title('Predicted vs. True Closing Prices for Each Day in the Window')
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        
        # Plot the true closing prices
        # for i in range(window_size):
        #     plt.plot(y_test.index, y_test[f'Close_{i+1}'], label=f'Day {i+1} True', alpha=1)
        #     break
        
        # # Plot the corresponding predictions
        # for i in range(window_size):
        #     plt.plot(y_test.index, y_preds[i], label=f'Day {i+1} Predicted', linestyle='--', alpha=0.6)
        start_index = -1500  # Replace with your desired starting index
        end_index = -1200   # Replace with your desired ending index
        
        # Create separate plots for the true closing prices and predictions for each day in the window
        for i in range(self.window_size):
            # plt.figure(figsize=(12, 6))
            # plt.title(f'Day {i+1} - True vs. Predicted Closing Prices')
            # plt.xlabel('Date')
            # plt.ylabel('Closing Price')
            # plt.grid(True)
        
            # Plot the true closing prices for the specific range
            if i == 0:
                plt.plot(y_test.index[start_index:end_index], y_test[f'Close_{i+1}'].iloc[start_index:end_index],
                         label='True', linestyle='-')
        
            # Plot the corresponding predictions for the specific range
            plt.plot(y_test.index[start_index:end_index], y_preds[i][start_index:end_index], label='Predicted', linestyle='--')

   
        plt.legend()
        plt.show()
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol, 10)
    predictions = cp.predict_windows()
    data = cp.data

    # future_predictions = cp.predict_future(window=30)
    # print(future_predictions)
132/33:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.window_size = window_size
        self.data = self.add_features(data)
        
       

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-05-01', '2023-12-08')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        # Visualize the predictions
        # for i in range(window_size):
        #     plt.figure(figsize=(10, 5))
        #     plt.title(f"Day {i+1} Prediction")
        #     plt.plot(y_test.index, y_test[f'Close_{i+1}'], label='Actual')
        #     plt.plot(y_test.index, y_preds[i], label='Predicted', linestyle='--')
        #     plt.legend()
        #     plt.xlabel('Date')
        #     plt.ylabel('Closing Price')
        #     plt.grid(True)
        #     plt.show()

        # Create a single plot to visualize all predictions and the true closing prices
        plt.figure(figsize=(12, 6))
        plt.title('Predicted vs. True Closing Prices for Each Day in the Window')
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        
        # Plot the true closing prices
        # for i in range(window_size):
        #     plt.plot(y_test.index, y_test[f'Close_{i+1}'], label=f'Day {i+1} True', alpha=1)
        #     break
        
        # # Plot the corresponding predictions
        # for i in range(window_size):
        #     plt.plot(y_test.index, y_preds[i], label=f'Day {i+1} Predicted', linestyle='--', alpha=0.6)
        start_index = -150  # Replace with your desired starting index
        end_index = -120   # Replace with your desired ending index
        
        # Create separate plots for the true closing prices and predictions for each day in the window
        for i in range(self.window_size):
            # plt.figure(figsize=(12, 6))
            # plt.title(f'Day {i+1} - True vs. Predicted Closing Prices')
            # plt.xlabel('Date')
            # plt.ylabel('Closing Price')
            # plt.grid(True)
        
            # Plot the true closing prices for the specific range
            if i == 0:
                plt.plot(y_test.index[start_index:end_index], y_test[f'Close_{i+1}'].iloc[start_index:end_index],
                         label='True', linestyle='-')
        
            # Plot the corresponding predictions for the specific range
            plt.plot(y_test.index[start_index:end_index], y_preds[i][start_index:end_index], label='Predicted', linestyle='--')

   
        plt.legend()
        plt.show()
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol, 10)
    predictions = cp.predict_windows()
    data = cp.data

    # future_predictions = cp.predict_future(window=30)
    # print(future_predictions)
132/34:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.window_size = window_size
        self.data = self.add_features(data)
        
       

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-05-01', '2023-12-08')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        # Visualize the predictions
        # for i in range(window_size):
        #     plt.figure(figsize=(10, 5))
        #     plt.title(f"Day {i+1} Prediction")
        #     plt.plot(y_test.index, y_test[f'Close_{i+1}'], label='Actual')
        #     plt.plot(y_test.index, y_preds[i], label='Predicted', linestyle='--')
        #     plt.legend()
        #     plt.xlabel('Date')
        #     plt.ylabel('Closing Price')
        #     plt.grid(True)
        #     plt.show()

        # Create a single plot to visualize all predictions and the true closing prices
        plt.figure(figsize=(12, 6))
        plt.title('Predicted vs. True Closing Prices for Each Day in the Window')
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        
        # Plot the true closing prices
        # for i in range(window_size):
        #     plt.plot(y_test.index, y_test[f'Close_{i+1}'], label=f'Day {i+1} True', alpha=1)
        #     break
        
        # # Plot the corresponding predictions
        # for i in range(window_size):
        #     plt.plot(y_test.index, y_preds[i], label=f'Day {i+1} Predicted', linestyle='--', alpha=0.6)
        start_index = -150  # Replace with your desired starting index
        end_index = -140   # Replace with your desired ending index
        
        # Create separate plots for the true closing prices and predictions for each day in the window
        for i in range(self.window_size):
            # plt.figure(figsize=(12, 6))
            # plt.title(f'Day {i+1} - True vs. Predicted Closing Prices')
            # plt.xlabel('Date')
            # plt.ylabel('Closing Price')
            # plt.grid(True)
        
            # Plot the true closing prices for the specific range
            if i == 0:
                plt.plot(y_test.index[start_index:end_index], y_test[f'Close_{i+1}'].iloc[start_index:end_index],
                         label='True', linestyle='-')
        
            # Plot the corresponding predictions for the specific range
            plt.plot(y_test.index[start_index:end_index], y_preds[i][start_index:end_index], label='Predicted', linestyle='--')

   
        plt.legend()
        plt.show()
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol, 10)
    predictions = cp.predict_windows()
    data = cp.data

    # future_predictions = cp.predict_future(window=30)
    # print(future_predictions)
132/35:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.window_size = window_size
        self.data = self.add_features(data)
        
       

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-05-01', '2023-12-08')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        Visualize the predictions
        for i in range(window_size):
            plt.figure(figsize=(10, 5))
            plt.title(f"Day {i+1} Prediction")
            plt.plot(y_test.index, y_test[f'Close_{i+1}'], label='Actual')
            plt.plot(y_test.index, y_preds[i], label='Predicted', linestyle='--')
            plt.legend()
            plt.xlabel('Date')
            plt.ylabel('Closing Price')
            plt.grid(True)
            plt.show()

        # Create a single plot to visualize all predictions and the true closing prices
        plt.figure(figsize=(12, 6))
        plt.title('Predicted vs. True Closing Prices for Each Day in the Window')
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        
        # Plot the true closing prices
        # for i in range(window_size):
        #     plt.plot(y_test.index, y_test[f'Close_{i+1}'], label=f'Day {i+1} True', alpha=1)
        #     break
        
        # # Plot the corresponding predictions
        # for i in range(window_size):
        #     plt.plot(y_test.index, y_preds[i], label=f'Day {i+1} Predicted', linestyle='--', alpha=0.6)
        start_index = -150  # Replace with your desired starting index
        end_index = -140   # Replace with your desired ending index
        
        # Create separate plots for the true closing prices and predictions for each day in the window
        for i in range(self.window_size):
            # plt.figure(figsize=(12, 6))
            # plt.title(f'Day {i+1} - True vs. Predicted Closing Prices')
            # plt.xlabel('Date')
            # plt.ylabel('Closing Price')
            # plt.grid(True)
        
            # Plot the true closing prices for the specific range
            if i == 0:
                plt.plot(y_test.index[start_index:end_index], y_test[f'Close_{i+1}'].iloc[start_index:end_index],
                         label='True', linestyle='-')
        
            # Plot the corresponding predictions for the specific range
            plt.plot(y_test.index[start_index:end_index], y_preds[i][start_index:end_index], label='Predicted', linestyle='--')

   
        plt.legend()
        plt.show()
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol, 10)
    predictions = cp.predict_windows()
    data = cp.data

    # future_predictions = cp.predict_future(window=30)
    # print(future_predictions)
132/36:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.window_size = window_size
        self.data = self.add_features(data)
        
       

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-05-01', '2023-12-08')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        # Visualize the predictions
        for i in range(window_size):
            plt.figure(figsize=(10, 5))
            plt.title(f"Day {i+1} Prediction")
            plt.plot(y_test.index, y_test[f'Close_{i+1}'], label='Actual')
            plt.plot(y_test.index, y_preds[i], label='Predicted', linestyle='--')
            plt.legend()
            plt.xlabel('Date')
            plt.ylabel('Closing Price')
            plt.grid(True)
            plt.show()

        # Create a single plot to visualize all predictions and the true closing prices
        plt.figure(figsize=(12, 6))
        plt.title('Predicted vs. True Closing Prices for Each Day in the Window')
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        
        # Plot the true closing prices
        # for i in range(window_size):
        #     plt.plot(y_test.index, y_test[f'Close_{i+1}'], label=f'Day {i+1} True', alpha=1)
        #     break
        
        # # Plot the corresponding predictions
        # for i in range(window_size):
        #     plt.plot(y_test.index, y_preds[i], label=f'Day {i+1} Predicted', linestyle='--', alpha=0.6)
        start_index = -150  # Replace with your desired starting index
        end_index = -140   # Replace with your desired ending index
        
        # Create separate plots for the true closing prices and predictions for each day in the window
        for i in range(self.window_size):
            # plt.figure(figsize=(12, 6))
            # plt.title(f'Day {i+1} - True vs. Predicted Closing Prices')
            # plt.xlabel('Date')
            # plt.ylabel('Closing Price')
            # plt.grid(True)
        
            # Plot the true closing prices for the specific range
            if i == 0:
                plt.plot(y_test.index[start_index:end_index], y_test[f'Close_{i+1}'].iloc[start_index:end_index],
                         label='True', linestyle='-')
        
            # Plot the corresponding predictions for the specific range
            plt.plot(y_test.index[start_index:end_index], y_preds[i][start_index:end_index], label='Predicted', linestyle='--')

   
        plt.legend()
        plt.show()
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol, 10)
    predictions = cp.predict_windows()
    data = cp.data

    # future_predictions = cp.predict_future(window=30)
    # print(future_predictions)
132/37:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.window_size = window_size
        self.data = self.add_features(data)
        
       

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-05-01', '2023-12-08')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        # Visualize the predictions
        for i in range(window_size):
            plt.figure(figsize=(10, 5))
            plt.title(f"Day {i+1} Prediction")
            plt.plot(y_test.index, y_test[f'Close_{i+1}'], label='Actual')
            plt.plot(y_test.index, y_preds[i], label='Predicted', linestyle='--')
            plt.legend()
            plt.xlabel('Date')
            plt.ylabel('Closing Price')
            plt.grid(True)
            plt.show()

        # Create a single plot to visualize all predictions and the true closing prices
        plt.figure(figsize=(12, 6))
        plt.title('Predicted vs. True Closing Prices for Each Day in the Window')
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        
        Plot the true closing prices
        for i in range(window_size):
            plt.plot(y_test.index, y_test[f'Close_{i+1}'], label=f'Day {i+1} True', alpha=1)
            break
        
        # Plot the corresponding predictions
        for i in range(window_size):
            plt.plot(y_test.index, y_preds[i], label=f'Day {i+1} Predicted', linestyle='--', alpha=0.6)
        start_index = -150  # Replace with your desired starting index
        end_index = -140   # Replace with your desired ending index
        
        # Create separate plots for the true closing prices and predictions for each day in the window
        for i in range(self.window_size):
            # Plot the true closing prices for the specific range
            if i == 0:
                plt.plot(y_test.index[start_index:end_index], y_test[f'Close_{i+1}'].iloc[start_index:end_index],
                         label='True', linestyle='-')
        
            # Plot the corresponding predictions for the specific range
            plt.plot(y_test.index[start_index:end_index], y_preds[i][start_index:end_index], label='Predicted', linestyle='--')

   
        plt.legend()
        plt.show()
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol, 10)
    predictions = cp.predict_windows()
    data = cp.data

    # future_predictions = cp.predict_future(window=30)
    # print(future_predictions)
132/38:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.window_size = window_size
        self.data = self.add_features(data)
        
       

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-05-01', '2023-12-08')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        # Visualize the predictions
        for i in range(window_size):
            plt.figure(figsize=(10, 5))
            plt.title(f"Day {i+1} Prediction")
            plt.plot(y_test.index, y_test[f'Close_{i+1}'], label='Actual')
            plt.plot(y_test.index, y_preds[i], label='Predicted', linestyle='--')
            plt.legend()
            plt.xlabel('Date')
            plt.ylabel('Closing Price')
            plt.grid(True)
            plt.show()

        # Create a single plot to visualize all predictions and the true closing prices
        plt.figure(figsize=(12, 6))
        plt.title('Predicted vs. True Closing Prices for Each Day in the Window')
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        
        Plot the true closing prices
        for i in range(window_size):
            plt.plot(y_test.index, y_test[f'Close_{i+1}'], label=f'Day {i+1} True', alpha=1)
            break
        
        # Plot the corresponding predictions
        for i in range(window_size):
            plt.plot(y_test.index, y_preds[i], label=f'Day {i+1} Predicted', linestyle='--', alpha=0.6)
        start_index = -150  # Replace with your desired starting index
        end_index = -140   # Replace with your desired ending index
        
        # Create separate plots for the true closing prices and predictions for each day in the window
        for i in range(self.window_size):
            # Plot the true closing prices for the specific range
            if i == 0:
                plt.plot(y_test.index[start_index:end_index], y_test[f'Close_{i+1}'].iloc[start_index:end_index],
                         label='True', linestyle='-')
        
            # Plot the corresponding predictions for the specific range
            plt.plot(y_test.index[start_index:end_index], y_preds[i][start_index:end_index], label='Predicted', linestyle='--')

   
        plt.legend()
        plt.show()
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol, 10)
    predictions = cp.predict_windows()
    data = cp.data

    # future_predictions = cp.predict_future(window=30)
    # print(future_predictions)
132/39:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.window_size = window_size
        self.data = self.add_features(data)
        
       

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-05-01', '2023-12-08')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        # Visualize the predictions
        for i in range(window_size):
            plt.figure(figsize=(10, 5))
            plt.title(f"Day {i+1} Prediction")
            plt.plot(y_test.index, y_test[f'Close_{i+1}'], label='Actual')
            plt.plot(y_test.index, y_preds[i], label='Predicted', linestyle='--')
            plt.legend()
            plt.xlabel('Date')
            plt.ylabel('Closing Price')
            plt.grid(True)
            plt.show()

        # Create a single plot to visualize all predictions and the true closing prices
        plt.figure(figsize=(12, 6))
        plt.title('Predicted vs. True Closing Prices for Each Day in the Window')
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        
        # Plot the true closing prices
        for i in range(window_size):
            plt.plot(y_test.index, y_test[f'Close_{i+1}'], label=f'Day {i+1} True', alpha=1)
            break
        
        # Plot the corresponding predictions
        for i in range(window_size):
            plt.plot(y_test.index, y_preds[i], label=f'Day {i+1} Predicted', linestyle='--', alpha=0.6)
        start_index = -150  # Replace with your desired starting index
        end_index = -140   # Replace with your desired ending index
        
        # Create separate plots for the true closing prices and predictions for each day in the window
        for i in range(self.window_size):
            # Plot the true closing prices for the specific range
            if i == 0:
                plt.plot(y_test.index[start_index:end_index], y_test[f'Close_{i+1}'].iloc[start_index:end_index],
                         label='True', linestyle='-')
        
            # Plot the corresponding predictions for the specific range
            plt.plot(y_test.index[start_index:end_index], y_preds[i][start_index:end_index], label='Predicted', linestyle='--')

   
        plt.legend()
        plt.show()
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol, 10)
    predictions = cp.predict_windows()
    data = cp.data

    # future_predictions = cp.predict_future(window=30)
    # print(future_predictions)
132/40:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.window_size = window_size
        self.data = self.add_features(data)
        
       

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-05-01', '2023-12-08')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        # Visualize the predictions
        for i in range(window_size):
            plt.figure(figsize=(10, 5))
            plt.title(f"Day {i+1} Prediction")
            plt.plot(y_test.index, y_test[f'Close_{i+1}'], label='Actual')
            plt.plot(y_test.index, y_preds[i], label='Predicted', linestyle='--')
            plt.legend()
            plt.xlabel('Date')
            plt.ylabel('Closing Price')
            plt.grid(True)
            plt.show()

        # Create a single plot to visualize all predictions and the true closing prices
        plt.figure(figsize=(12, 6))
        plt.title('Predicted vs. True Closing Prices for Each Day in the Window')
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        
        # Plot the true closing prices
        # for i in range(window_size):
        #     plt.plot(y_test.index, y_test[f'Close_{i+1}'], label=f'Day {i+1} True', alpha=1)
        #     break
        
        # # Plot the corresponding predictions
        # for i in range(window_size):
        #     plt.plot(y_test.index, y_preds[i], label=f'Day {i+1} Predicted', linestyle='--', alpha=0.6)
        start_index = -150  # Replace with your desired starting index
        end_index = -140   # Replace with your desired ending index
        
        # Create separate plots for the true closing prices and predictions for each day in the window
        for i in range(self.window_size):
            # Plot the true closing prices for the specific range
            if i == 0:
                plt.plot(y_test.index[start_index:end_index], y_test[f'Close_{i+1}'].iloc[start_index:end_index],
                         label='True', linestyle='-')
        
            # Plot the corresponding predictions for the specific range
            plt.plot(y_test.index[start_index:end_index], y_preds[i][start_index:end_index], label='Predicted', linestyle='--')

   
        plt.legend()
        plt.show()
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol, 10)
    predictions = cp.predict_windows()
    data = cp.data

    # future_predictions = cp.predict_future(window=30)
    # print(future_predictions)
132/41:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.window_size = window_size
        self.data = self.add_features(data)
        
       

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-05-01', '2023-12-08')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        # Visualize the predictions
        for i in range(window_size):
            plt.figure(figsize=(10, 5))
            plt.title(f"Day {i+1} Prediction")
            plt.plot(y_test.index, y_test[f'Close_{i+1}'], label='Actual')
            plt.plot(y_test.index, y_preds[i], label='Predicted', linestyle='--')
            plt.legend()
            plt.xlabel('Date')
            plt.ylabel('Closing Price')
            plt.grid(True)
            plt.show()

        # Create a single plot to visualize all predictions and the true closing prices
        plt.figure(figsize=(12, 6))
        plt.title('Predicted vs. True Closing Prices for Each Day in the Window')
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)

        # Plot the true closing prices
        for i in range(window_size):
            plt.plot(y_test.index, y_test[f'Close_{i+1}'], label=f'Day {i+1} True', alpha=1)
            break

        # Plot the corresponding predictions
        for i in range(window_size):
            plt.plot(y_test.index, y_preds[i], label=f'Day {i+1} Predicted', linestyle='--', alpha=0.6)
        
        # Visualize the predictions
        # for i in range(window_size):
        #     plt.figure(figsize=(10, 5))
        #     plt.title(f"Day {i+1} Prediction")
        #     plt.plot(y_test.index, y_test[f'Close_{i+1}'], label='Actual')
        #     plt.plot(y_test.index, y_preds[i], label='Predicted', linestyle='--')
        #     plt.legend()
        #     plt.xlabel('Date')
        #     plt.ylabel('Closing Price')
        #     plt.grid(True)
        #     plt.show()

        # # Create a single plot to visualize all predictions and the true closing prices
        # plt.figure(figsize=(12, 6))
        # plt.title('Predicted vs. True Closing Prices for Each Day in the Window')
        # plt.xlabel('Date')
        # plt.ylabel('Closing Price')
        # plt.grid(True)
        
        # # Plot the true closing prices
        # # for i in range(window_size):
        # #     plt.plot(y_test.index, y_test[f'Close_{i+1}'], label=f'Day {i+1} True', alpha=1)
        # #     break
        
        # # # Plot the corresponding predictions
        # # for i in range(window_size):
        # #     plt.plot(y_test.index, y_preds[i], label=f'Day {i+1} Predicted', linestyle='--', alpha=0.6)
        # start_index = -150  # Replace with your desired starting index
        # end_index = -140   # Replace with your desired ending index
        
        # # Create separate plots for the true closing prices and predictions for each day in the window
        # for i in range(self.window_size):
        #     # Plot the true closing prices for the specific range
        #     if i == 0:
        #         plt.plot(y_test.index[start_index:end_index], y_test[f'Close_{i+1}'].iloc[start_index:end_index],
        #                  label='True', linestyle='-')
        
        #     # Plot the corresponding predictions for the specific range
        #     plt.plot(y_test.index[start_index:end_index], y_preds[i][start_index:end_index], label='Predicted', linestyle='--')

   
        # plt.legend()
        # plt.show()
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol, 10)
    predictions = cp.predict_windows()
    data = cp.data

    # future_predictions = cp.predict_future(window=30)
    # print(future_predictions)
132/42:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.window_size = window_size
        self.data = self.add_features(data)
        
       

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-05-01', '2023-12-08')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        Visualize the predictions
        for i in range(window_size):
            plt.figure(figsize=(10, 5))
            plt.title(f"Day {i+1} Prediction")
            plt.plot(y_test.index, y_test[f'Close_{i+1}'], label='Actual')
            plt.plot(y_test.index, y_preds[i], label='Predicted', linestyle='--')
            plt.legend()
            plt.xlabel('Date')
            plt.ylabel('Closing Price')
            plt.grid(True)
            plt.show()

        # Create a single plot to visualize all predictions and the true closing prices
        plt.figure(figsize=(12, 6))
        plt.title('Predicted vs. True Closing Prices for Each Day in the Window')
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        
        # Plot the true closing prices
        # for i in range(window_size):
        #     plt.plot(y_test.index, y_test[f'Close_{i+1}'], label=f'Day {i+1} True', alpha=1)
        #     break
        
        # # Plot the corresponding predictions
        # for i in range(window_size):
        #     plt.plot(y_test.index, y_preds[i], label=f'Day {i+1} Predicted', linestyle='--', alpha=0.6)
        start_index = -150  # Replace with your desired starting index
        end_index = -140   # Replace with your desired ending index
        
        # Create separate plots for the true closing prices and predictions for each day in the window
        for i in range(self.window_size):
            # plt.figure(figsize=(12, 6))
            # plt.title(f'Day {i+1} - True vs. Predicted Closing Prices')
            # plt.xlabel('Date')
            # plt.ylabel('Closing Price')
            # plt.grid(True)
        
            # Plot the true closing prices for the specific range
            if i == 0:
                plt.plot(y_test.index[start_index:end_index], y_test[f'Close_{i+1}'].iloc[start_index:end_index],
                         label='True', linestyle='-')
        
            # Plot the corresponding predictions for the specific range
            plt.plot(y_test.index[start_index:end_index], y_preds[i][start_index:end_index], label='Predicted', linestyle='--')

   
        plt.legend()
        plt.show()
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol, 10)
    predictions = cp.predict_windows()
    data = cp.data

    # future_predictions = cp.predict_future(window=30)
    # print(future_predictions)
132/43:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.window_size = window_size
        self.data = self.add_features(data)
        
       

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-05-01', '2023-12-08')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        # Visualize the predictions
        for i in range(window_size):
            plt.figure(figsize=(10, 5))
            plt.title(f"Day {i+1} Prediction")
            plt.plot(y_test.index, y_test[f'Close_{i+1}'], label='Actual')
            plt.plot(y_test.index, y_preds[i], label='Predicted', linestyle='--')
            plt.legend()
            plt.xlabel('Date')
            plt.ylabel('Closing Price')
            plt.grid(True)
            plt.show()

        # Create a single plot to visualize all predictions and the true closing prices
        plt.figure(figsize=(12, 6))
        plt.title('Predicted vs. True Closing Prices for Each Day in the Window')
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        
        # Plot the true closing prices
        # for i in range(window_size):
        #     plt.plot(y_test.index, y_test[f'Close_{i+1}'], label=f'Day {i+1} True', alpha=1)
        #     break
        
        # # Plot the corresponding predictions
        # for i in range(window_size):
        #     plt.plot(y_test.index, y_preds[i], label=f'Day {i+1} Predicted', linestyle='--', alpha=0.6)
        start_index = -150  # Replace with your desired starting index
        end_index = -140   # Replace with your desired ending index
        
        # Create separate plots for the true closing prices and predictions for each day in the window
        for i in range(self.window_size):
            # plt.figure(figsize=(12, 6))
            # plt.title(f'Day {i+1} - True vs. Predicted Closing Prices')
            # plt.xlabel('Date')
            # plt.ylabel('Closing Price')
            # plt.grid(True)
        
            # Plot the true closing prices for the specific range
            if i == 0:
                plt.plot(y_test.index[start_index:end_index], y_test[f'Close_{i+1}'].iloc[start_index:end_index],
                         label='True', linestyle='-')
        
            # Plot the corresponding predictions for the specific range
            plt.plot(y_test.index[start_index:end_index], y_preds[i][start_index:end_index], label='Predicted', linestyle='--')

   
        plt.legend()
        plt.show()
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol, 10)
    predictions = cp.predict_windows()
    data = cp.data

    # future_predictions = cp.predict_future(window=30)
    # print(future_predictions)
132/44:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.window_size = window_size
        self.data = self.add_features(data)
        
       

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-05-01', '2023-12-08')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        # Visualize the predictions
        for i in range(window_size):
            plt.figure(figsize=(10, 5))
            plt.title(f"Day {i+1} Prediction")
            plt.plot(y_test.index, y_test[f'Close_{i+1}'], label='Actual')
            plt.plot(y_test.index, y_preds[i], label='Predicted', linestyle='--')
            plt.legend()
            plt.xlabel('Date')
            plt.ylabel('Closing Price')
            plt.grid(True)
            plt.show()

        # Create a single plot to visualize all predictions and the true closing prices
        plt.figure(figsize=(12, 6))
        plt.title('Predicted vs. True Closing Prices for Each Day in the Window')
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        
        # Plot the true closing prices
        # for i in range(window_size):
        #     plt.plot(y_test.index, y_test[f'Close_{i+1}'], label=f'Day {i+1} True', alpha=1)
        #     break
        
        # # Plot the corresponding predictions
        # for i in range(window_size):
        #     plt.plot(y_test.index, y_preds[i], label=f'Day {i+1} Predicted', linestyle='--', alpha=0.6)
        start_index = -150  # Replace with your desired starting index
        end_index = -140   # Replace with your desired ending index
        
        # Create separate plots for the true closing prices and predictions for each day in the window
        for i in range(self.window_size):
            # plt.figure(figsize=(12, 6))
            # plt.title(f'Day {i+1} - True vs. Predicted Closing Prices')
            # plt.xlabel('Date')
            # plt.ylabel('Closing Price')
            # plt.grid(True)
        
            # Plot the true closing prices for the specific range
            if i == 0:
                plt.plot(y_test.index[start_index:end_index], y_test[f'Close_{i+1}'].iloc[start_index:end_index],
                         label='True', linestyle='-')
        
            # Plot the corresponding predictions for the specific range
            plt.plot(y_test.index[start_index:end_index], y_preds[i][start_index:end_index], label='Predicted', linestyle='--')

   
        plt.legend()
        plt.show()
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol, 10)
    predictions = cp.predict_windows(10)
    data = cp.data

    # future_predictions = cp.predict_future(window=30)
    # print(future_predictions)
132/45:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.window_size = window_size
        self.data = self.add_features(data)
        
       

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-05-01', '2023-12-08')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        # Visualize the predictions
        for i in range(window_size):
            plt.figure(figsize=(10, 5))
            plt.title(f"Day {i+1} Prediction")
            plt.plot(y_test.index, y_test[f'Close_{i+1}'], label='Actual')
            plt.plot(y_test.index, y_preds[i], label='Predicted', linestyle='--')
            plt.legend()
            plt.xlabel('Date')
            plt.ylabel('Closing Price')
            plt.grid(True)
            plt.show()

        # Create a single plot to visualize all predictions and the true closing prices
        plt.figure(figsize=(12, 6))
        plt.title('Predicted vs. True Closing Prices for Each Day in the Window')
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        
        # Plot the true closing prices
        # for i in range(window_size):
        #     plt.plot(y_test.index, y_test[f'Close_{i+1}'], label=f'Day {i+1} True', alpha=1)
        #     break
        
        # # Plot the corresponding predictions
        # for i in range(window_size):
        #     plt.plot(y_test.index, y_preds[i], label=f'Day {i+1} Predicted', linestyle='--', alpha=0.6)
        start_index = -150  # Replace with your desired starting index
        end_index = -130   # Replace with your desired ending index
        
        # Create separate plots for the true closing prices and predictions for each day in the window
        for i in range(self.window_size):
            # plt.figure(figsize=(12, 6))
            # plt.title(f'Day {i+1} - True vs. Predicted Closing Prices')
            # plt.xlabel('Date')
            # plt.ylabel('Closing Price')
            # plt.grid(True)
        
            # Plot the true closing prices for the specific range
            if i == 0:
                plt.plot(y_test.index[start_index:end_index], y_test[f'Close_{i+1}'].iloc[start_index:end_index],
                         label='True', linestyle='-')
        
            # Plot the corresponding predictions for the specific range
            plt.plot(y_test.index[start_index:end_index], y_preds[i][start_index:end_index], label='Predicted', linestyle='--')

   
        plt.legend()
        plt.show()
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol, 10)
    predictions = cp.predict_windows(10)
    data = cp.data

    # future_predictions = cp.predict_future(window=30)
    # print(future_predictions)
132/46:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.window_size = window_size
        self.data = self.add_features(data)
        
       

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-05-01', '2023-12-08')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        # Visualize the predictions
        for i in range(window_size):
            plt.figure(figsize=(10, 5))
            plt.title(f"Day {i+1} Prediction")
            plt.plot(y_test.index, y_test[f'Close_{i+1}'], label='Actual')
            plt.plot(y_test.index, y_preds[i], label='Predicted', linestyle='--')
            plt.legend()
            plt.xlabel('Date')
            plt.ylabel('Closing Price')
            plt.grid(True)
            plt.show()

        # Create a single plot to visualize all predictions and the true closing prices
        plt.figure(figsize=(12, 6))
        plt.title('Predicted vs. True Closing Prices for Each Day in the Window')
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        
        # Plot the true closing prices
        # for i in range(window_size):
        #     plt.plot(y_test.index, y_test[f'Close_{i+1}'], label=f'Day {i+1} True', alpha=1)
        #     break
        
        # # Plot the corresponding predictions
        # for i in range(window_size):
        #     plt.plot(y_test.index, y_preds[i], label=f'Day {i+1} Predicted', linestyle='--', alpha=0.6)
        start_index = -150  # Replace with your desired starting index
        end_index = -90   # Replace with your desired ending index
        
        # Create separate plots for the true closing prices and predictions for each day in the window
        for i in range(self.window_size):
            # plt.figure(figsize=(12, 6))
            # plt.title(f'Day {i+1} - True vs. Predicted Closing Prices')
            # plt.xlabel('Date')
            # plt.ylabel('Closing Price')
            # plt.grid(True)
        
            # Plot the true closing prices for the specific range
            if i == 0:
                plt.plot(y_test.index[start_index:end_index], y_test[f'Close_{i+1}'].iloc[start_index:end_index],
                         label='True', linestyle='-')
        
            # Plot the corresponding predictions for the specific range
            plt.plot(y_test.index[start_index:end_index], y_preds[i][start_index:end_index], label='Predicted', linestyle='--')

   
        plt.legend()
        plt.show()
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol, 10)
    predictions = cp.predict_windows(10)
    data = cp.data

    # future_predictions = cp.predict_future(window=30)
    # print(future_predictions)
132/47:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.window_size = window_size
        self.data = self.add_features(data)
        
       

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-05-01', '2023-12-08')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        # Visualize the predictions
        for i in range(window_size):
            plt.figure(figsize=(10, 5))
            plt.title(f"Day {i+1} Prediction")
            plt.plot(y_test.index, y_test[f'Close_{i+1}'], label='Actual')
            plt.plot(y_test.index, y_preds[i], label='Predicted', linestyle='--')
            plt.legend()
            plt.xlabel('Date')
            plt.ylabel('Closing Price')
            plt.grid(True)
            plt.show()

        # Create a single plot to visualize all predictions and the true closing prices
        plt.figure(figsize=(12, 6))
        plt.title('Predicted vs. True Closing Prices for Each Day in the Window')
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        
        # Plot the true closing prices
        # for i in range(window_size):
        #     plt.plot(y_test.index, y_test[f'Close_{i+1}'], label=f'Day {i+1} True', alpha=1)
        #     break
        
        # # Plot the corresponding predictions
        # for i in range(window_size):
        #     plt.plot(y_test.index, y_preds[i], label=f'Day {i+1} Predicted', linestyle='--', alpha=0.6)
        start_index = -150  # Replace with your desired starting index
        end_index = -90   # Replace with your desired ending index
        
        # Create separate plots for the true closing prices and predictions for each day in the window
        for i in range(self.window_size):
            # plt.figure(figsize=(12, 6))
            # plt.title(f'Day {i+1} - True vs. Predicted Closing Prices')
            # plt.xlabel('Date')
            # plt.ylabel('Closing Price')
            # plt.grid(True)
        
            # Plot the true closing prices for the specific range
            if i == 0:
                plt.plot(y_test.index[start_index:end_index], y_test[f'Close_{i+1}'].iloc[start_index:end_index],
                         label='True', linestyle='-')
        
            # Plot the corresponding predictions for the specific range
            plt.plot(y_test.index[start_index:end_index], y_preds[i][start_index:end_index], label='Predicted', linestyle='--')

   
        plt.legend()
        plt.show()
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol, 10)
    predictions = cp.predict_windows(10)
    data = cp.data

    # future_predictions = cp.predict_future(window=30)
    # print(future_predictions)
132/48:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.window_size = window_size
        self.data = self.add_features(data)
        
       

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-05-01', '2023-12-08')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        # Visualize the predictions
        for i in range(window_size):
            plt.figure(figsize=(10, 5))
            plt.title(f"Day {i+1} Prediction")
            plt.plot(y_test.index, y_test[f'Close_{i+1}'], label='Actual')
            plt.plot(y_test.index, y_preds[i], label='Predicted', linestyle='--')
            plt.legend()
            plt.xlabel('Date')
            plt.ylabel('Closing Price')
            plt.grid(True)
            plt.show()

        # Create a single plot to visualize all predictions and the true closing prices
        plt.figure(figsize=(12, 6))
        plt.title('Predicted vs. True Closing Prices for Each Day in the Window')
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        
        # Plot the true closing prices
        # for i in range(window_size):
        #     plt.plot(y_test.index, y_test[f'Close_{i+1}'], label=f'Day {i+1} True', alpha=1)
        #     break
        
        # # Plot the corresponding predictions
        # for i in range(window_size):
        #     plt.plot(y_test.index, y_preds[i], label=f'Day {i+1} Predicted', linestyle='--', alpha=0.6)
        start_index = -150  # Replace with your desired starting index
        end_index = -90   # Replace with your desired ending index
        
        # Create separate plots for the true closing prices and predictions for each day in the window
        for i in range(self.window_size):
            # plt.figure(figsize=(12, 6))
            # plt.title(f'Day {i+1} - True vs. Predicted Closing Prices')
            # plt.xlabel('Date')
            # plt.ylabel('Closing Price')
            # plt.grid(True)
        
            # Plot the true closing prices for the specific range
            if i == 0:
                plt.plot(y_test.index[start_index:end_index], y_test[f'Close_{i+1}'].iloc[start_index:end_index],
                         label='True', linestyle='-')
        
            # Plot the corresponding predictions for the specific range
            plt.plot(y_test.index[start_index:end_index], y_preds[i][start_index:end_index], label='Predicted', linestyle='--')

   
        plt.legend()
        plt.show()
        return y_pred
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol, 10)
    predictions = cp.predict_windows(10)
    data = cp.data

    # future_predictions = cp.predict_future(window=30)
    # print(future_predictions)
132/49: predictions
132/50:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.window_size = window_size
        self.data = self.add_features(data)
        
       

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-05-01', '2023-12-08')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        # Visualize the predictions
        for i in range(window_size):
            plt.figure(figsize=(10, 5))
            plt.title(f"Day {i+1} Prediction")
            plt.plot(y_test.index, y_test[f'Close_{i+1}'], label='Actual')
            plt.plot(y_test.index, y_preds[i], label='Predicted', linestyle='--')
            plt.legend()
            plt.xlabel('Date')
            plt.ylabel('Closing Price')
            plt.grid(True)
            plt.show()

        # Create a single plot to visualize all predictions and the true closing prices
        plt.figure(figsize=(12, 6))
        plt.title('Predicted vs. True Closing Prices for Each Day in the Window')
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        
        # Plot the true closing prices
        # for i in range(window_size):
        #     plt.plot(y_test.index, y_test[f'Close_{i+1}'], label=f'Day {i+1} True', alpha=1)
        #     break
        
        # # Plot the corresponding predictions
        # for i in range(window_size):
        #     plt.plot(y_test.index, y_preds[i], label=f'Day {i+1} Predicted', linestyle='--', alpha=0.6)
        start_index = -150  # Replace with your desired starting index
        end_index = -90   # Replace with your desired ending index
        
        # Create separate plots for the true closing prices and predictions for each day in the window
        for i in range(self.window_size):
            # plt.figure(figsize=(12, 6))
            # plt.title(f'Day {i+1} - True vs. Predicted Closing Prices')
            # plt.xlabel('Date')
            # plt.ylabel('Closing Price')
            # plt.grid(True)
        
            # Plot the true closing prices for the specific range
            if i == 0:
                plt.plot(y_test.index[start_index:end_index], y_test[f'Close_{i+1}'].iloc[start_index:end_index],
                         label='True', linestyle='-')
        
            # Plot the corresponding predictions for the specific range
            plt.plot(y_test.index[start_index:end_index], y_preds[i][start_index:end_index], label='Predicted', linestyle='--')

   
        plt.legend()
        plt.show()
        return y_preds
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol, 10)
    predictions = cp.predict_windows(10)
    data = cp.data

    # future_predictions = cp.predict_future(window=30)
    # print(future_predictions)
132/51: predictions
132/52:
avg = np.mean(predictions)
avg
132/53:
avg = np.mean(predictions, axis=0)
avg
132/54:
avg = np.mean(predictions, axis=0)
plt.plot(avg)
132/55:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.window_size = window_size
        self.data = self.add_features(data)
        
       

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-05-01', '2023-12-08')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        avg_pred = np.mean(y_preds, axis=0)
        plt.figure(figsize=(10, 5))
        plt.title(f"AVERGAGE Prediction")
        plt.plot(y_test.index, y_test[f'Close'], label='Actual')
        plt.plot(y_test.index, avg_pred, label='Predicted', linestyle='--')
        plt.legend()
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        plt.show()
        
        # Visualize the predictions
        for i in range(window_size):
            plt.figure(figsize=(10, 5))
            plt.title(f"Day {i+1} Prediction")
            plt.plot(y_test.index, y_test[f'Close_{i+1}'], label='Actual')
            plt.plot(y_test.index, y_preds[i], label='Predicted', linestyle='--')
            plt.legend()
            plt.xlabel('Date')
            plt.ylabel('Closing Price')
            plt.grid(True)
            plt.show()

        # Create a single plot to visualize all predictions and the true closing prices
        plt.figure(figsize=(12, 6))
        plt.title('Predicted vs. True Closing Prices for Each Day in the Window')
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        
        # Plot the true closing prices
        # for i in range(window_size):
        #     plt.plot(y_test.index, y_test[f'Close_{i+1}'], label=f'Day {i+1} True', alpha=1)
        #     break
        
        # # Plot the corresponding predictions
        # for i in range(window_size):
        #     plt.plot(y_test.index, y_preds[i], label=f'Day {i+1} Predicted', linestyle='--', alpha=0.6)
        start_index = -150  # Replace with your desired starting index
        end_index = -90   # Replace with your desired ending index
        
        # Create separate plots for the true closing prices and predictions for each day in the window
        for i in range(self.window_size):
            # plt.figure(figsize=(12, 6))
            # plt.title(f'Day {i+1} - True vs. Predicted Closing Prices')
            # plt.xlabel('Date')
            # plt.ylabel('Closing Price')
            # plt.grid(True)
        
            # Plot the true closing prices for the specific range
            if i == 0:
                plt.plot(y_test.index[start_index:end_index], y_test[f'Close_{i+1}'].iloc[start_index:end_index],
                         label='True', linestyle='-')
        
            # Plot the corresponding predictions for the specific range
            plt.plot(y_test.index[start_index:end_index], y_preds[i][start_index:end_index], label='Predicted', linestyle='--')

   
        plt.legend()
        plt.show()
        return y_preds
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol, 10)
    predictions = cp.predict_windows(10)
    data = cp.data

    # future_predictions = cp.predict_future(window=30)
    # print(future_predictions)
132/56:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.window_size = window_size
        self.data = self.add_features(data)
        
       

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-05-01', '2023-12-08')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        avg_pred = np.mean(y_preds, axis=0)
        plt.figure(figsize=(10, 5))
        plt.title(f"AVERGAGE Prediction")
        plt.plot(y_test.index, y_test['Close'], label='Actual')
        plt.plot(y_test.index, avg_pred, label='Predicted', linestyle='--')
        plt.legend()
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        plt.show()
        
        # Visualize the predictions
        for i in range(window_size):
            plt.figure(figsize=(10, 5))
            plt.title(f"Day {i+1} Prediction")
            plt.plot(y_test.index, y_test[f'Close_{i+1}'], label='Actual')
            plt.plot(y_test.index, y_preds[i], label='Predicted', linestyle='--')
            plt.legend()
            plt.xlabel('Date')
            plt.ylabel('Closing Price')
            plt.grid(True)
            plt.show()

        # Create a single plot to visualize all predictions and the true closing prices
        plt.figure(figsize=(12, 6))
        plt.title('Predicted vs. True Closing Prices for Each Day in the Window')
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        
        # Plot the true closing prices
        # for i in range(window_size):
        #     plt.plot(y_test.index, y_test[f'Close_{i+1}'], label=f'Day {i+1} True', alpha=1)
        #     break
        
        # # Plot the corresponding predictions
        # for i in range(window_size):
        #     plt.plot(y_test.index, y_preds[i], label=f'Day {i+1} Predicted', linestyle='--', alpha=0.6)
        start_index = -150  # Replace with your desired starting index
        end_index = -90   # Replace with your desired ending index
        
        # Create separate plots for the true closing prices and predictions for each day in the window
        for i in range(self.window_size):
            # plt.figure(figsize=(12, 6))
            # plt.title(f'Day {i+1} - True vs. Predicted Closing Prices')
            # plt.xlabel('Date')
            # plt.ylabel('Closing Price')
            # plt.grid(True)
        
            # Plot the true closing prices for the specific range
            if i == 0:
                plt.plot(y_test.index[start_index:end_index], y_test[f'Close_{i+1}'].iloc[start_index:end_index],
                         label='True', linestyle='-')
        
            # Plot the corresponding predictions for the specific range
            plt.plot(y_test.index[start_index:end_index], y_preds[i][start_index:end_index], label='Predicted', linestyle='--')

   
        plt.legend()
        plt.show()
        return y_preds
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol, 10)
    predictions = cp.predict_windows(10)
    data = cp.data

    # future_predictions = cp.predict_future(window=30)
    # print(future_predictions)
132/57:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.window_size = window_size
        self.data = self.add_features(data)
        
       

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-05-01', '2023-12-08')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        avg_pred = np.mean(y_preds, axis=0)
        plt.figure(figsize=(10, 5))
        plt.title(f"AVERGAGE Prediction")
        plt.plot(y_test.index, y_test['Close_0'], label='Actual')
        plt.plot(y_test.index, avg_pred, label='Predicted', linestyle='--')
        plt.legend()
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        plt.show()
        
        # Visualize the predictions
        for i in range(window_size):
            plt.figure(figsize=(10, 5))
            plt.title(f"Day {i+1} Prediction")
            plt.plot(y_test.index, y_test[f'Close_{i+1}'], label='Actual')
            plt.plot(y_test.index, y_preds[i], label='Predicted', linestyle='--')
            plt.legend()
            plt.xlabel('Date')
            plt.ylabel('Closing Price')
            plt.grid(True)
            plt.show()

        # Create a single plot to visualize all predictions and the true closing prices
        plt.figure(figsize=(12, 6))
        plt.title('Predicted vs. True Closing Prices for Each Day in the Window')
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        
        # Plot the true closing prices
        # for i in range(window_size):
        #     plt.plot(y_test.index, y_test[f'Close_{i+1}'], label=f'Day {i+1} True', alpha=1)
        #     break
        
        # # Plot the corresponding predictions
        # for i in range(window_size):
        #     plt.plot(y_test.index, y_preds[i], label=f'Day {i+1} Predicted', linestyle='--', alpha=0.6)
        start_index = -150  # Replace with your desired starting index
        end_index = -90   # Replace with your desired ending index
        
        # Create separate plots for the true closing prices and predictions for each day in the window
        for i in range(self.window_size):
            # plt.figure(figsize=(12, 6))
            # plt.title(f'Day {i+1} - True vs. Predicted Closing Prices')
            # plt.xlabel('Date')
            # plt.ylabel('Closing Price')
            # plt.grid(True)
        
            # Plot the true closing prices for the specific range
            if i == 0:
                plt.plot(y_test.index[start_index:end_index], y_test[f'Close_{i+1}'].iloc[start_index:end_index],
                         label='True', linestyle='-')
        
            # Plot the corresponding predictions for the specific range
            plt.plot(y_test.index[start_index:end_index], y_preds[i][start_index:end_index], label='Predicted', linestyle='--')

   
        plt.legend()
        plt.show()
        return y_preds
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol, 10)
    predictions = cp.predict_windows(10)
    data = cp.data

    # future_predictions = cp.predict_future(window=30)
    # print(future_predictions)
132/58:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.window_size = window_size
        self.data = self.add_features(data)
        
       

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-05-01', '2023-12-08')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        avg_pred = np.mean(y_preds, axis=0)
        plt.figure(figsize=(10, 5))
        plt.title(f"AVERGAGE Prediction")
        plt.plot(y_test.index, y_test[f'Close_{i+0}'], label='Actual')
        plt.plot(y_test.index, avg_pred, label='Predicted', linestyle='--')
        plt.legend()
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        plt.show()
        
        # Visualize the predictions
        for i in range(window_size):
            plt.figure(figsize=(10, 5))
            plt.title(f"Day {i+1} Prediction")
            plt.plot(y_test.index, y_test[f'Close_{i+1}'], label='Actual')
            plt.plot(y_test.index, y_preds[i], label='Predicted', linestyle='--')
            plt.legend()
            plt.xlabel('Date')
            plt.ylabel('Closing Price')
            plt.grid(True)
            plt.show()

        # Create a single plot to visualize all predictions and the true closing prices
        plt.figure(figsize=(12, 6))
        plt.title('Predicted vs. True Closing Prices for Each Day in the Window')
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        
        # Plot the true closing prices
        # for i in range(window_size):
        #     plt.plot(y_test.index, y_test[f'Close_{i+1}'], label=f'Day {i+1} True', alpha=1)
        #     break
        
        # # Plot the corresponding predictions
        # for i in range(window_size):
        #     plt.plot(y_test.index, y_preds[i], label=f'Day {i+1} Predicted', linestyle='--', alpha=0.6)
        start_index = -150  # Replace with your desired starting index
        end_index = -90   # Replace with your desired ending index
        
        # Create separate plots for the true closing prices and predictions for each day in the window
        for i in range(self.window_size):
            # plt.figure(figsize=(12, 6))
            # plt.title(f'Day {i+1} - True vs. Predicted Closing Prices')
            # plt.xlabel('Date')
            # plt.ylabel('Closing Price')
            # plt.grid(True)
        
            # Plot the true closing prices for the specific range
            if i == 0:
                plt.plot(y_test.index[start_index:end_index], y_test[f'Close_{i+1}'].iloc[start_index:end_index],
                         label='True', linestyle='-')
        
            # Plot the corresponding predictions for the specific range
            plt.plot(y_test.index[start_index:end_index], y_preds[i][start_index:end_index], label='Predicted', linestyle='--')

   
        plt.legend()
        plt.show()
        return y_preds
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol, 10)
    predictions = cp.predict_windows(10)
    data = cp.data

    # future_predictions = cp.predict_future(window=30)
    # print(future_predictions)
132/59:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.window_size = window_size
        self.data = self.add_features(data)
        
       

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-05-01', '2023-12-08')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        avg_pred = np.mean(y_preds, axis=0)
        plt.figure(figsize=(10, 5))
        plt.title(f"AVERGAGE Prediction")
        plt.plot(y_test.index, y_test[f'Close_{i+0}'], label='Actual')
        plt.plot(y_test.index, avg_pred, label='Predicted', linestyle='--')
        plt.legend()
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        plt.show()
        
        # Visualize the predictions
        for i in range(window_size):
            plt.figure(figsize=(10, 5))
            plt.title(f"Day {i+1} Prediction")
            plt.plot(y_test.index, y_test[f'Close_{i+1}'], label='Actual')
            plt.plot(y_test.index, y_preds[i], label='Predicted', linestyle='--')
            plt.legend()
            plt.xlabel('Date')
            plt.ylabel('Closing Price')
            plt.grid(True)
            plt.show()

        # Create a single plot to visualize all predictions and the true closing prices
        plt.figure(figsize=(12, 6))
        plt.title('Predicted vs. True Closing Prices for Each Day in the Window')
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        
        # Plot the true closing prices
        # for i in range(window_size):
        #     plt.plot(y_test.index, y_test[f'Close_{i+1}'], label=f'Day {i+1} True', alpha=1)
        #     break
        
        # # Plot the corresponding predictions
        # for i in range(window_size):
        #     plt.plot(y_test.index, y_preds[i], label=f'Day {i+1} Predicted', linestyle='--', alpha=0.6)
        start_index = -150  # Replace with your desired starting index
        end_index = -90   # Replace with your desired ending index
        
        # Create separate plots for the true closing prices and predictions for each day in the window
        for i in range(self.window_size):
            # plt.figure(figsize=(12, 6))
            # plt.title(f'Day {i+1} - True vs. Predicted Closing Prices')
            # plt.xlabel('Date')
            # plt.ylabel('Closing Price')
            # plt.grid(True)
        
            # Plot the true closing prices for the specific range
            if i == 0:
                plt.plot(y_test.index[start_index:end_index], y_test[f'Close_{i+1}'].iloc[start_index:end_index],
                         label='True', linestyle='-')
        
            # Plot the corresponding predictions for the specific range
            plt.plot(y_test.index[start_index:end_index], y_preds[i][start_index:end_index], label='Predicted', linestyle='--')

   
        plt.legend()
        plt.show()
        return y_preds
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol, 30)
    predictions = cp.predict_windows(30)
    data = cp.data

    # future_predictions = cp.predict_future(window=30)
    # print(future_predictions)
132/60:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.window_size = window_size
        self.data = self.add_features(data)
        
       

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-05-01', '2023-12-08')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        avg_pred = np.mean(y_preds, axis=0)
        plt.figure(figsize=(10, 5))
        plt.title(f"AVERGAGE Prediction")
        plt.plot(y_test.index, y_test[f'Close_{i+0}'], label='Actual')
        plt.plot(y_test.index, avg_pred, label='Predicted', linestyle='--')
        plt.legend()
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        plt.show()
        
        # Visualize the predictions
        for i in range(window_size):
            plt.figure(figsize=(10, 5))
            plt.title(f"Day {i+1} Prediction")
            plt.plot(y_test.index, y_test[f'Close_{i+1}'], label='Actual')
            plt.plot(y_test.index, y_preds[i], label='Predicted', linestyle='--')
            plt.legend()
            plt.xlabel('Date')
            plt.ylabel('Closing Price')
            plt.grid(True)
            plt.show()

        # Create a single plot to visualize all predictions and the true closing prices
        plt.figure(figsize=(12, 6))
        plt.title('Predicted vs. True Closing Prices for Each Day in the Window')
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        
        # Plot the true closing prices
        # for i in range(window_size):
        #     plt.plot(y_test.index, y_test[f'Close_{i+1}'], label=f'Day {i+1} True', alpha=1)
        #     break
        
        # # Plot the corresponding predictions
        # for i in range(window_size):
        #     plt.plot(y_test.index, y_preds[i], label=f'Day {i+1} Predicted', linestyle='--', alpha=0.6)
        start_index = -150  # Replace with your desired starting index
        end_index = -90   # Replace with your desired ending index
        
        # Create separate plots for the true closing prices and predictions for each day in the window
        for i in range(self.window_size):
            # plt.figure(figsize=(12, 6))
            # plt.title(f'Day {i+1} - True vs. Predicted Closing Prices')
            # plt.xlabel('Date')
            # plt.ylabel('Closing Price')
            # plt.grid(True)
        
            # Plot the true closing prices for the specific range
            if i == 0:
                plt.plot(y_test.index[start_index:end_index], y_test[f'Close_{i+1}'].iloc[start_index:end_index],
                         label='True', linestyle='-')
        
            # Plot the corresponding predictions for the specific range
            plt.plot(y_test.index[start_index:end_index], y_preds[i][start_index:end_index], label='Predicted', linestyle='--')

   
        plt.legend()
        plt.show()
        return y_preds
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol, 30)
    predictions = cp.predict_windows(120)
    data = cp.data

    # future_predictions = cp.predict_future(window=30)
    # print(future_predictions)
132/61:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.window_size = window_size
        self.data = self.add_features(data)
        
       

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-05-01', '2023-12-08')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        avg_pred = np.mean(y_preds, axis=0)
        plt.figure(figsize=(10, 5))
        plt.title(f"AVERGAGE Prediction")
        plt.plot(y_test.index, y_test[f'Close_{i+0}'], label='Actual')
        plt.plot(y_test.index, avg_pred, label='Predicted', linestyle='--')
        plt.legend()
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        plt.show()
        
        # Visualize the predictions
        for i in range(window_size):
            plt.figure(figsize=(10, 5))
            plt.title(f"Day {i+1} Prediction")
            plt.plot(y_test.index, y_test[f'Close_{i+1}'], label='Actual')
            plt.plot(y_test.index, y_preds[i], label='Predicted', linestyle='--')
            plt.legend()
            plt.xlabel('Date')
            plt.ylabel('Closing Price')
            plt.grid(True)
            plt.show()

        # Create a single plot to visualize all predictions and the true closing prices
        plt.figure(figsize=(12, 6))
        plt.title('Predicted vs. True Closing Prices for Each Day in the Window')
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        
        # Plot the true closing prices
        # for i in range(window_size):
        #     plt.plot(y_test.index, y_test[f'Close_{i+1}'], label=f'Day {i+1} True', alpha=1)
        #     break
        
        # # Plot the corresponding predictions
        # for i in range(window_size):
        #     plt.plot(y_test.index, y_preds[i], label=f'Day {i+1} Predicted', linestyle='--', alpha=0.6)
        start_index = 0  # Replace with your desired starting index
        end_index = -1   # Replace with your desired ending index
        
        # Create separate plots for the true closing prices and predictions for each day in the window
        for i in range(self.window_size):
            # plt.figure(figsize=(12, 6))
            # plt.title(f'Day {i+1} - True vs. Predicted Closing Prices')
            # plt.xlabel('Date')
            # plt.ylabel('Closing Price')
            # plt.grid(True)
        
            # Plot the true closing prices for the specific range
            if i == 0:
                plt.plot(y_test.index[start_index:end_index], y_test[f'Close_{i+1}'].iloc[start_index:end_index],
                         label='True', linestyle='-')
        
            # Plot the corresponding predictions for the specific range
            plt.plot(y_test.index[start_index:end_index], y_preds[i][start_index:end_index], label='Predicted', linestyle='--')

   
        plt.legend()
        plt.show()
        return y_preds
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol, 30)
    predictions = cp.predict_windows(120)
    data = cp.data

    # future_predictions = cp.predict_future(window=30)
    # print(future_predictions)
132/62:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.window_size = window_size
        self.data = self.add_features(data)
        
       

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-05-01', '2023-12-08')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        avg_pred = np.mean(y_preds, axis=0)
        plt.figure(figsize=(10, 5))
        plt.title(f"AVERGAGE Prediction")
        plt.plot(y_test.index, y_test[f'Close_{i+0}'], label='Actual')
        plt.plot(y_test.index, avg_pred, label='Predicted', linestyle='--')
        plt.legend()
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        plt.show()
        
        # Visualize the predictions
        for i in range(window_size):
            plt.figure(figsize=(10, 5))
            plt.title(f"Day {i+1} Prediction")
            plt.plot(y_test.index, y_test[f'Close_{i+1}'], label='Actual')
            plt.plot(y_test.index, y_preds[i], label='Predicted', linestyle='--')
            plt.legend()
            plt.xlabel('Date')
            plt.ylabel('Closing Price')
            plt.grid(True)
            plt.show()

        # Create a single plot to visualize all predictions and the true closing prices
        plt.figure(figsize=(12, 6))
        plt.title('Predicted vs. True Closing Prices for Each Day in the Window')
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        
        # Plot the true closing prices
        # for i in range(window_size):
        #     plt.plot(y_test.index, y_test[f'Close_{i+1}'], label=f'Day {i+1} True', alpha=1)
        #     break
        
        # # Plot the corresponding predictions
        # for i in range(window_size):
        #     plt.plot(y_test.index, y_preds[i], label=f'Day {i+1} Predicted', linestyle='--', alpha=0.6)
        start_index = 0  # Replace with your desired starting index
        end_index = -1   # Replace with your desired ending index
        
        # Create separate plots for the true closing prices and predictions for each day in the window
        for i in range(self.window_size):
            # plt.figure(figsize=(12, 6))
            # plt.title(f'Day {i+1} - True vs. Predicted Closing Prices')
            # plt.xlabel('Date')
            # plt.ylabel('Closing Price')
            # plt.grid(True)
        
            # Plot the true closing prices for the specific range
            if i == 0:
                plt.plot(y_test.index[start_index:end_index], y_test[f'Close_{i+1}'].iloc[start_index:end_index],
                         label='True', linestyle='-')
        
            # Plot the corresponding predictions for the specific range
            plt.plot(y_test.index[start_index:end_index], y_preds[i][start_index:end_index], label='Predicted', linestyle='--')

   
        plt.legend()
        plt.show()
        return y_preds
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol, 120)
    predictions = cp.predict_windows(120)
    data = cp.data

    # future_predictions = cp.predict_future(window=30)
    # print(future_predictions)
132/63:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.window_size = window_size
        self.data = self.add_features(data)
        
       

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-05-01', '2023-12-08')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        avg_pred = np.mean(y_preds, axis=0)
        plt.figure(figsize=(10, 5))
        plt.title(f"AVERGAGE Prediction")
        plt.plot(y_test.index, y_test[f'Close_{i+0}'], label='Actual')
        plt.plot(y_test.index, avg_pred, label='Predicted', linestyle='--')
        plt.legend()
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        plt.show()
        
        # Visualize the predictions
        for i in range(window_size):
            plt.figure(figsize=(10, 5))
            plt.title(f"Day {i+1} Prediction")
            plt.plot(y_test.index, y_test[f'Close_{i+1}'], label='Actual')
            plt.plot(y_test.index, y_preds[i], label='Predicted', linestyle='--')
            plt.legend()
            plt.xlabel('Date')
            plt.ylabel('Closing Price')
            plt.grid(True)
            plt.show()

        # Create a single plot to visualize all predictions and the true closing prices
        plt.figure(figsize=(12, 6))
        plt.title('Predicted vs. True Closing Prices for Each Day in the Window')
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        
        # Plot the true closing prices
        # for i in range(window_size):
        #     plt.plot(y_test.index, y_test[f'Close_{i+1}'], label=f'Day {i+1} True', alpha=1)
        #     break
        
        # # Plot the corresponding predictions
        # for i in range(window_size):
        #     plt.plot(y_test.index, y_preds[i], label=f'Day {i+1} Predicted', linestyle='--', alpha=0.6)
        start_index = 0  # Replace with your desired starting index
        end_index = -1   # Replace with your desired ending index
        
        # Create separate plots for the true closing prices and predictions for each day in the window
        for i in range(self.window_size):
            # plt.figure(figsize=(12, 6))
            # plt.title(f'Day {i+1} - True vs. Predicted Closing Prices')
            # plt.xlabel('Date')
            # plt.ylabel('Closing Price')
            # plt.grid(True)
        
            # Plot the true closing prices for the specific range
            if i == 0:
                plt.plot(y_test.index[start_index:end_index], y_test[f'Close_{i+1}'].iloc[start_index:end_index],
                         label='True', linestyle='-')
        
            # Plot the corresponding predictions for the specific range
            plt.plot(y_test.index[start_index:end_index], y_preds[i][start_index:end_index], label='Predicted', linestyle='--')

   
        plt.legend()
        plt.show()
        return y_preds
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol, 60)
    predictions = cp.predict_windows(60)
    data = cp.data

    # future_predictions = cp.predict_future(window=30)
    # print(future_predictions)
132/64:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.window_size = window_size
        self.data = self.add_features(data)
        
       

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-05-01', '2023-12-08')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        avg_pred = np.mean(y_preds, axis=0)
        plt.figure(figsize=(10, 5))
        plt.title(f"AVERGAGE Prediction")
        plt.plot(y_test.index, y_test[f'Close_{i+0}'], label='Actual')
        plt.plot(y_test.index, avg_pred, label='Predicted', linestyle='--')
        plt.legend()
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        plt.show()
        
        # Visualize the predictions
        for i in range(window_size):
            plt.figure(figsize=(10, 5))
            plt.title(f"Day {i+1} Prediction")
            plt.plot(y_test.index, y_test[f'Close_{i+1}'], label='Actual')
            plt.plot(y_test.index, y_preds[i], label='Predicted', linestyle='--')
            plt.legend()
            plt.xlabel('Date')
            plt.ylabel('Closing Price')
            plt.grid(True)
            plt.show()

        # Create a single plot to visualize all predictions and the true closing prices
        plt.figure(figsize=(12, 6))
        plt.title('Predicted vs. True Closing Prices for Each Day in the Window')
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        
        plot(y_test.index, y_preds[i], label=f'Day {i+1} Predicted', linestyle='--', alpha=0.6)
        start_index = 0  # Replace with your desired starting index
        end_index = -1   # Replace with your desired ending index
        
        # Create separate plots for the true closing prices and predictions for each day in the window
        for i in range(self.window_size):

            # Plot the true closing prices for the specific range
            if i == 0:
                plt.plot(y_test.index[start_index:end_index], y_test[f'Close_{i+1}'].iloc[start_index:end_index],
                         label='True', linestyle='-')
        
            # Plot the corresponding predictions for the specific range
            plt.plot(y_test.index[start_index:end_index], y_preds[i][start_index:end_index], label='Predicted', linestyle='--')

   
        plt.legend()
        plt.show()
        return models
        
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol, 60)
    models = cp.predict_windows(60)
    data = cp.data

    # future_predictions = cp.predict_future(window=30)
    # print(future_predictions)
132/65:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.window_size = window_size
        self.data = self.add_features(data)
        
       

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-05-01', '2023-12-08')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        avg_pred = np.mean(y_preds, axis=0)
        plt.figure(figsize=(10, 5))
        plt.title(f"AVERGAGE Prediction")
        plt.plot(y_test.index, y_test[f'Close_{i+0}'], label='Actual')
        plt.plot(y_test.index, avg_pred, label='Predicted', linestyle='--')
        plt.legend()
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        plt.show()
        
        # Visualize the predictions
        for i in range(window_size):
            plt.figure(figsize=(10, 5))
            plt.title(f"Day {i+1} Prediction")
            plt.plot(y_test.index, y_test[f'Close_{i+1}'], label='Actual')
            plt.plot(y_test.index, y_preds[i], label='Predicted', linestyle='--')
            plt.legend()
            plt.xlabel('Date')
            plt.ylabel('Closing Price')
            plt.grid(True)
            plt.show()

        # Create a single plot to visualize all predictions and the true closing prices
        plt.figure(figsize=(12, 6))
        plt.title('Predicted vs. True Closing Prices for Each Day in the Window')
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)

        # Specify the number of days ahead to predict
        days_ahead = 10  # Change this to your desired number of days

        # Create a list to store the predictions for each day ahead
        predictions_for_days_ahead = []

        for i in range(self.window_size):
            # Plot the true closing prices for the specific day in the future
            if i == 0:
                plt.plot(
                    y_test.index[days_ahead:],
                    y_test[f'Close_{i+1}'].iloc[days_ahead:],
                    label=f'True Day {i+1}',
                    linestyle='-'
                )

            # Plot the corresponding predictions for the specific day in the future
            plt.plot(
                y_test.index[days_ahead:],
                y_preds[i][days_ahead:],
                label=f'Predicted Day {i+1}',
                linestyle='--'
            )

            # Append the prediction for the specified day ahead to the list
            predictions_for_days_ahead.append(y_preds[i][days_ahead])

        # Add a legend for the plotted lines
        plt.legend()

        # Show the plot
        plt.show()
        
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol, 60)
    models = cp.predict_windows(60)
    data = cp.data

    # future_predictions = cp.predict_future(window=30)
    # print(future_predictions)
132/66:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.window_size = window_size
        self.data = self.add_features(data)
        
       

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-05-01', '2023-12-08')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        avg_pred = np.mean(y_preds, axis=0)
        plt.figure(figsize=(10, 5))
        plt.title(f"AVERGAGE Prediction")
        plt.plot(y_test.index, y_test[f'Close_{i+0}'], label='Actual')
        plt.plot(y_test.index, avg_pred, label='Predicted', linestyle='--')
        plt.legend()
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        plt.show()
        
        # Visualize the predictions
        for i in range(window_size):
            plt.figure(figsize=(10, 5))
            plt.title(f"Day {i+1} Prediction")
            plt.plot(y_test.index, y_test[f'Close_{i+1}'], label='Actual')
            plt.plot(y_test.index, y_preds[i], label='Predicted', linestyle='--')
            plt.legend()
            plt.xlabel('Date')
            plt.ylabel('Closing Price')
            plt.grid(True)
            plt.show()

        # Create a single plot to visualize all predictions and the true closing prices
        plt.figure(figsize=(12, 6))
        plt.title('Predicted vs. True Closing Prices for Each Day in the Window')
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)

        # Specify the number of days ahead to predict
        # days_ahead = self.window_size  # Change this to your desired number of days

        # Create a list to store the predictions for each day ahead
        predictions_for_days_ahead = []

        for i in range(self.window_size):
            days_ahead = i
            # Plot the true closing prices for the specific day in the future
            if i == 0:
                plt.plot(
                    y_test.index[days_ahead:],
                    y_test[f'Close_{i+1}'].iloc[days_ahead:],
                    label=f'True Day {i+1}',
                    linestyle='-'
                )

            # Plot the corresponding predictions for the specific day in the future
            plt.plot(
                y_test.index[days_ahead:],
                y_preds[i][days_ahead:],
                label=f'Predicted Day {i+1}',
                linestyle='--'
            )

            # Append the prediction for the specified day ahead to the list
            predictions_for_days_ahead.append(y_preds[i][days_ahead])

        # Add a legend for the plotted lines
        plt.legend()

        # Show the plot
        plt.show()
        
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol, 60)
    models = cp.predict_windows(60)
    data = cp.data

    # future_predictions = cp.predict_future(window=30)
    # print(future_predictions)
132/67:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.window_size = window_size
        self.data = self.add_features(data)
        
       

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-05-01', '2023-12-08')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        avg_pred = np.mean(y_preds, axis=0)
        plt.figure(figsize=(10, 5))
        plt.title(f"AVERGAGE Prediction")
        plt.plot(y_test.index, y_test[f'Close_{i+0}'], label='Actual')
        plt.plot(y_test.index, avg_pred, label='Predicted', linestyle='--')
        plt.legend()
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        plt.show()
        
        # Visualize the predictions
        for i in range(window_size):
            plt.figure(figsize=(10, 5))
            plt.title(f"Day {i+1} Prediction")
            plt.plot(y_test.index, y_test[f'Close_{i+1}'], label='Actual')
            plt.plot(y_test.index, y_preds[i], label='Predicted', linestyle='--')
            plt.legend()
            plt.xlabel('Date')
            plt.ylabel('Closing Price')
            plt.grid(True)
            plt.show()

        # Create a single plot to visualize all predictions and the true closing prices
        plt.figure(figsize=(12, 6))
        plt.title('Predicted vs. True Closing Prices for Each Day in the Window')
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)

        # Specify the number of days ahead to predict
        # days_ahead = self.window_size  # Change this to your desired number of days

        # Create a list to store the predictions for each day ahead
        predictions_for_days_ahead = []

        for i in range(self.window_size):
            days_ahead = i
            # Plot the true closing prices for the specific day in the future
            # if i == 0:
            plt.plot(
                y_test.index[days_ahead:],
                y_test[f'Close_{i+1}'].iloc[days_ahead:],
                label=f'True Day {i+1}',
                linestyle='-'
            )

            # Plot the corresponding predictions for the specific day in the future
            plt.plot(
                y_test.index[days_ahead:],
                y_preds[i][days_ahead:],
                label=f'Predicted Day {i+1}',
                linestyle='--'
            )

            # Append the prediction for the specified day ahead to the list
            predictions_for_days_ahead.append(y_preds[i][days_ahead])

        # Add a legend for the plotted lines
        plt.legend()

        # Show the plot
        plt.show()
        
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol, 60)
    models = cp.predict_windows(60)
    data = cp.data

    # future_predictions = cp.predict_future(window=30)
    # print(future_predictions)
132/68:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.window_size = window_size
        self.data = self.add_features(data)
        
       

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-05-01', '2023-12-08')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        avg_pred = np.mean(y_preds, axis=0)
        plt.figure(figsize=(10, 5))
        plt.title(f"AVERGAGE Prediction")
        plt.plot(y_test.index, y_test[f'Close_{i+0}'], label='Actual')
        plt.plot(y_test.index, avg_pred, label='Predicted', linestyle='--')
        plt.legend()
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        plt.show()
        
        # Visualize the predictions
        for i in range(window_size):
            plt.figure(figsize=(10, 5))
            plt.title(f"Day {i+1} Prediction")
            plt.plot(y_test.index, y_test[f'Close_{i+1}'], label='Actual')
            plt.plot(y_test.index, y_preds[i], label='Predicted', linestyle='--')
            plt.legend()
            plt.xlabel('Date')
            plt.ylabel('Closing Price')
            plt.grid(True)
            plt.show()

        # Create a single plot to visualize all predictions and the true closing prices
        plt.figure(figsize=(12, 6))
        plt.title('Predicted vs. True Closing Prices for Each Day in the Window')
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)

        # Specify the number of days ahead to predict
        # days_ahead = self.window_size  # Change this to your desired number of days

        # Create a list to store the predictions for each day ahead
        predictions_for_days_ahead = []

        for i in range(self.window_size):
            days_ahead = i
            # Plot the true closing prices for the specific day in the future
            if i == 0:
                plt.plot(
                    y_test.index[days_ahead:],
                    y_test[f'Close_{i+1}'].iloc[days_ahead:],
                    label=f'True Day {i+1}',
                    linestyle='-'
                )

            # Plot the corresponding predictions for the specific day in the future
            plt.plot(
                y_test.index[days_ahead:],
                y_preds[i][days_ahead:],
                label=f'Predicted Day {i+1}',
                linestyle='--'
            )

            # Append the prediction for the specified day ahead to the list
            predictions_for_days_ahead.append(y_preds[i][days_ahead])

        # Add a legend for the plotted lines
        plt.legend()

        # Show the plot
        plt.show()
        
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol, 10)
    models = cp.predict_windows(10)
    data = cp.data

    # future_predictions = cp.predict_future(window=30)
    # print(future_predictions)
132/69:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.window_size = window_size
        self.data = self.add_features(data)
        
       

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-05-01', '2023-12-08')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        avg_pred = np.mean(y_preds, axis=0)
        plt.figure(figsize=(10, 5))
        plt.title(f"AVERGAGE Prediction")
        plt.plot(y_test.index[window_size:], y_test[f'Close_{i+0}'], label='Actual')
        plt.plot(y_test.index, avg_pred, label='Predicted', linestyle='--')
        plt.legend()
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        plt.show()
        
        # Visualize the predictions
        for i in range(window_size):
            plt.figure(figsize=(10, 5))
            plt.title(f"Day {i+1} Prediction")
            plt.plot(y_test.index, y_test[f'Close_{i+1}'], label='Actual')
            plt.plot(y_test.index, y_preds[i], label='Predicted', linestyle='--')
            plt.legend()
            plt.xlabel('Date')
            plt.ylabel('Closing Price')
            plt.grid(True)
            plt.show()

        # Create a single plot to visualize all predictions and the true closing prices
        plt.figure(figsize=(12, 6))
        plt.title('Predicted vs. True Closing Prices for Each Day in the Window')
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)

        # Specify the number of days ahead to predict
        # days_ahead = self.window_size  # Change this to your desired number of days

        # Create a list to store the predictions for each day ahead
        predictions_for_days_ahead = []

        for i in range(self.window_size):
            days_ahead = i
            # Plot the true closing prices for the specific day in the future
            if i == 0:
                plt.plot(
                    y_test.index[days_ahead:],
                    y_test[f'Close_{i+1}'].iloc[days_ahead:],
                    label=f'True Day {i+1}',
                    linestyle='-'
                )

            # Plot the corresponding predictions for the specific day in the future
            plt.plot(
                y_test.index[days_ahead:],
                y_preds[i][days_ahead:],
                label=f'Predicted Day {i+1}',
                linestyle='--'
            )

            # Append the prediction for the specified day ahead to the list
            predictions_for_days_ahead.append(y_preds[i][days_ahead])

        # Add a legend for the plotted lines
        plt.legend()

        # Show the plot
        plt.show()
        
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol, 10)
    models = cp.predict_windows(10)
    data = cp.data

    # future_predictions = cp.predict_future(window=30)
    # print(future_predictions)
132/70:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.window_size = window_size
        self.data = self.add_features(data)
        
       

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-05-01', '2023-12-08')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        avg_pred = np.mean(y_preds, axis=0)
        plt.figure(figsize=(10, 5))
        plt.title(f"AVERGAGE Prediction")
        plt.plot(y_test.index[window_size:], y_test[f'Close_{i+0}'], label='Actual')
        plt.plot(y_test.index[:-window_size, avg_pred, label='Predicted', linestyle='--')
        plt.legend()
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        plt.show()
        
        # Visualize the predictions
        for i in range(window_size):
            plt.figure(figsize=(10, 5))
            plt.title(f"Day {i+1} Prediction")
            plt.plot(y_test.index, y_test[f'Close_{i+1}'], label='Actual')
            plt.plot(y_test.index, y_preds[i], label='Predicted', linestyle='--')
            plt.legend()
            plt.xlabel('Date')
            plt.ylabel('Closing Price')
            plt.grid(True)
            plt.show()

        # Create a single plot to visualize all predictions and the true closing prices
        plt.figure(figsize=(12, 6))
        plt.title('Predicted vs. True Closing Prices for Each Day in the Window')
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)

        # Specify the number of days ahead to predict
        # days_ahead = self.window_size  # Change this to your desired number of days

        # Create a list to store the predictions for each day ahead
        predictions_for_days_ahead = []

        for i in range(self.window_size):
            days_ahead = i
            # Plot the true closing prices for the specific day in the future
            if i == 0:
                plt.plot(
                    y_test.index[days_ahead:],
                    y_test[f'Close_{i+1}'].iloc[days_ahead:],
                    label=f'True Day {i+1}',
                    linestyle='-'
                )

            # Plot the corresponding predictions for the specific day in the future
            plt.plot(
                y_test.index[days_ahead:],
                y_preds[i][days_ahead:],
                label=f'Predicted Day {i+1}',
                linestyle='--'
            )

            # Append the prediction for the specified day ahead to the list
            predictions_for_days_ahead.append(y_preds[i][days_ahead])

        # Add a legend for the plotted lines
        plt.legend()

        # Show the plot
        plt.show()
        
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol, 10)
    models = cp.predict_windows(10)
    data = cp.data

    # future_predictions = cp.predict_future(window=30)
    # print(future_predictions)
132/71:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.window_size = window_size
        self.data = self.add_features(data)
        
       

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-05-01', '2023-12-08')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        avg_pred = np.mean(y_preds, axis=0)
        plt.figure(figsize=(10, 5))
        plt.title(f"AVERGAGE Prediction")
        plt.plot(y_test.index[window_size:], y_test[f'Close_{i+0}'], label='Actual')
        plt.plot(y_test.index[:-window_size], avg_pred, label='Predicted', linestyle='--')
        plt.legend()
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        plt.show()
        
        # Visualize the predictions
        for i in range(window_size):
            plt.figure(figsize=(10, 5))
            plt.title(f"Day {i+1} Prediction")
            plt.plot(y_test.index, y_test[f'Close_{i+1}'], label='Actual')
            plt.plot(y_test.index, y_preds[i], label='Predicted', linestyle='--')
            plt.legend()
            plt.xlabel('Date')
            plt.ylabel('Closing Price')
            plt.grid(True)
            plt.show()

        # Create a single plot to visualize all predictions and the true closing prices
        plt.figure(figsize=(12, 6))
        plt.title('Predicted vs. True Closing Prices for Each Day in the Window')
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)

        # Specify the number of days ahead to predict
        # days_ahead = self.window_size  # Change this to your desired number of days

        # Create a list to store the predictions for each day ahead
        predictions_for_days_ahead = []

        for i in range(self.window_size):
            days_ahead = i
            # Plot the true closing prices for the specific day in the future
            if i == 0:
                plt.plot(
                    y_test.index[days_ahead:],
                    y_test[f'Close_{i+1}'].iloc[days_ahead:],
                    label=f'True Day {i+1}',
                    linestyle='-'
                )

            # Plot the corresponding predictions for the specific day in the future
            plt.plot(
                y_test.index[days_ahead:],
                y_preds[i][days_ahead:],
                label=f'Predicted Day {i+1}',
                linestyle='--'
            )

            # Append the prediction for the specified day ahead to the list
            predictions_for_days_ahead.append(y_preds[i][days_ahead])

        # Add a legend for the plotted lines
        plt.legend()

        # Show the plot
        plt.show()
        
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol, 10)
    models = cp.predict_windows(10)
    data = cp.data

    # future_predictions = cp.predict_future(window=30)
    # print(future_predictions)
132/72:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.window_size = window_size
        self.data = self.add_features(data)
        
       

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-05-01', '2023-12-08')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        avg_pred = np.mean(y_preds, axis=0)
        plt.figure(figsize=(10, 5))
        plt.title(f"AVERGAGE Prediction")
        plt.plot(y_test.index[window_size:], y_test[f'Close_{i+0}'][window_size:], label='Actual')
        plt.plot(y_test.index[:-window_size], avg_pred[:-window_size], label='Predicted', linestyle='--')
        plt.legend()
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        plt.show()
        
        # Visualize the predictions
        for i in range(window_size):
            plt.figure(figsize=(10, 5))
            plt.title(f"Day {i+1} Prediction")
            plt.plot(y_test.index, y_test[f'Close_{i+1}'], label='Actual')
            plt.plot(y_test.index, y_preds[i], label='Predicted', linestyle='--')
            plt.legend()
            plt.xlabel('Date')
            plt.ylabel('Closing Price')
            plt.grid(True)
            plt.show()

        # Create a single plot to visualize all predictions and the true closing prices
        plt.figure(figsize=(12, 6))
        plt.title('Predicted vs. True Closing Prices for Each Day in the Window')
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)

        # Specify the number of days ahead to predict
        # days_ahead = self.window_size  # Change this to your desired number of days

        # Create a list to store the predictions for each day ahead
        predictions_for_days_ahead = []

        for i in range(self.window_size):
            days_ahead = i
            # Plot the true closing prices for the specific day in the future
            if i == 0:
                plt.plot(
                    y_test.index[days_ahead:],
                    y_test[f'Close_{i+1}'].iloc[days_ahead:],
                    label=f'True Day {i+1}',
                    linestyle='-'
                )

            # Plot the corresponding predictions for the specific day in the future
            plt.plot(
                y_test.index[days_ahead:],
                y_preds[i][days_ahead:],
                label=f'Predicted Day {i+1}',
                linestyle='--'
            )

            # Append the prediction for the specified day ahead to the list
            predictions_for_days_ahead.append(y_preds[i][days_ahead])

        # Add a legend for the plotted lines
        plt.legend()

        # Show the plot
        plt.show()
        
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol, 10)
    models = cp.predict_windows(10)
    data = cp.data

    # future_predictions = cp.predict_future(window=30)
    # print(future_predictions)
132/73:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.window_size = window_size
        self.data = self.add_features(data)
        
       

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-05-01', '2023-12-08')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        avg_pred = np.mean(y_preds, axis=0)
        plt.figure(figsize=(10, 5))
        plt.title(f"AVERGAGE Prediction")
        plt.plot(y_test.index[window_size:], y_test[f'Close_{i+0}'][window_size:], label='Actual')
        plt.plot(y_test.index[window_size:}], avg_pred[:-window_size], label='Predicted', linestyle='--')
        plt.legend()
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        plt.show()
        
        # Visualize the predictions
        for i in range(window_size):
            plt.figure(figsize=(10, 5))
            plt.title(f"Day {i+1} Prediction")
            plt.plot(y_test.index, y_test[f'Close_{i+1}'], label='Actual')
            plt.plot(y_test.index, y_preds[i], label='Predicted', linestyle='--')
            plt.legend()
            plt.xlabel('Date')
            plt.ylabel('Closing Price')
            plt.grid(True)
            plt.show()

        # Create a single plot to visualize all predictions and the true closing prices
        plt.figure(figsize=(12, 6))
        plt.title('Predicted vs. True Closing Prices for Each Day in the Window')
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)

        # Specify the number of days ahead to predict
        # days_ahead = self.window_size  # Change this to your desired number of days

        # Create a list to store the predictions for each day ahead
        predictions_for_days_ahead = []

        for i in range(self.window_size):
            days_ahead = i
            # Plot the true closing prices for the specific day in the future
            if i == 0:
                plt.plot(
                    y_test.index[days_ahead:],
                    y_test[f'Close_{i+1}'].iloc[days_ahead:],
                    label=f'True Day {i+1}',
                    linestyle='-'
                )

            # Plot the corresponding predictions for the specific day in the future
            plt.plot(
                y_test.index[days_ahead:],
                y_preds[i][days_ahead:],
                label=f'Predicted Day {i+1}',
                linestyle='--'
            )

            # Append the prediction for the specified day ahead to the list
            predictions_for_days_ahead.append(y_preds[i][days_ahead])

        # Add a legend for the plotted lines
        plt.legend()

        # Show the plot
        plt.show()
        
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol, 10)
    models = cp.predict_windows(10)
    data = cp.data

    # future_predictions = cp.predict_future(window=30)
    # print(future_predictions)
132/75:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.window_size = window_size
        self.data = self.add_features(data)
        
       

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-05-01', '2023-12-08')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        avg_pred = np.mean(y_preds, axis=0)
        plt.figure(figsize=(10, 5))
        plt.title(f"AVERGAGE Prediction")
        plt.plot(y_test.index[window_size:], y_test[f'Close_{i+0}'][window_size:], label='Actual')
        plt.plot(y_test.index[window_size:], avg_pred[:-window_size], label='Predicted', linestyle='--')
        plt.legend()
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        plt.show()
        
        # Visualize the predictions
        for i in range(window_size):
            plt.figure(figsize=(10, 5))
            plt.title(f"Day {i+1} Prediction")
            plt.plot(y_test.index, y_test[f'Close_{i+1}'], label='Actual')
            plt.plot(y_test.index, y_preds[i], label='Predicted', linestyle='--')
            plt.legend()
            plt.xlabel('Date')
            plt.ylabel('Closing Price')
            plt.grid(True)
            plt.show()

        # Create a single plot to visualize all predictions and the true closing prices
        plt.figure(figsize=(12, 6))
        plt.title('Predicted vs. True Closing Prices for Each Day in the Window')
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)

        # Specify the number of days ahead to predict
        # days_ahead = self.window_size  # Change this to your desired number of days

        # Create a list to store the predictions for each day ahead
        predictions_for_days_ahead = []

        for i in range(self.window_size):
            days_ahead = i
            # Plot the true closing prices for the specific day in the future
            if i == 0:
                plt.plot(
                    y_test.index[days_ahead:],
                    y_test[f'Close_{i+1}'].iloc[days_ahead:],
                    label=f'True Day {i+1}',
                    linestyle='-'
                )

            # Plot the corresponding predictions for the specific day in the future
            plt.plot(
                y_test.index[days_ahead:],
                y_preds[i][days_ahead:],
                label=f'Predicted Day {i+1}',
                linestyle='--'
            )

            # Append the prediction for the specified day ahead to the list
            predictions_for_days_ahead.append(y_preds[i][days_ahead])

        # Add a legend for the plotted lines
        plt.legend()

        # Show the plot
        plt.show()
        
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol, 10)
    models = cp.predict_windows(10)
    data = cp.data

    # future_predictions = cp.predict_future(window=30)
    # print(future_predictions)
132/76:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.window_size = window_size
        self.data = self.add_features(data)
        
       

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-05-01', '2023-12-08')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        avg_pred = np.mean(y_preds, axis=0)
        plt.figure(figsize=(10, 5))
        plt.title(f"AVERGAGE Prediction")
        plt.plot(y_test.index[window_size:], y_test[f'Close_{i+0}'][:-window_size], label='Actual')
        plt.plot(y_test.index[window_size:], avg_pred[window_size:], label='Predicted', linestyle='--')
        plt.legend()
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        plt.show()
        
        # Visualize the predictions
        for i in range(window_size):
            plt.figure(figsize=(10, 5))
            plt.title(f"Day {i+1} Prediction")
            plt.plot(y_test.index, y_test[f'Close_{i+1}'], label='Actual')
            plt.plot(y_test.index, y_preds[i], label='Predicted', linestyle='--')
            plt.legend()
            plt.xlabel('Date')
            plt.ylabel('Closing Price')
            plt.grid(True)
            plt.show()

        # Create a single plot to visualize all predictions and the true closing prices
        plt.figure(figsize=(12, 6))
        plt.title('Predicted vs. True Closing Prices for Each Day in the Window')
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)

        # Specify the number of days ahead to predict
        # days_ahead = self.window_size  # Change this to your desired number of days

        # Create a list to store the predictions for each day ahead
        predictions_for_days_ahead = []

        for i in range(self.window_size):
            days_ahead = i
            # Plot the true closing prices for the specific day in the future
            if i == 0:
                plt.plot(
                    y_test.index[days_ahead:],
                    y_test[f'Close_{i+1}'].iloc[days_ahead:],
                    label=f'True Day {i+1}',
                    linestyle='-'
                )

            # Plot the corresponding predictions for the specific day in the future
            plt.plot(
                y_test.index[days_ahead:],
                y_preds[i][days_ahead:],
                label=f'Predicted Day {i+1}',
                linestyle='--'
            )

            # Append the prediction for the specified day ahead to the list
            predictions_for_days_ahead.append(y_preds[i][days_ahead])

        # Add a legend for the plotted lines
        plt.legend()

        # Show the plot
        plt.show()
        
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol, 10)
    models = cp.predict_windows(10)
    data = cp.data

    # future_predictions = cp.predict_future(window=30)
    # print(future_predictions)
132/77:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.window_size = window_size
        self.data = self.add_features(data)
        
       

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-05-01', '2023-12-08')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        avg_pred = np.mean(y_preds, axis=0)
        plt.figure(figsize=(10, 5))
        plt.title(f"AVERGAGE Prediction")
        plt.plot(y_test.index[window_size:], y_test[f'Close_{i+0}'][:-window_size], label='Actual')
        plt.plot(y_test.index[window_size:], avg_pred[window_size:], label='Predicted', linestyle='--')
        plt.legend()
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        plt.show()
        
        # Visualize the predictions
        for i in range(window_size):
            plt.figure(figsize=(10, 5))
            plt.title(f"Day {i+1} Prediction")
            plt.plot(y_test.index[window_size:], y_test[f'Close_{i+1}'][:-window_size], label='Actual')
            plt.plot(y_test.index[window_size:], y_preds[i][window_size:], label='Predicted', linestyle='--')
            plt.legend()
            plt.xlabel('Date')
            plt.ylabel('Closing Price')
            plt.grid(True)
            plt.show()

        # Create a single plot to visualize all predictions and the true closing prices
        plt.figure(figsize=(12, 6))
        plt.title('Predicted vs. True Closing Prices for Each Day in the Window')
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)

        # Specify the number of days ahead to predict
        # days_ahead = self.window_size  # Change this to your desired number of days

        # Create a list to store the predictions for each day ahead
        predictions_for_days_ahead = []

        for i in range(self.window_size):
            days_ahead = i
            # Plot the true closing prices for the specific day in the future
            if i == 0:
                plt.plot(
                    y_test.index[days_ahead:],
                    y_test[f'Close_{i+1}'].iloc[days_ahead:],
                    label=f'True Day {i+1}',
                    linestyle='-'
                )

            # Plot the corresponding predictions for the specific day in the future
            plt.plot(
                y_test.index[days_ahead:],
                y_preds[i][days_ahead:],
                label=f'Predicted Day {i+1}',
                linestyle='--'
            )

            # Append the prediction for the specified day ahead to the list
            predictions_for_days_ahead.append(y_preds[i][days_ahead])

        # Add a legend for the plotted lines
        plt.legend()

        # Show the plot
        plt.show()
        
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol, 10)
    models = cp.predict_windows(10)
    data = cp.data

    # future_predictions = cp.predict_future(window=30)
    # print(future_predictions)
132/78:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.window_size = window_size
        self.data = self.add_features(data)
        
       

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-05-01', '2023-12-08')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        avg_pred = np.mean(y_preds, axis=0)
        plt.figure(figsize=(10, 5))
        plt.title(f"AVERGAGE Prediction")
        plt.plot(y_test.index[window_size:], y_test[f'Close_{i+0}'][:-window_size], label='Actual')
        plt.plot(y_test.index[window_size:], avg_pred[window_size:], label='Predicted', linestyle='--')
        plt.legend()
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        plt.show()
        
        # Visualize the predictions
        for i in range(window_size):
            plt.figure(figsize=(10, 5))
            plt.title(f"Day {i+1} Prediction")
            plt.plot(y_test.index[window_size:], y_test[f'Close_{i+1}'][:-window_size], label='Actual')
            plt.plot(y_test.index[window_size:], y_preds[i][window_size:], label='Predicted', linestyle='--')
            plt.legend()
            plt.xlabel('Date')
            plt.ylabel('Closing Price')
            plt.grid(True)
            plt.show()

        # Create a single plot to visualize all predictions and the true closing prices
        plt.figure(figsize=(12, 6))
        plt.title('Predicted vs. True Closing Prices for Each Day in the Window')
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)

        # Specify the number of days ahead to predict
        # days_ahead = self.window_size  # Change this to your desired number of days

        # Create a list to store the predictions for each day ahead
        # predictions_for_days_ahead = []

        # for i in range(self.window_size):
        #     days_ahead = i
        #     # Plot the true closing prices for the specific day in the future
        #     # if i == 0:
        #     plt.plot(
        #         y_test.index[days_ahead:],
        #         y_test[f'Close_{i+1}'].iloc[days_ahead:],
        #         label=f'True Day {i+1}',
        #         linestyle='-'
        #     )

        #     # Plot the corresponding predictions for the specific day in the future
        #     plt.plot(
        #         y_test.index[days_ahead:],
        #         y_preds[i][days_ahead:],
        #         label=f'Predicted Day {i+1}',
        #         linestyle='--'
        #     )

        #     # Append the prediction for the specified day ahead to the list
        #     predictions_for_days_ahead.append(y_preds[i][days_ahead])

        # Add a legend for the plotted lines
        plt.legend()

        # Show the plot
        plt.show()
        
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol, 10)
    models = cp.predict_windows(10)
    data = cp.data

    # future_predictions = cp.predict_future(window=30)
    # print(future_predictions)
132/79:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.window_size = window_size
        self.data = self.add_features(data)
        
       

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-05-01', '2023-12-08')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        avg_pred = np.mean(y_preds, axis=0)
        plt.figure(figsize=(10, 5))
        plt.title(f"AVERGAGE Prediction")
        plt.plot(y_test.index[window_size:], y_test[f'Close_{i+0}'][:-window_size], label='Actual')
        plt.plot(y_test.index[window_size:], avg_pred[window_size:], label='Predicted', linestyle='--')
        plt.legend()
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        plt.show()
        
        # Visualize the predictions
        for i in range(window_size):
            plt.figure(figsize=(10, 5))
            plt.title(f"Day {i+1} Prediction")
            plt.plot(y_test.index[window_size:], y_test[f'Close_{i+1}'][:-window_size], label='Actual')
            plt.plot(y_test.index[window_size:], y_preds[i][window_size:], label='Predicted', linestyle='--')
            plt.legend()
            plt.xlabel('Date')
            plt.ylabel('Closing Price')
            plt.grid(True)
            plt.show()

        # Create a single plot to visualize all predictions and the true closing prices
        plt.figure(figsize=(12, 6))
        plt.title('Predicted vs. True Closing Prices for Each Day in the Window')
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)

        # Specify the number of days ahead to predict
        # days_ahead = self.window_size  # Change this to your desired number of days

        # Create a list to store the predictions for each day ahead
        # predictions_for_days_ahead = []

        # for i in range(self.window_size):
        #     days_ahead = i
        #     # Plot the true closing prices for the specific day in the future
        #     # if i == 0:
        #     plt.plot(
        #         y_test.index[days_ahead:],
        #         y_test[f'Close_{i+1}'].iloc[days_ahead:],
        #         label=f'True Day {i+1}',
        #         linestyle='-'
        #     )

        #     # Plot the corresponding predictions for the specific day in the future
        #     plt.plot(
        #         y_test.index[days_ahead:],
        #         y_preds[i][days_ahead:],
        #         label=f'Predicted Day {i+1}',
        #         linestyle='--'
        #     )

        #     # Append the prediction for the specified day ahead to the list
        #     predictions_for_days_ahead.append(y_preds[i][days_ahead])

        # Add a legend for the plotted lines
        plt.legend()

        # Show the plot
        plt.show()
        
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol, 4)
    models = cp.predict_windows(4)
    data = cp.data

    # future_predictions = cp.predict_future(window=30)
    # print(future_predictions)
132/80:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.window_size = window_size
        self.data = self.add_features(data)
        
       

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-05-01', '2023-12-08')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        avg_pred = np.mean(y_preds, axis=0)
        plt.figure(figsize=(10, 5))
        plt.title(f"AVERGAGE Prediction")
        plt.plot(y_test.index[window_size:], y_test[f'Close_{i+0}'][:-window_size], label='Actual')
        plt.plot(y_test.index[window_size:], avg_pred[window_size:], label='Predicted', linestyle='--')
        plt.legend()
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        plt.show()
        
        # Visualize the predictions
        for i in range(window_size):
            plt.figure(figsize=(10, 5))
            plt.title(f"Day {i+1} Prediction")
            plt.plot(y_test.index[i:], y_test[f'Close_{i+1}'][:-i], label='Actual')
            plt.plot(y_test.index[i:], y_preds[i][i:], label='Predicted', linestyle='--')
            plt.legend()
            plt.xlabel('Date')
            plt.ylabel('Closing Price')
            plt.grid(True)
            plt.show()

        # Add a legend for the plotted lines
        plt.legend()

        # Show the plot
        plt.show()
        
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol, 4)
    models = cp.predict_windows(4)
    data = cp.data

    # future_predictions = cp.predict_future(window=30)
    # print(future_predictions)
132/81:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.window_size = window_size
        self.data = self.add_features(data)
        
       

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-05-01', '2023-12-08')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        avg_pred = np.mean(y_preds, axis=0)
        plt.figure(figsize=(10, 5))
        plt.title(f"AVERGAGE Prediction")
        plt.plot(y_test.index[window_size:], y_test[f'Close_{i+0}'][:-window_size], label='Actual')
        plt.plot(y_test.index[window_size:], avg_pred[window_size:], label='Predicted', linestyle='--')
        plt.legend()
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        plt.show()
        
        # Visualize the predictions
        for i in range(window_size):
            if i == 0:
                i = 1
            plt.figure(figsize=(10, 5))
            plt.title(f"Day {i+1} Prediction")
            plt.plot(y_test.index[i:], y_test[f'Close_{i+1}'][:-i], label='Actual')
            plt.plot(y_test.index[i:], y_preds[i][i:], label='Predicted', linestyle='--')
            plt.legend()
            plt.xlabel('Date')
            plt.ylabel('Closing Price')
            plt.grid(True)
            plt.show()

        # Add a legend for the plotted lines
        plt.legend()

        # Show the plot
        plt.show()
        
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    cp = CryptoPrediction(crypto_symbol, 4)
    models = cp.predict_windows(4)
    data = cp.data

    # future_predictions = cp.predict_future(window=30)
    # print(future_predictions)
132/82:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.window_size = window_size
        self.data = self.add_features(data)
        
       

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-05-01', '2023-12-08')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        avg_pred = np.mean(y_preds, axis=0)
        plt.figure(figsize=(10, 5))
        plt.title(f"AVERGAGE Prediction")
        plt.plot(y_test.index[window_size:], y_test[f'Close_{i+0}'][:-window_size], label='Actual')
        plt.plot(y_test.index[window_size:], avg_pred[window_size:], label='Predicted', linestyle='--')
        plt.legend()
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        plt.show()
        
        # Visualize the predictions
        for i in range(window_size):
            if i == 0:
                i = 1
            plt.figure(figsize=(10, 5))
            plt.title(f"Day {i+1} Prediction")
            plt.plot(y_test.index[i:], y_test[f'Close_{i+1}'][:-i], label='Actual')
            plt.plot(y_test.index[i:], y_preds[i][i:], label='Predicted', linestyle='--')
            plt.legend()
            plt.xlabel('Date')
            plt.ylabel('Closing Price')
            plt.grid(True)
            plt.show()

        # Add a legend for the plotted lines
        plt.legend()

        # Show the plot
        plt.show()
        
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "BTC-USD"  # Replace with your desired cryptocurrency symbol
    window = 60
    cp = CryptoPrediction(crypto_symbol, window)
    models = cp.predict_windows(window)
    data = cp.data

    # future_predictions = cp.predict_future(window=30)
    # print(future_predictions)
132/83:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.window_size = window_size
        self.data = self.add_features(data)
        
       

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-05-01', '2023-12-08')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        avg_pred = np.mean(y_preds, axis=0)
        plt.figure(figsize=(10, 5))
        plt.title(f"AVERGAGE Prediction")
        plt.plot(y_test.index[window_size:], y_test[f'Close_{i+0}'][:-window_size], label='Actual')
        plt.plot(y_test.index[window_size:], avg_pred[window_size:], label='Predicted', linestyle='--')
        plt.legend()
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        plt.show()
        
        # Visualize the predictions
        for i in range(window_size):
            if i == 0:
                i = 1
            plt.figure(figsize=(10, 5))
            plt.title(f"Day {i+1} Prediction")
            plt.plot(y_test.index[i:], y_test[f'Close_{i+1}'][:-i], label='Actual')
            plt.plot(y_test.index[i:], y_preds[i][i:], label='Predicted', linestyle='--')
            plt.legend()
            plt.xlabel('Date')
            plt.ylabel('Closing Price')
            plt.grid(True)
            plt.show()

        # Add a legend for the plotted lines
        plt.legend()

        # Show the plot
        plt.show()
        
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "ADA-USD"  # Replace with your desired cryptocurrency symbol
    window = 60
    cp = CryptoPrediction(crypto_symbol, window)
    models = cp.predict_windows(window)
    data = cp.data

    # future_predictions = cp.predict_future(window=30)
    # print(future_predictions)
132/84:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.window_size = window_size
        self.data = self.add_features(data)
        
       

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-05-01', '2023-12-08')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        avg_pred = np.mean(y_preds, axis=0)
        plt.figure(figsize=(10, 5))
        plt.title(f"AVERGAGE Prediction")
        plt.plot(y_test.index[window_size:], y_test[f'Close_{i+0}'][:-window_size], label='Actual')
        plt.plot(y_test.index[window_size:], avg_pred[window_size:], label='Predicted', linestyle='--')
        plt.legend()
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        plt.show()
        
        # Visualize the predictions
        for i in range(window_size):
            if i == 0:
                i = 1
            plt.figure(figsize=(10, 5))
            plt.title(f"Day {i+1} Prediction")
            plt.plot(y_test.index[i:], y_test[f'Close_{i+1}'][:-i], label='Actual')
            plt.plot(y_test.index[i:], y_preds[i][i:], label='Predicted', linestyle='--')
            plt.legend()
            plt.xlabel('Date')
            plt.ylabel('Closing Price')
            plt.grid(True)
            plt.show()

        # Add a legend for the plotted lines
        plt.legend()

        # Show the plot
        plt.show()
        
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

    def forecast_window(self, window_size=30, forecast_steps=10):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)

        # Create a list to store the forecasts for each day ahead
        forecasts = []

        for i in range(forecast_steps):
            future_features = X_test.iloc[i:i+1]  # Take one day's worth of features
            day_ahead_predictions = []

            for model in models:
                y_pred = model.predict(future_features)
                day_ahead_predictions.append(y_pred[0])

            # Append the predictions for the day ahead to the list of forecasts
            forecasts.append(day_ahead_predictions)

            # Update the features for the next day by shifting them forward
            future_features = future_features.shift(-1)
            future_features['SMA5'] = future_features['SMA5'].fillna(future_features['SMA5'].iloc[-1])
            future_features['SMA20'] = future_features['SMA20'].fillna(future_features['SMA20'].iloc[-1])
            future_features['SMA60'] = future_features['SMA60'].fillna(future_features['SMA60'].iloc[-1])

        # Create a DataFrame to store the forecasts
        forecast_df = pd.DataFrame(forecasts, columns=[f'Day_{i+1}' for i in range(forecast_steps)], index=y_test.index[:forecast_steps])

        # Plot the forecasts
        plt.figure(figsize=(12, 6))
        plt.title('Forecasts for Closing Prices in the Window')
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)

        for i in range(forecast_steps):
            plt.plot(forecast_df.index, forecast_df[f'Day_{i+1}'], label=f'Day {i+1} Forecast', linestyle='--')

        # Add a legend for the plotted lines
        plt.legend()

        # Show the plot
        plt.show()

        # Return the forecasts DataFrame
        return forecast_df

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "ADA-USD"  # Replace with your desired cryptocurrency symbol
    window = 60
    cp = CryptoPrediction(crypto_symbol, window)
    models = cp.predict_windows(window)
    data = cp.data

    # future_predictions = cp.predict_future(window=30)
    # print(future_predictions)
    forecast_steps = 10  # Specify the number of forecast steps
    forecasts = cp.forecast_window(60, forecast_steps)
    print(forecasts)
132/85:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.window_size = window_size
        self.data = self.add_features(data)
        
       

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-05-01', '2023-12-08')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        avg_pred = np.mean(y_preds, axis=0)
        plt.figure(figsize=(10, 5))
        plt.title(f"AVERGAGE Prediction")
        plt.plot(y_test.index[window_size:], y_test[f'Close_{i+0}'][:-window_size], label='Actual')
        plt.plot(y_test.index[window_size:], avg_pred[window_size:], label='Predicted', linestyle='--')
        plt.legend()
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        plt.show()
        
        # Visualize the predictions
        for i in range(window_size):
            if i == 0:
                i = 1
            plt.figure(figsize=(10, 5))
            plt.title(f"Day {i+1} Prediction")
            plt.plot(y_test.index[i:], y_test[f'Close_{i+1}'][:-i], label='Actual')
            plt.plot(y_test.index[i:], y_preds[i][i:], label='Predicted', linestyle='--')
            plt.legend()
            plt.xlabel('Date')
            plt.ylabel('Closing Price')
            plt.grid(True)
            plt.show()

        # Add a legend for the plotted lines
        plt.legend()

        # Show the plot
        plt.show()
        
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

    def forecast_window(self, window_size=30, forecast_steps=10):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)

        # Create a list to store the forecasts for each day ahead
        forecasts = []

        for i in range(forecast_steps):
            future_features = X_test.iloc[i:i+1]  # Take one day's worth of features
            day_ahead_predictions = []

            for model in models:
                y_pred = model.predict(future_features)
                day_ahead_predictions.append(y_pred[0])

            # Append the predictions for the day ahead to the list of forecasts
            forecasts.append(day_ahead_predictions)

            # Update the features for the next day by shifting them forward
            future_features = future_features.shift(-1)
            future_features['SMA5'] = future_features['SMA5'].fillna(future_features['SMA5'].iloc[-1])
            future_features['SMA20'] = future_features['SMA20'].fillna(future_features['SMA20'].iloc[-1])
            future_features['SMA60'] = future_features['SMA60'].fillna(future_features['SMA60'].iloc[-1])

        # Create a DataFrame to store the forecasts
        forecast_df = pd.DataFrame(forecasts, columns=[f'Day_{i+1}' for i in range(forecast_steps)], index=y_test.index[:forecast_steps])

        # Plot the forecasts
        plt.figure(figsize=(12, 6))
        plt.title('Forecasts for Closing Prices in the Window')
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)

        for i in range(forecast_steps):
            plt.plot(forecast_df.index, forecast_df[f'Day_{i+1}'], label=f'Day {i+1} Forecast', linestyle='--')

        # Add a legend for the plotted lines
        plt.legend()

        # Show the plot
        plt.show()

        # Return the forecasts DataFrame
        return forecast_df

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "ADA-USD"  # Replace with your desired cryptocurrency symbol
    window = 10
    cp = CryptoPrediction(crypto_symbol, window)
    models = cp.predict_windows(window)
    data = cp.data

    # future_predictions = cp.predict_future(window=30)
    # print(future_predictions)
    forecast_steps = 10  # Specify the number of forecast steps
    forecasts = cp.forecast_window(60, forecast_steps)
    print(forecasts)
132/86:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.window_size = window_size
        self.data = self.add_features(data)
        
       

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-05-01', '2023-12-08')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        avg_pred = np.mean(y_preds, axis=0)
        plt.figure(figsize=(10, 5))
        plt.title(f"AVERGAGE Prediction")
        plt.plot(y_test.index[window_size:], y_test[f'Close_{i+0}'][:-window_size], label='Actual')
        plt.plot(y_test.index[window_size:], avg_pred[window_size:], label='Predicted', linestyle='--')
        plt.legend()
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        plt.show()
        
        # Visualize the predictions
        for i in range(window_size):
            if i == 0:
                i = 1
            plt.figure(figsize=(10, 5))
            plt.title(f"Day {i+1} Prediction")
            plt.plot(y_test.index[i:], y_test[f'Close_{i+1}'][:-i], label='Actual')
            plt.plot(y_test.index[i:], y_preds[i][i:], label='Predicted', linestyle='--')
            plt.legend()
            plt.xlabel('Date')
            plt.ylabel('Closing Price')
            plt.grid(True)
            plt.show()

        # Add a legend for the plotted lines
        plt.legend()

        # Show the plot
        plt.show()
        
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

    def forecast_window(self, window_size=30, forecast_steps=10):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)

        # Create a list to store the forecasts for each day ahead
        forecasts = []

        for i in range(forecast_steps):
            future_features = X_test.iloc[i:i+1]  # Take one day's worth of features
            day_ahead_predictions = []

            for model in models:
                y_pred = model.predict(future_features)
                day_ahead_predictions.append(y_pred[0])

            # Append the predictions for the day ahead to the list of forecasts
            forecasts.append(day_ahead_predictions)

            # Update the features for the next day by shifting them forward
            future_features = future_features.shift(-1)
            future_features['SMA5'] = future_features['SMA5'].fillna(future_features['SMA5'].iloc[-1])
            future_features['SMA20'] = future_features['SMA20'].fillna(future_features['SMA20'].iloc[-1])
            future_features['SMA60'] = future_features['SMA60'].fillna(future_features['SMA60'].iloc[-1])

        # Create a DataFrame to store the forecasts
        forecast_df = pd.DataFrame(forecasts, columns=[f'Day_{i+1}' for i in range(forecast_steps)], index=y_test.index[:forecast_steps])

        # Plot the forecasts
        plt.figure(figsize=(12, 6))
        plt.title('Forecasts for Closing Prices in the Window')
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)

        for i in range(forecast_steps):
            plt.plot(forecast_df.index, forecast_df[f'Day_{i+1}'], label=f'Day {i+1} Forecast', linestyle='--')

        # Add a legend for the plotted lines
        plt.legend()

        # Show the plot
        plt.show()

        # Return the forecasts DataFrame
        return forecast_df

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "ADA-USD"  # Replace with your desired cryptocurrency symbol
    window = 2
    cp = CryptoPrediction(crypto_symbol, window)
    models = cp.predict_windows(window)
    data = cp.data

    # future_predictions = cp.predict_future(window=30)
    # print(future_predictions)
    forecast_steps = 20  # Specify the number of forecast steps
    forecasts = cp.forecast_window(60, forecast_steps)
    print(forecasts)
132/87:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.window_size = window_size
        self.data = self.add_features(data)
        
       

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-05-01', '2023-12-08')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        avg_pred = np.mean(y_preds, axis=0)
        plt.figure(figsize=(10, 5))
        plt.title(f"AVERGAGE Prediction")
        plt.plot(y_test.index[window_size:], y_test[f'Close_{i+0}'][:-window_size], label='Actual')
        plt.plot(y_test.index[window_size:], avg_pred[window_size:], label='Predicted', linestyle='--')
        plt.legend()
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        plt.show()
        
        # Visualize the predictions
        for i in range(window_size):
            if i == 0:
                i = 1
            plt.figure(figsize=(10, 5))
            plt.title(f"Day {i+1} Prediction")
            plt.plot(y_test.index[i:], y_test[f'Close_{i+1}'][:-i], label='Actual')
            plt.plot(y_test.index[i:], y_preds[i][i:], label='Predicted', linestyle='--')
            plt.legend()
            plt.xlabel('Date')
            plt.ylabel('Closing Price')
            plt.grid(True)
            plt.show()

        # Add a legend for the plotted lines
        plt.legend()

        # Show the plot
        plt.show()
        
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

    def forecast_window(self, window_size=30, forecast_steps=10):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)

        # Create a list to store the forecasts for each day ahead
        forecasts = []

        for i in range(forecast_steps):
            future_features = X_test.iloc[i:i+1]  # Take one day's worth of features
            day_ahead_predictions = []

            for model in models:
                y_pred = model.predict(future_features)
                day_ahead_predictions.append(y_pred[0])

            # Append the predictions for the day ahead to the list of forecasts
            forecasts.append(day_ahead_predictions)

            # Update the features for the next day by shifting them forward
            future_features = future_features.shift(-1)
            future_features['SMA5'] = future_features['SMA5'].fillna(future_features['SMA5'].iloc[-1])
            future_features['SMA20'] = future_features['SMA20'].fillna(future_features['SMA20'].iloc[-1])
            future_features['SMA60'] = future_features['SMA60'].fillna(future_features['SMA60'].iloc[-1])

        # Create a DataFrame to store the forecasts
        forecast_df = pd.DataFrame(forecasts, columns=[f'Day_{i+1}' for i in range(forecast_steps)], index=y_test.index[:forecast_steps])

        # Plot the forecasts
        plt.figure(figsize=(12, 6))
        plt.title('Forecasts for Closing Prices in the Window')
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)

        for i in range(forecast_steps):
            plt.plot(forecast_df.index, forecast_df[f'Day_{i+1}'], label=f'Day {i+1} Forecast', linestyle='--')

        # Add a legend for the plotted lines
        plt.legend()

        # Show the plot
        plt.show()

        # Return the forecasts DataFrame
        return forecast_df

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "ADA-USD"  # Replace with your desired cryptocurrency symbol
    window = 2
    cp = CryptoPrediction(crypto_symbol, window)
    models = cp.predict_windows(window)
    data = cp.data

    # future_predictions = cp.predict_future(window=30)
    # print(future_predictions)
    forecast_steps = 10  # Specify the number of forecast steps
    forecasts = cp.forecast_window(60, forecast_steps)
    print(forecasts)
132/88:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.window_size = window_size
        self.data = self.add_features(data)
        
       

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-05-01', '2023-12-08')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        avg_pred = np.mean(y_preds, axis=0)
        plt.figure(figsize=(10, 5))
        plt.title(f"AVERGAGE Prediction")
        plt.plot(y_test.index[window_size:], y_test[f'Close_{i+0}'][:-window_size], label='Actual')
        plt.plot(y_test.index[window_size:], avg_pred[window_size:], label='Predicted', linestyle='--')
        plt.legend()
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        plt.show()
        
        # Visualize the predictions
        for i in range(window_size):
            if i == 0:
                i = 1
            plt.figure(figsize=(10, 5))
            plt.title(f"Day {i+1} Prediction")
            plt.plot(y_test.index[i:], y_test[f'Close_{i+1}'][:-i], label='Actual')
            plt.plot(y_test.index[i:], y_preds[i][i:], label='Predicted', linestyle='--')
            plt.legend()
            plt.xlabel('Date')
            plt.ylabel('Closing Price')
            plt.grid(True)
            plt.show()

        # Add a legend for the plotted lines
        plt.legend()

        # Show the plot
        plt.show()
        
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

    def forecast_window(self, window_size=30, forecast_steps=10):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)

        # Create a list to store the forecasts for each day ahead
        forecasts = []

        for i in range(forecast_steps):
            future_features = X_test.iloc[i:i+1]  # Take one day's worth of features
            day_ahead_predictions = []

            for model in models:
                y_pred = model.predict(future_features)
                day_ahead_predictions.append(y_pred[0])

            # Append the predictions for the day ahead to the list of forecasts
            forecasts.append(day_ahead_predictions)

            # Update the features for the next day by shifting them forward
            future_features = future_features.shift(-1)
            future_features['SMA5'] = future_features['SMA5'].fillna(future_features['SMA5'].iloc[-1])
            future_features['SMA20'] = future_features['SMA20'].fillna(future_features['SMA20'].iloc[-1])
            future_features['SMA60'] = future_features['SMA60'].fillna(future_features['SMA60'].iloc[-1])

        # Create a DataFrame to store the forecasts
        forecast_df = pd.DataFrame(forecasts, columns=[f'Day_{i+1}' for i in range(forecast_steps)], index=y_test.index[:forecast_steps])

        # Plot the forecasts
        plt.figure(figsize=(12, 6))
        plt.title('Forecasts for Closing Prices in the Window')
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)

        for i in range(forecast_steps):
            plt.plot(forecast_df.index, forecast_df[f'Day_{i+1}'], label=f'Day {i+1} Forecast', linestyle='--')

        # Add a legend for the plotted lines
        plt.legend()

        # Show the plot
        plt.show()

        # Return the forecasts DataFrame
        return forecast_df

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "ADA-USD"  # Replace with your desired cryptocurrency symbol
    window = 20
    cp = CryptoPrediction(crypto_symbol, window)
    models = cp.predict_windows(window)
    data = cp.data

    # future_predictions = cp.predict_future(window=30)
    # print(future_predictions)
    forecast_steps = 20  # Specify the number of forecast steps
    forecasts = cp.forecast_window(60, forecast_steps)
    print(forecasts)
132/89:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.window_size = window_size
        self.data = self.add_features(data)
        
       

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-05-01', '2023-12-08')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        avg_pred = np.mean(y_preds, axis=0)
        plt.figure(figsize=(10, 5))
        plt.title(f"AVERGAGE Prediction")
        plt.plot(y_test.index[window_size:], y_test[f'Close_{i+0}'][:-window_size], label='Actual')
        plt.plot(y_test.index[window_size:], avg_pred[window_size:], label='Predicted', linestyle='--')
        plt.legend()
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        plt.show()
        
        # Visualize the predictions
        for i in range(window_size):
            if i == 0:
                i = 1
            plt.figure(figsize=(10, 5))
            plt.title(f"Day {i+1} Prediction")
            plt.plot(y_test.index[i:], y_test[f'Close_{i+1}'][:-i], label='Actual')
            plt.plot(y_test.index[i:], y_preds[i][i:], label='Predicted', linestyle='--')
            plt.legend()
            plt.xlabel('Date')
            plt.ylabel('Closing Price')
            plt.grid(True)
            plt.show()

        # Add a legend for the plotted lines
        plt.legend()

        # Show the plot
        plt.show()
        
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

    def forecast_window(self, window_size=30, forecast_steps=10):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)

        # Create a list to store the forecasts for each day ahead
        forecasts = []

        for i in range(forecast_steps):
            future_features = X_test.iloc[i:i+1]  # Take one day's worth of features
            day_ahead_predictions = []

            for model in models:
                y_pred = model.predict(future_features)
                day_ahead_predictions.append(y_pred[0])

            # Append the predictions for the day ahead to the list of forecasts
            forecasts.append(day_ahead_predictions)

            # Update the features for the next day by shifting them forward
            future_features = future_features.shift(-1)
            future_features['SMA5'] = future_features['SMA5'].fillna(future_features['SMA5'].iloc[-1])
            future_features['SMA20'] = future_features['SMA20'].fillna(future_features['SMA20'].iloc[-1])
            future_features['SMA60'] = future_features['SMA60'].fillna(future_features['SMA60'].iloc[-1])

        # Create a DataFrame to store the forecasts
        forecast_df = pd.DataFrame(forecasts, columns=[f'Day_{i+1}' for i in range(forecast_steps)], index=y_test.index[:forecast_steps])

        # Plot the forecasts
        plt.figure(figsize=(12, 6))
        plt.title('Forecasts for Closing Prices in the Window')
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)

        for i in range(forecast_steps):
            plt.plot(forecast_df.index, forecast_df[f'Day_{i+1}'], label=f'Day {i+1} Forecast', linestyle='--')

        # Add a legend for the plotted lines
        plt.legend()

        # Show the plot
        plt.show()

        # Return the forecasts DataFrame
        return forecast_df

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "ADA-USD"  # Replace with your desired cryptocurrency symbol
    window = 20
    cp = CryptoPrediction(crypto_symbol, window)
    # models = cp.predict_windows(window)
    data = cp.data

    # future_predictions = cp.predict_future(window=30)
    # print(future_predictions)
    forecast_steps = 20  # Specify the number of forecast steps
    forecasts = cp.forecast_window(60, forecast_steps)
    print(forecasts)
132/90:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.window_size = window_size
        self.data = self.add_features(data)
        
       

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-05-01', '2023-12-08')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        avg_pred = np.mean(y_preds, axis=0)
        plt.figure(figsize=(10, 5))
        plt.title(f"AVERGAGE Prediction")
        plt.plot(y_test.index[window_size:], y_test[f'Close_{i+0}'][:-window_size], label='Actual')
        plt.plot(y_test.index[window_size:], avg_pred[window_size:], label='Predicted', linestyle='--')
        plt.legend()
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        plt.show()
        
        # Visualize the predictions
        for i in range(window_size):
            if i == 0:
                i = 1
            plt.figure(figsize=(10, 5))
            plt.title(f"Day {i+1} Prediction")
            plt.plot(y_test.index[i:], y_test[f'Close_{i+1}'][:-i], label='Actual')
            plt.plot(y_test.index[i:], y_preds[i][i:], label='Predicted', linestyle='--')
            plt.legend()
            plt.xlabel('Date')
            plt.ylabel('Closing Price')
            plt.grid(True)
            plt.show()

        # Add a legend for the plotted lines
        plt.legend()

        # Show the plot
        plt.show()
        
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

    def forecast_window(self, window_size=30, forecast_steps=10):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)

        # Create a list to store the forecasts for each day ahead
        forecasts = []

        for i in range(forecast_steps):
            future_features = X_test.iloc[i:i+1]  # Take one day's worth of features
            day_ahead_predictions = []

            for model in models:
                y_pred = model.predict(future_features)
                day_ahead_predictions.append(y_pred[0])

            # Append the predictions for the day ahead to the list of forecasts
            forecasts.append(day_ahead_predictions)

            # Update the features for the next day by shifting them forward
            future_features = future_features.shift(-1)
            future_features['SMA5'] = future_features['SMA5'].fillna(future_features['SMA5'].iloc[-1])
            future_features['SMA20'] = future_features['SMA20'].fillna(future_features['SMA20'].iloc[-1])
            future_features['SMA60'] = future_features['SMA60'].fillna(future_features['SMA60'].iloc[-1])

        # Create a DataFrame to store the forecasts
        forecast_df = pd.DataFrame(forecasts, columns=[f'Day_{i+1}' for i in range(forecast_steps)], index=y_test.index[:forecast_steps])

        # Plot the forecasts
        plt.figure(figsize=(12, 6))
        plt.title('Forecasts for Closing Prices in the Window')
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)

        for i in range(forecast_steps):
            plt.plot(forecast_df.index, forecast_df[f'Day_{i+1}'], label=f'Day {i+1} Forecast', linestyle='--')

        # Add a legend for the plotted lines
        plt.legend()

        # Show the plot
        plt.show()

        # Return the forecasts DataFrame
        return forecast_df

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "ADA-USD"  # Replace with your desired cryptocurrency symbol
    window = 40
    cp = CryptoPrediction(crypto_symbol, window)
    # models = cp.predict_windows(window)
    data = cp.data

    # future_predictions = cp.predict_future(window=30)
    # print(future_predictions)
    forecast_steps = 40  # Specify the number of forecast steps
    forecasts = cp.forecast_window(60, forecast_steps)
    print(forecasts)
132/91:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.window_size = window_size
        self.data = self.add_features(data)
        
       

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-01-01', '2023-12-09')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        avg_pred = np.mean(y_preds, axis=0)
        plt.figure(figsize=(10, 5))
        plt.title(f"AVERGAGE Prediction")
        plt.plot(y_test.index[window_size:], y_test[f'Close_{i+0}'][:-window_size], label='Actual')
        plt.plot(y_test.index[window_size:], avg_pred[window_size:], label='Predicted', linestyle='--')
        plt.legend()
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        plt.show()
        
        # Visualize the predictions
        for i in range(window_size):
            if i == 0:
                i = 1
            plt.figure(figsize=(10, 5))
            plt.title(f"Day {i+1} Prediction")
            plt.plot(y_test.index[i:], y_test[f'Close_{i+1}'][:-i], label='Actual')
            plt.plot(y_test.index[i:], y_preds[i][i:], label='Predicted', linestyle='--')
            plt.legend()
            plt.xlabel('Date')
            plt.ylabel('Closing Price')
            plt.grid(True)
            plt.show()

        # Add a legend for the plotted lines
        plt.legend()

        # Show the plot
        plt.show()
        
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

    def forecast_window(self, window_size=30, forecast_steps=10):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)

        # Create a list to store the forecasts for each day ahead
        forecasts = []

        for i in range(forecast_steps):
            future_features = X_test.iloc[i:i+1]  # Take one day's worth of features
            day_ahead_predictions = []

            for model in models:
                y_pred = model.predict(future_features)
                day_ahead_predictions.append(y_pred[0])

            # Append the predictions for the day ahead to the list of forecasts
            forecasts.append(day_ahead_predictions)

            # Update the features for the next day by shifting them forward
            future_features = future_features.shift(-1)
            future_features['SMA5'] = future_features['SMA5'].fillna(future_features['SMA5'].iloc[-1])
            future_features['SMA20'] = future_features['SMA20'].fillna(future_features['SMA20'].iloc[-1])
            future_features['SMA60'] = future_features['SMA60'].fillna(future_features['SMA60'].iloc[-1])

        # Create a DataFrame to store the forecasts
        forecast_df = pd.DataFrame(forecasts, columns=[f'Day_{i+1}' for i in range(forecast_steps)], index=y_test.index[:forecast_steps])

        # Plot the forecasts
        plt.figure(figsize=(12, 6))
        plt.title('Forecasts for Closing Prices in the Window')
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)

        for i in range(forecast_steps):
            plt.plot(forecast_df.index, forecast_df[f'Day_{i+1}'], label=f'Day {i+1} Forecast', linestyle='--')

        # Add a legend for the plotted lines
        plt.legend()

        # Show the plot
        plt.show()

        # Return the forecasts DataFrame
        return forecast_df

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "ADA-USD"  # Replace with your desired cryptocurrency symbol
    window = 40
    cp = CryptoPrediction(crypto_symbol, window)
    # models = cp.predict_windows(window)
    data = cp.data

    # future_predictions = cp.predict_future(window=30)
    # print(future_predictions)
    forecast_steps = 40  # Specify the number of forecast steps
    forecasts = cp.forecast_window(60, forecast_steps)
    print(forecasts)
132/92:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.window_size = window_size
        self.data = self.add_features(data)
        
       

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-01-01', '2023-12-09')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        avg_pred = np.mean(y_preds, axis=0)
        plt.figure(figsize=(10, 5))
        plt.title(f"AVERGAGE Prediction")
        plt.plot(y_test.index[window_size:], y_test[f'Close_{i+0}'][:-window_size], label='Actual')
        plt.plot(y_test.index[window_size:], avg_pred[window_size:], label='Predicted', linestyle='--')
        plt.legend()
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        plt.show()
        
        # Visualize the predictions
        for i in range(window_size):
            if i == 0:
                i = 1
            plt.figure(figsize=(10, 5))
            plt.title(f"Day {i+1} Prediction")
            plt.plot(y_test.index[i:], y_test[f'Close_{i+1}'][:-i], label='Actual')
            plt.plot(y_test.index[i:], y_preds[i][i:], label='Predicted', linestyle='--')
            plt.legend()
            plt.xlabel('Date')
            plt.ylabel('Closing Price')
            plt.grid(True)
            plt.show()

        # Add a legend for the plotted lines
        plt.legend()

        # Show the plot
        plt.show()
        
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

    def forecast_window(self, window_size=30, forecast_steps=10):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)

        # Create a list to store the forecasts for each day ahead
        forecasts = []

        for i in range(forecast_steps):
            future_features = X_test.iloc[i:i+1]  # Take one day's worth of features
            day_ahead_predictions = []

            for model in models:
                y_pred = model.predict(future_features)
                day_ahead_predictions.append(y_pred[0])

            # Append the predictions for the day ahead to the list of forecasts
            forecasts.append(day_ahead_predictions)

            # Update the features for the next day by shifting them forward
            future_features = future_features.shift(-1)
            future_features['SMA5'] = future_features['SMA5'].fillna(future_features['SMA5'].iloc[-1])
            future_features['SMA20'] = future_features['SMA20'].fillna(future_features['SMA20'].iloc[-1])
            future_features['SMA60'] = future_features['SMA60'].fillna(future_features['SMA60'].iloc[-1])

        # Create a DataFrame to store the forecasts
        forecast_df = pd.DataFrame(forecasts, columns=[f'Day_{i+1}' for i in range(forecast_steps)], index=y_test.index[:forecast_steps])

        # Plot the forecasts
        plt.figure(figsize=(12, 6))
        plt.title('Forecasts for Closing Prices in the Window')
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)

        for i in range(forecast_steps):
            plt.plot(forecast_df.index, forecast_df[f'Day_{i+1}'], label=f'Day {i+1} Forecast', linestyle='--')

        # Add a legend for the plotted lines
        plt.legend()

        # Show the plot
        plt.show()

        # Return the forecasts DataFrame
        return forecast_df

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "ADA-USD"  # Replace with your desired cryptocurrency symbol
    window = 40
    cp = CryptoPrediction(crypto_symbol, window)
    models = cp.predict_windows(window)
    data = cp.data

    # future_predictions = cp.predict_future(window=30)
    # print(future_predictions)
    forecast_steps = 40  # Specify the number of forecast steps
    forecasts = cp.forecast_window(60, forecast_steps)
    print(forecasts)
132/93:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.window_size = window_size
        self.data = self.add_features(data)
        
       

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-01-01', '2023-12-09')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        avg_pred = np.mean(y_preds, axis=0)
        plt.figure(figsize=(10, 5))
        plt.title(f"AVERGAGE Prediction")
        plt.plot(y_test.index[window_size:], y_test[f'Close_{i+0}'][:-window_size], label='Actual')
        plt.plot(y_test.index[window_size:], avg_pred[window_size:], label='Predicted', linestyle='--')
        plt.legend()
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        plt.show()
        
        # Visualize the predictions
        for i in range(window_size):
            if i == 0:
                i = 1
            plt.figure(figsize=(10, 5))
            plt.title(f"Day {i+1} Prediction")
            plt.plot(y_test.index[i:], y_test[f'Close_{i+1}'][:-i], label='Actual')
            plt.plot(y_test.index[i:], y_preds[i][i:], label='Predicted', linestyle='--')
            plt.legend()
            plt.xlabel('Date')
            plt.ylabel('Closing Price')
            plt.grid(True)
            plt.show()

        # Add a legend for the plotted lines
        plt.legend()

        # Show the plot
        plt.show()
        
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        ax2 = ax1.twinx()  
        error = (test_data['Close'] - predictions) / 100
        ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        ax2.set_ylabel('Error', color='green')  
        ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()

    def predict_next_close(self, window=30):
        # Create the X and y data
        x = self.data.Close.values[:-1]
        y = self.data.Close.values[1:]
    
        # Split the data into train and test sets
        x_train, x_test = x[:-window], x[-window:]
        y_train, y_test = y[:-window], y[-window:]
    
        # Create and fit the Linear Regression model
        lr = LinearRegression()
        lr.fit(x_train.reshape(-1, 1), y_train)
    
        # Predict the next close value
        next_close_pred = lr.predict(np.array(x))

        return next_close_pred

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

    def predict_future(self, window=10):
        start_date = self.test_data.index[-1] + timedelta(days=1)
        end_date = start_date + timedelta(days=window-1)
        future_dates = pd.date_range(start_date, end_date, freq='D')

        scaler = StandardScaler()
        scaled_features = scaler.fit_transform(self.test_data[['SMA5', 'SMA20', 'SMA60']])
        scaled_features_df = pd.DataFrame(scaled_features, columns=['SMA5', 'SMA20', 'SMA60'], index=self.test_data.index)

        future_features = scaled_features_df.tail(window).values
        future_predictions = self.model.predict(future_features)
        future_predictions = scaler.inverse_transform(future_predictions.reshape(-1, 3))

        predicted_data = pd.DataFrame({'Date': future_dates, 'Close': future_predictions.ravel()},
                                      index=future_dates)
        predicted_data['SMA5'] = predicted_data['Close'].rolling(5).mean()
        predicted_data['SMA20'] = predicted_data['Close'].rolling(20).mean()
        predicted_data['SMA60'] = predicted_data['Close'].rolling(60).mean()
        return predicted_data

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "ADA-USD"  # Replace with your desired cryptocurrency symbol
    window = 40
    cp = CryptoPrediction(crypto_symbol, window)
    models = cp.predict_windows(window)
    data = cp.data
132/94:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.window_size = window_size
        self.data = self.add_features(data)
        
       

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-01-01', '2023-12-09')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        avg_pred = np.mean(y_preds, axis=0)
        plt.figure(figsize=(10, 5))
        plt.title(f"AVERGAGE Prediction")
        plt.plot(y_test.index[window_size:], y_test[f'Close_{i+0}'][:-window_size], label='Actual')
        plt.plot(y_test.index[window_size:], avg_pred[window_size:], label='Predicted', linestyle='--')
        plt.legend()
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        plt.show()
        
        # Visualize the predictions
        for i in range(window_size):
            if i == 0:
                i = 1
            plt.figure(figsize=(10, 5))
            plt.title(f"Day {i+1} Prediction")
            plt.plot(y_test.index[i:], y_test[f'Close_{i+1}'][:-i], label='Actual')
            plt.plot(y_test.index[i:], y_preds[i][i:], label='Predicted', linestyle='--')
            plt.legend()
            plt.xlabel('Date')
            plt.ylabel('Closing Price')
            plt.grid(True)
            plt.show()

        # Add a legend for the plotted lines
        plt.legend()

        # Show the plot
        plt.show()
        
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        ax2 = ax1.twinx()  
        error = (test_data['Close'] - predictions) / 100
        ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        ax2.set_ylabel('Error', color='green')  
        ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "ADA-USD"  # Replace with your desired cryptocurrency symbol
    window = 40
    cp = CryptoPrediction(crypto_symbol, window)
    # models = cp.predict_windows(window)
    data = cp.predict()"
132/95:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.window_size = window_size
        self.data = self.add_features(data)
        
       

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-01-01', '2023-12-09')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        avg_pred = np.mean(y_preds, axis=0)
        plt.figure(figsize=(10, 5))
        plt.title(f"AVERGAGE Prediction")
        plt.plot(y_test.index[window_size:], y_test[f'Close_{i+0}'][:-window_size], label='Actual')
        plt.plot(y_test.index[window_size:], avg_pred[window_size:], label='Predicted', linestyle='--')
        plt.legend()
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        plt.show()
        
        # Visualize the predictions
        for i in range(window_size):
            if i == 0:
                i = 1
            plt.figure(figsize=(10, 5))
            plt.title(f"Day {i+1} Prediction")
            plt.plot(y_test.index[i:], y_test[f'Close_{i+1}'][:-i], label='Actual')
            plt.plot(y_test.index[i:], y_preds[i][i:], label='Predicted', linestyle='--')
            plt.legend()
            plt.xlabel('Date')
            plt.ylabel('Closing Price')
            plt.grid(True)
            plt.show()

        # Add a legend for the plotted lines
        plt.legend()

        # Show the plot
        plt.show()
        
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        ax2 = ax1.twinx()  
        error = (test_data['Close'] - predictions) / 100
        ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        ax2.set_ylabel('Error', color='green')  
        ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "ADA-USD"  # Replace with your desired cryptocurrency symbol
    window = 40
    cp = CryptoPrediction(crypto_symbol, window)
    # models = cp.predict_windows(window)
    data = cp.predict()
132/96:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.window_size = window_size
        self.data = self.add_features(data)
        
       

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2018-01-01', '2023-12-09')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        avg_pred = np.mean(y_preds, axis=0)
        plt.figure(figsize=(10, 5))
        plt.title(f"AVERGAGE Prediction")
        plt.plot(y_test.index[window_size:], y_test[f'Close_{i+0}'][:-window_size], label='Actual')
        plt.plot(y_test.index[window_size:], avg_pred[window_size:], label='Predicted', linestyle='--')
        plt.legend()
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        plt.show()
        
        # Visualize the predictions
        for i in range(window_size):
            if i == 0:
                i = 1
            plt.figure(figsize=(10, 5))
            plt.title(f"Day {i+1} Prediction")
            plt.plot(y_test.index[i:], y_test[f'Close_{i+1}'][:-i], label='Actual')
            plt.plot(y_test.index[i:], y_preds[i][i:], label='Predicted', linestyle='--')
            plt.legend()
            plt.xlabel('Date')
            plt.ylabel('Closing Price')
            plt.grid(True)
            plt.show()

        # Add a legend for the plotted lines
        plt.legend()

        # Show the plot
        plt.show()
        
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "ADA-USD"  # Replace with your desired cryptocurrency symbol
    window = 40
    cp = CryptoPrediction(crypto_symbol, window)
    # models = cp.predict_windows(window)
    data = cp.predict()
132/97:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.window_size = window_size
        self.data = self.add_features(data)
        
       

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2023-01-01', '2023-12-09')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        avg_pred = np.mean(y_preds, axis=0)
        plt.figure(figsize=(10, 5))
        plt.title(f"AVERGAGE Prediction")
        plt.plot(y_test.index[window_size:], y_test[f'Close_{i+0}'][:-window_size], label='Actual')
        plt.plot(y_test.index[window_size:], avg_pred[window_size:], label='Predicted', linestyle='--')
        plt.legend()
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        plt.show()
        
        # Visualize the predictions
        for i in range(window_size):
            if i == 0:
                i = 1
            plt.figure(figsize=(10, 5))
            plt.title(f"Day {i+1} Prediction")
            plt.plot(y_test.index[i:], y_test[f'Close_{i+1}'][:-i], label='Actual')
            plt.plot(y_test.index[i:], y_preds[i][i:], label='Predicted', linestyle='--')
            plt.legend()
            plt.xlabel('Date')
            plt.ylabel('Closing Price')
            plt.grid(True)
            plt.show()

        # Add a legend for the plotted lines
        plt.legend()

        # Show the plot
        plt.show()
        
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()

    def predict(self):
        print(self.data)
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "ADA-USD"  # Replace with your desired cryptocurrency symbol
    window = 40
    cp = CryptoPrediction(crypto_symbol, window)
    # models = cp.predict_windows(window)
    data = cp.predict()
132/98:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.window_size = window_size
        self.data = self.add_features(data)
        
       

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2023-01-01', '2023-12-09')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        avg_pred = np.mean(y_preds, axis=0)
        plt.figure(figsize=(10, 5))
        plt.title(f"AVERGAGE Prediction")
        plt.plot(y_test.index[window_size:], y_test[f'Close_{i+0}'][:-window_size], label='Actual')
        plt.plot(y_test.index[window_size:], avg_pred[window_size:], label='Predicted', linestyle='--')
        plt.legend()
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        plt.show()
        
        # Visualize the predictions
        for i in range(window_size):
            if i == 0:
                i = 1
            plt.figure(figsize=(10, 5))
            plt.title(f"Day {i+1} Prediction")
            plt.plot(y_test.index[i:], y_test[f'Close_{i+1}'][:-i], label='Actual')
            plt.plot(y_test.index[i:], y_preds[i][i:], label='Predicted', linestyle='--')
            plt.legend()
            plt.xlabel('Date')
            plt.ylabel('Closing Price')
            plt.grid(True)
            plt.show()

        # Add a legend for the plotted lines
        plt.legend()

        # Show the plot
        plt.show()
        
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()

    def predict(self):
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "ADA-USD"  # Replace with your desired cryptocurrency symbol
    window = 40
    cp = CryptoPrediction(crypto_symbol, window)
    # models = cp.predict_windows(window)
    data = cp.predict()
132/99:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.window_size = window_size
        self.data = self.add_features(data)
        
       

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2023-01-01', '2023-12-09')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        avg_pred = np.mean(y_preds, axis=0)
        plt.figure(figsize=(10, 5))
        plt.title(f"AVERGAGE Prediction")
        plt.plot(y_test.index[window_size:], y_test[f'Close_{i+0}'][:-window_size], label='Actual')
        plt.plot(y_test.index[window_size:], avg_pred[window_size:], label='Predicted', linestyle='--')
        plt.legend()
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        plt.show()
        
        # Visualize the predictions
        for i in range(window_size):
            if i == 0:
                i = 1
            plt.figure(figsize=(10, 5))
            plt.title(f"Day {i+1} Prediction")
            plt.plot(y_test.index[i:], y_test[f'Close_{i+1}'][:-i], label='Actual')
            plt.plot(y_test.index[i:], y_preds[i][i:], label='Predicted', linestyle='--')
            plt.legend()
            plt.xlabel('Date')
            plt.ylabel('Closing Price')
            plt.grid(True)
            plt.show()

        # Add a legend for the plotted lines
        plt.legend()

        # Show the plot
        plt.show()
        
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close_Tomorrow'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()

    def predict(self):
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "ADA-USD"  # Replace with your desired cryptocurrency symbol
    window = 40
    cp = CryptoPrediction(crypto_symbol, window)
    # models = cp.predict_windows(window)
    data = cp.predict()
132/100:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.window_size = window_size
        self.data = self.add_features(data)
        
       

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2023-01-01', '2023-12-09')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        avg_pred = np.mean(y_preds, axis=0)
        plt.figure(figsize=(10, 5))
        plt.title(f"AVERGAGE Prediction")
        plt.plot(y_test.index[window_size:], y_test[f'Close_{i+0}'][:-window_size], label='Actual')
        plt.plot(y_test.index[window_size:], avg_pred[window_size:], label='Predicted', linestyle='--')
        plt.legend()
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        plt.show()
        
        # Visualize the predictions
        for i in range(window_size):
            if i == 0:
                i = 1
            plt.figure(figsize=(10, 5))
            plt.title(f"Day {i+1} Prediction")
            plt.plot(y_test.index[i:], y_test[f'Close_{i+1}'][:-i], label='Actual')
            plt.plot(y_test.index[i:], y_preds[i][i:], label='Predicted', linestyle='--')
            plt.legend()
            plt.xlabel('Date')
            plt.ylabel('Closing Price')
            plt.grid(True)
            plt.show()

        # Add a legend for the plotted lines
        plt.legend()

        # Show the plot
        plt.show()
        
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close_Tomorrow'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()

    def predict(self):
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "ADA-USD"  # Replace with your desired cryptocurrency symbol
    window = 40
    cp = CryptoPrediction(crypto_symbol, window)
    models = cp.predict_windows(window)
    data = cp.predict()
132/101:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.window_size = window_size
        self.data = self.add_features(data)
        
       

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2023-01-01', '2023-12-09')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        avg_pred = np.mean(y_preds, axis=0)
        plt.figure(figsize=(10, 5))
        plt.title(f"AVERGAGE Prediction")
        plt.plot(y_test.index[window_size:], y_test[f'Close_{i+0}'][:-window_size], label='Actual')
        plt.plot(y_test.index[window_size:], avg_pred[window_size:], label='Predicted', linestyle='--')
        plt.legend()
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        plt.show()
        
        # Visualize the predictions
        for i in range(window_size):
            if i == 0:
                i = 1
            plt.figure(figsize=(10, 5))
            plt.title(f"Day {i+1} Prediction")
            plt.plot(y_test.index[i:], y_test[f'Close_{i+1}'][:-i], label='Actual')
            plt.plot(y_test.index[i:], y_preds[i][i:], label='Predicted', linestyle='--')
            plt.legend()
            plt.xlabel('Date')
            plt.ylabel('Closing Price')
            plt.grid(True)
            plt.show()

        # Add a legend for the plotted lines
        plt.legend()

        # Show the plot
        plt.show()
        
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close_Tomorrow'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()

    def predict(self):
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "ADA-USD"  # Replace with your desired cryptocurrency symbol
    window = 40
    cp = CryptoPrediction(crypto_symbol, window)
    models = cp.predict_windows(window)
    data = cp.predict()
132/102:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.window_size = window_size
        self.data = self.add_features(data)
        
       

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2023-01-01', '2023-12-09')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        avg_pred = np.mean(y_preds, axis=0)
        plt.figure(figsize=(10, 5))
        plt.title(f"AVERGAGE Prediction")
        plt.plot(y_test.index[window_size:], y_test[f'Close_{i+0}'][:-window_size], label='Actual')
        plt.plot(y_test.index[window_size:], avg_pred[window_size:], label='Predicted', linestyle='--')
        plt.legend()
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        plt.show()
        
        # Visualize the predictions
        for i in range(window_size):
            if i == 0:
                i = 1
            plt.figure(figsize=(10, 5))
            plt.title(f"Day {i+1} Prediction")
            plt.plot(y_test.index[i:], y_test[f'Close_{i+1}'][:-i], label='Actual')
            plt.plot(y_test.index[i:], y_preds[i][i:], label='Predicted', linestyle='--')
            plt.legend()
            plt.xlabel('Date')
            plt.ylabel('Closing Price')
            plt.grid(True)
            #plt.show()

        # Add a legend for the plotted lines
        plt.legend()

        # Show the plot
        plt.show()
        
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close_Tomorrow'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()

    def predict(self):
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "ADA-USD"  # Replace with your desired cryptocurrency symbol
    window = 40
    cp = CryptoPrediction(crypto_symbol, window)
    models = cp.predict_windows(window)
    data = cp.predict()
132/103:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.window_size = window_size
        self.data = self.add_features(data)
        
       

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2023-01-01', '2023-12-09')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        avg_pred = np.mean(y_preds, axis=0)
        plt.figure(figsize=(10, 5))
        plt.title(f"AVERGAGE Prediction")
        plt.plot(y_test.index[window_size:], y_test[f'Close_{i+0}'][:-window_size], label='Actual')
        plt.plot(y_test.index[window_size:], avg_pred[window_size:], label='Predicted', linestyle='--')
        plt.legend()
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        plt.show()
        
        # Visualize the predictions
        for i in range(window_size):
            # if i == 0:
            #     i = 1
            plt.figure(figsize=(10, 5))
            plt.title(f"Day {i+1} Prediction")
            plt.plot(y_test.index[i:], y_test[f'Close_{i+1}'][:-i], label='Actual')
            plt.plot(y_test.index[i:], y_preds[i][i:], label='Predicted', linestyle='--')
            plt.legend()
            plt.xlabel('Date')
            plt.ylabel('Closing Price')
            #plt.grid(True)
            #plt.show()

        # Add a legend for the plotted lines
        plt.legend()

        # Show the plot
        plt.show()
        
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close_Tomorrow'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()

    def predict(self):
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "ADA-USD"  # Replace with your desired cryptocurrency symbol
    window = 5
    cp = CryptoPrediction(crypto_symbol, window)
    models = cp.predict_windows(window)
    data = cp.predict()
132/104:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.window_size = window_size
        self.data = self.add_features(data)
        
       

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2023-01-01', '2023-12-09')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        avg_pred = np.mean(y_preds, axis=0)
        plt.figure(figsize=(10, 5))
        plt.title(f"AVERGAGE Prediction")
        plt.plot(y_test.index[window_size:], y_test[f'Close_{i+0}'][:-window_size], label='Actual')
        plt.plot(y_test.index[window_size:], avg_pred[window_size:], label='Predicted', linestyle='--')
        plt.legend()
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        plt.show()
        
        # Visualize the predictions
        for i in range(window_size):
            if i == 0:
                i = 1
            plt.figure(figsize=(10, 5))
            plt.title(f"Day {i+1} Prediction")
            plt.plot(y_test.index[i:], y_test[f'Close_{i+1}'][:-i], label='Actual')
            plt.plot(y_test.index[i:], y_preds[i][i:], label='Predicted', linestyle='--')
            plt.legend()
            plt.xlabel('Date')
            plt.ylabel('Closing Price')
            #plt.grid(True)
            #plt.show()

        # Add a legend for the plotted lines
        plt.legend()

        # Show the plot
        plt.show()
        
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close_Tomorrow'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()

    def predict(self):
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "ADA-USD"  # Replace with your desired cryptocurrency symbol
    window = 5
    cp = CryptoPrediction(crypto_symbol, window)
    models = cp.predict_windows(window)
    data = cp.predict()
132/105:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.window_size = window_size
        self.data = self.add_features(data)
        
       

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2023-01-01', '2023-12-09')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        avg_pred = np.mean(y_preds, axis=0)
        plt.figure(figsize=(10, 5))
        plt.title(f"AVERGAGE Prediction")
        plt.plot(y_test.index[window_size:], y_test[f'Close_{i+0}'][:-window_size], label='Actual')
        plt.plot(y_test.index[window_size:], avg_pred[window_size:], label='Predicted', linestyle='--')
        plt.legend()
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        plt.show()
        
        # Visualize the predictions
        for i in range(window_size):
            if i == 0:
                i = 1
            # plt.figure(figsize=(10, 5))
            # plt.title(f"Day {i+1} Prediction")
            plt.plot(y_test.index[i:], y_test[f'Close_{i+1}'][:-i], label='Actual')
            plt.plot(y_test.index[i:], y_preds[i][i:], label='Predicted', linestyle='--')
            # plt.legend()
            # plt.xlabel('Date')
            # plt.ylabel('Closing Price')
            #plt.grid(True)
            #plt.show()

        # Add a legend for the plotted lines
        plt.legend()

        # Show the plot
        plt.show()
        
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close_Tomorrow'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()

    def predict(self):
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "ADA-USD"  # Replace with your desired cryptocurrency symbol
    window = 5
    cp = CryptoPrediction(crypto_symbol, window)
    models = cp.predict_windows(window)
    data = cp.predict()
132/106:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.window_size = window_size
        self.data = self.add_features(data)
        
       

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2023-01-01', '2023-12-09')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        avg_pred = np.mean(y_preds, axis=0)
        plt.figure(figsize=(10, 5))
        plt.title(f"AVERGAGE Prediction")
        plt.plot(y_test.index[window_size:], y_test[f'Close_{i+0}'][:-window_size], label='Actual')
        plt.plot(y_test.index[window_size:], avg_pred[window_size:], label='Predicted', linestyle='--')
        plt.legend()
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        plt.show()
        
        # Visualize the predictions
        i=0
        plt.plot(y_test.index[i:], y_test[f'Close_{i+1}'][:-i], label='Actual')
        for i in range(window_size):
            # if i == 0:
                # i = 1
            # plt.figure(figsize=(10, 5))
            # plt.title(f"Day {i+1} Prediction")
                
            plt.plot(y_test.index[i:], y_preds[i][i:], label='Predicted', linestyle='--')
            # plt.legend()
            # plt.xlabel('Date')
            # plt.ylabel('Closing Price')
            #plt.grid(True)
            #plt.show()

        # Add a legend for the plotted lines
        plt.legend()

        # Show the plot
        plt.show()
        
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close_Tomorrow'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()

    def predict(self):
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "ADA-USD"  # Replace with your desired cryptocurrency symbol
    window = 5
    cp = CryptoPrediction(crypto_symbol, window)
    models = cp.predict_windows(window)
    data = cp.predict()
132/107:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.window_size = window_size
        self.data = self.add_features(data)
        
       

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2023-01-01', '2023-12-09')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        avg_pred = np.mean(y_preds, axis=0)
        plt.figure(figsize=(10, 5))
        plt.title(f"AVERGAGE Prediction")
        plt.plot(y_test.index[window_size:], y_test[f'Close_{i+0}'][:-window_size], label='Actual')
        plt.plot(y_test.index[window_size:], avg_pred[window_size:], label='Predicted', linestyle='--')
        plt.legend()
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        plt.show()
        
        # Visualize the predictions
        i=1
        plt.plot(y_test.index[i:], y_test[f'Close_{i+1}'][:-i], label='Actual')
        for i in range(window_size):
            # if i == 0:
                # i = 1
            # plt.figure(figsize=(10, 5))
            # plt.title(f"Day {i+1} Prediction")
                
            plt.plot(y_test.index[i:], y_preds[i][i:], label='Predicted', linestyle='--')
            # plt.legend()
            # plt.xlabel('Date')
            # plt.ylabel('Closing Price')
            #plt.grid(True)
            #plt.show()

        # Add a legend for the plotted lines
        plt.legend()

        # Show the plot
        plt.show()
        
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close_Tomorrow'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()

    def predict(self):
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "ADA-USD"  # Replace with your desired cryptocurrency symbol
    window = 5
    cp = CryptoPrediction(crypto_symbol, window)
    models = cp.predict_windows(window)
    data = cp.predict()
132/108:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.window_size = window_size
        self.data = self.add_features(data)
        
       

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2023-01-01', '2023-12-09')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        avg_pred = np.mean(y_preds, axis=0)
        plt.figure(figsize=(10, 5))
        plt.title(f"AVERGAGE Prediction")
        plt.plot(y_test.index[window_size:], y_test[f'Close_{i+0}'][:-window_size], label='Actual')
        plt.plot(y_test.index[window_size:], avg_pred[window_size:], label='Predicted', linestyle='--')
        plt.legend()
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        plt.show()
        
        # Visualize the predictions
        i=1
        plt.plot(y_test.index[i:], y_test[f'Close_{i+1}'][:-i], label='Actual')
        for i in range(window_size):
            # if i == 0:
                # i = 1
            # plt.figure(figsize=(10, 5))
            # plt.title(f"Day {i+1} Prediction")
                
            plt.plot(y_test.index[i:], y_preds[i][i:], label='Predicted', linestyle='--')
            # plt.legend()
            # plt.xlabel('Date')
            # plt.ylabel('Closing Price')
            #plt.grid(True)
            #plt.show()

        # Add a legend for the plotted lines
        plt.legend()

        # Show the plot
        plt.show()
        
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close_Tomorrow'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        ax2 = ax1.twinx()  
        error = (test_data['Close_Tomorrow'] - predictions) / 100
        ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        ax2.set_ylabel('Error', color='green')  
        ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()

    def predict(self):
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "ADA-USD"  # Replace with your desired cryptocurrency symbol
    window = 5
    cp = CryptoPrediction(crypto_symbol, window)
    models = cp.predict_windows(window)
    data = cp.predict()
132/109:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.window_size = window_size
        self.data = self.add_features(data)
        
       

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2023-01-01', '2023-12-09')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        avg_pred = np.mean(y_preds, axis=0)
        plt.figure(figsize=(10, 5))
        plt.title(f"AVERGAGE Prediction")
        plt.plot(y_test.index[window_size:], y_test[f'Close_{i+0}'][:-window_size], label='Actual')
        plt.plot(y_test.index[window_size:], avg_pred[window_size:], label='Predicted', linestyle='--')
        plt.legend()
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        plt.show()
        
        # Visualize the predictions
        i=0
        plt.plot(y_test.index[i:], y_test[f'Close_{i+1}'][:-i], label='Actual')
        for i in range(window_size):
            # if i == 0:
                # i = 1
            # plt.figure(figsize=(10, 5))
            # plt.title(f"Day {i+1} Prediction")
                
            plt.plot(y_test.index[i:], y_preds[i][i:], label='Predicted', linestyle='--')
            # plt.legend()
            # plt.xlabel('Date')
            # plt.ylabel('Closing Price')
            #plt.grid(True)
            #plt.show()

        # Add a legend for the plotted lines
        plt.legend()

        # Show the plot
        plt.show()
        
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close_Tomorrow'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')

        plt.title(title)

        plt.show()

    def predict(self):
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "ADA-USD"  # Replace with your desired cryptocurrency symbol
    window = 5
    cp = CryptoPrediction(crypto_symbol, window)
    models = cp.predict_windows(window)
    data = cp.predict()
132/110:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.window_size = window_size
        self.data = self.add_features(data)
        
       

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2023-01-01', '2023-12-09')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)
        data['Close_0'] = data['Close']

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(1, self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i}'])
            models.append(model)
        y_preds = []
        
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        avg_pred = np.mean(y_preds, axis=0)
        plt.figure(figsize=(10, 5))
        plt.title(f"AVERGAGE Prediction")
        plt.plot(y_test.index[window_size:], y_test[f'Close_{0}'][:-window_size], label='Actual')
        plt.plot(y_test.index[window_size:], avg_pred[window_size:], label='Predicted', linestyle='--')
        plt.legend()
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        plt.show()
        
        # Visualize the predictions
        i=0
        plt.plot(y_test.index[i:], y_test[f'Close_{i+1}'][:-i], label='Actual')
        for i in range(window_size):
            # if i == 0:
                # i = 1
            # plt.figure(figsize=(10, 5))
            # plt.title(f"Day {i+1} Prediction")
                
            plt.plot(y_test.index[i:], y_preds[i][i:], label='Predicted', linestyle='--')
            # plt.legend()
            # plt.xlabel('Date')
            # plt.ylabel('Closing Price')
            #plt.grid(True)
            #plt.show()

        # Add a legend for the plotted lines
        plt.legend()

        # Show the plot
        plt.show()
        
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close_Tomorrow'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')

        plt.title(title)

        plt.show()

    def predict(self):
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "ADA-USD"  # Replace with your desired cryptocurrency symbol
    window = 5
    cp = CryptoPrediction(crypto_symbol, window)
    models = cp.predict_windows(window)
    data = cp.predict()
132/111:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.window_size = window_size
        self.data = self.add_features(data)
        
       

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2023-01-01', '2023-12-09')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)
        data['Close_0'] = data['Close']

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(1, self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i}'])
            models.append(model)
        y_preds = []
        
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        avg_pred = np.mean(y_preds, axis=0)
        plt.figure(figsize=(10, 5))
        plt.title(f"AVERGAGE Prediction")
        plt.plot(y_test.index[window_size:], y_test[f'Close_0'][:-window_size], label='Actual')
        plt.plot(y_test.index[window_size:], avg_pred[window_size:], label='Predicted', linestyle='--')
        plt.legend()
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        plt.show()
        
        # Visualize the predictions
        i=0
        plt.plot(y_test.index[i:], y_test[f'Close_{i+1}'][:-i], label='Actual')
        for i in range(window_size):
            # if i == 0:
                # i = 1
            # plt.figure(figsize=(10, 5))
            # plt.title(f"Day {i+1} Prediction")
                
            plt.plot(y_test.index[i:], y_preds[i][i:], label='Predicted', linestyle='--')
            # plt.legend()
            # plt.xlabel('Date')
            # plt.ylabel('Closing Price')
            #plt.grid(True)
            #plt.show()

        # Add a legend for the plotted lines
        plt.legend()

        # Show the plot
        plt.show()
        
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close_Tomorrow'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')

        plt.title(title)

        plt.show()

    def predict(self):
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "ADA-USD"  # Replace with your desired cryptocurrency symbol
    window = 5
    cp = CryptoPrediction(crypto_symbol, window)
    models = cp.predict_windows(window)
    data = cp.predict()
132/112:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.window_size = window_size
        self.data = self.add_features(data)
        
       

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2023-01-01', '2023-12-09')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)
        data['Close_0'] = data['Close']

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(1, self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i}'])
            models.append(model)
        y_preds = []
        
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        avg_pred = np.mean(y_preds, axis=0)
        plt.figure(figsize=(10, 5))
        plt.title(f"AVERGAGE Prediction")
        plt.plot(y_test.index[window_size:], y_test[f'Close_{i+1}'][:-window_size], label='Actual')
        plt.plot(y_test.index[window_size:], avg_pred[window_size:], label='Predicted', linestyle='--')
        plt.legend()
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        plt.show()
        
        # Visualize the predictions
        i=0
        plt.plot(y_test.index[i:], y_test[f'Close_{i+1}'][:-i], label='Actual')
        for i in range(window_size):
            # if i == 0:
                # i = 1
            # plt.figure(figsize=(10, 5))
            # plt.title(f"Day {i+1} Prediction")
                
            plt.plot(y_test.index[i:], y_preds[i][i:], label='Predicted', linestyle='--')
            # plt.legend()
            # plt.xlabel('Date')
            # plt.ylabel('Closing Price')
            #plt.grid(True)
            #plt.show()

        # Add a legend for the plotted lines
        plt.legend()

        # Show the plot
        plt.show()
        
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close_Tomorrow'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')

        plt.title(title)

        plt.show()

    def predict(self):
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "ADA-USD"  # Replace with your desired cryptocurrency symbol
    window = 5
    cp = CryptoPrediction(crypto_symbol, window)
    models = cp.predict_windows(window)
    data = cp.predict()
132/113:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.window_size = window_size
        self.data = self.add_features(data)
        
       

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2023-01-01', '2023-12-09')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)
        data['Close_0'] = data['Close']

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(1, self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i}'])
            models.append(model)
        y_preds = []
        
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        avg_pred = np.mean(y_preds, axis=0)
        plt.figure(figsize=(10, 5))
        plt.title(f"AVERGAGE Prediction")
        plt.plot(y_test.index[window_size:], y_test[f'Close_{i}'][:-window_size], label='Actual')
        plt.plot(y_test.index[window_size:], avg_pred[window_size:], label='Predicted', linestyle='--')
        plt.legend()
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        plt.show()
        
        # Visualize the predictions
        i=0
        plt.plot(y_test.index[i:], y_test[f'Close_{i+1}'][:-i], label='Actual')
        for i in range(window_size):
            # if i == 0:
                # i = 1
            # plt.figure(figsize=(10, 5))
            # plt.title(f"Day {i+1} Prediction")
                
            plt.plot(y_test.index[i:], y_preds[i][i:], label='Predicted', linestyle='--')
            # plt.legend()
            # plt.xlabel('Date')
            # plt.ylabel('Closing Price')
            #plt.grid(True)
            #plt.show()

        # Add a legend for the plotted lines
        plt.legend()

        # Show the plot
        plt.show()
        
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close_Tomorrow'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')

        plt.title(title)

        plt.show()

    def predict(self):
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "ADA-USD"  # Replace with your desired cryptocurrency symbol
    window = 5
    cp = CryptoPrediction(crypto_symbol, window)
    models = cp.predict_windows(window)
    data = cp.predict()
132/114:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.window_size = window_size
        self.data = self.add_features(data)
        
       

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2023-01-01', '2023-12-09')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)
        data['Close_0'] = data['Close']

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(1, self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        avg_pred = np.mean(y_preds, axis=0)
        plt.figure(figsize=(10, 5))
        plt.title(f"AVERGAGE Prediction")
        plt.plot(y_test.index[window_size:], y_test[f'Close_{i+0}'][:-window_size], label='Actual')
        plt.plot(y_test.index[window_size:], avg_pred[window_size:], label='Predicted', linestyle='--')
        plt.legend()
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        plt.show()
        
        # Visualize the predictions
        i=0
        plt.plot(y_test.index[i:], y_test[f'Close_{i+1}'][:-i], label='Actual')/
            # if i == 0:
                # i = 1
            # plt.figure(figsize=(10, 5))
            # plt.title(f"Day {i+1} Prediction")
                
            plt.plot(y_test.index[i:], y_preds[i][i:], label='Predicted', linestyle='--')
            # plt.legend()
            # plt.xlabel('Date')
            # plt.ylabel('Closing Price')
            #plt.grid(True)
            #plt.show()

        # Add a legend for the plotted lines
        plt.legend()

        # Show the plot
        plt.show()
        
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close_Tomorrow'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')

        plt.title(title)

        plt.show()

    def predict(self):
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "ADA-USD"  # Replace with your desired cryptocurrency symbol
    window = 5
    cp = CryptoPrediction(crypto_symbol, window)
    models = cp.predict_windows(window)
    data = cp.predict()
132/115:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.window_size = window_size
        self.data = self.add_features(data)
        
       

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2023-01-01', '2023-12-09')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)
        data['Close_0'] = data['Close']

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(1, self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        avg_pred = np.mean(y_preds, axis=0)
        plt.figure(figsize=(10, 5))
        plt.title(f"AVERGAGE Prediction")
        plt.plot(y_test.index[window_size:], y_test[f'Close_{i+0}'][:-window_size], label='Actual')
        plt.plot(y_test.index[window_size:], avg_pred[window_size:], label='Predicted', linestyle='--')
        plt.legend()
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        plt.show()
        
        # Visualize the predictions
        i=0
        plt.plot(y_test.index[i:], y_test[f'Close_{i+1}'][:-i], label='Actual')
            # if i == 0:
                # i = 1
            # plt.figure(figsize=(10, 5))
            # plt.title(f"Day {i+1} Prediction")
                
            plt.plot(y_test.index[i:], y_preds[i][i:], label='Predicted', linestyle='--')
            # plt.legend()
            # plt.xlabel('Date')
            # plt.ylabel('Closing Price')
            #plt.grid(True)
            #plt.show()

        # Add a legend for the plotted lines
        plt.legend()

        # Show the plot
        plt.show()
        
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close_Tomorrow'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')

        plt.title(title)

        plt.show()

    def predict(self):
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "ADA-USD"  # Replace with your desired cryptocurrency symbol
    window = 5
    cp = CryptoPrediction(crypto_symbol, window)
    models = cp.predict_windows(window)
    data = cp.predict()
132/116:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.window_size = window_size
        self.data = self.add_features(data)
        
       

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2023-01-01', '2023-12-09')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)
        data['Close_0'] = data['Close']

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(1, self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        avg_pred = np.mean(y_preds, axis=0)
        plt.figure(figsize=(10, 5))
        plt.title(f"AVERGAGE Prediction")
        plt.plot(y_test.index[window_size:], y_test[f'Close_{i+0}'][:-window_size], label='Actual')
        plt.plot(y_test.index[window_size:], avg_pred[window_size:], label='Predicted', linestyle='--')
        plt.legend()
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        plt.show()
        
        # Visualize the predictions
        i=0
        plt.plot(y_test.index[i:], y_test[f'Close_{i+1}'][:-i], label='Actual')
        for i in range(window_size):
            # if i == 0:
                # i = 1
            # plt.figure(figsize=(10, 5))
            # plt.title(f"Day {i+1} Prediction")
                
            plt.plot(y_test.index[i:], y_preds[i][i:], label='Predicted', linestyle='--')
            # plt.legend()
            # plt.xlabel('Date')
            # plt.ylabel('Closing Price')
            #plt.grid(True)
            #plt.show()

        # Add a legend for the plotted lines
        plt.legend()

        # Show the plot
        plt.show()
        
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close_Tomorrow'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')

        plt.title(title)

        plt.show()

    def predict(self):
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "ADA-USD"  # Replace with your desired cryptocurrency symbol
    window = 5
    cp = CryptoPrediction(crypto_symbol, window)
    models = cp.predict_windows(window)
    data = cp.predict()
132/117:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.window_size = window_size
        self.data = self.add_features(data)
        
       

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2023-01-01', '2023-12-09')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)
        data['Close_0'] = data['Close']

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(1, self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        avg_pred = np.mean(y_preds, axis=0)
        plt.figure(figsize=(10, 5))
        plt.title(f"AVERGAGE Prediction")
        plt.plot(y_test.index[window_size:], y_test[f'Close_{i+0}'][:-window_size], label='Actual')
        plt.plot(y_test.index[window_size:], avg_pred[window_size:], label='Predicted', linestyle='--')
        plt.legend()
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        plt.show()
        
        # Visualize the predictions
        i=0
        plt.plot(y_test.index[i:], y_test[f'Close_{i+0}'][:-i], label='Actual')
        for i in range(window_size):
            # if i == 0:
                # i = 1
            # plt.figure(figsize=(10, 5))
            # plt.title(f"Day {i+1} Prediction")
                
            plt.plot(y_test.index[i:], y_preds[i][i:], label='Predicted', linestyle='--')
            # plt.legend()
            # plt.xlabel('Date')
            # plt.ylabel('Closing Price')
            #plt.grid(True)
            #plt.show()

        # Add a legend for the plotted lines
        plt.legend()

        # Show the plot
        plt.show()
        
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close_Tomorrow'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')

        plt.title(title)

        plt.show()

    def predict(self):
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "ADA-USD"  # Replace with your desired cryptocurrency symbol
    window = 5
    cp = CryptoPrediction(crypto_symbol, window)
    models = cp.predict_windows(window)
    data = cp.predict()
132/118:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.window_size = window_size
        self.data = self.add_features(data)
        
       

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2023-01-01', '2023-12-09')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)
        data['Close_0'] = data['Close']

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        avg_pred = np.mean(y_preds, axis=0)
        plt.figure(figsize=(10, 5))
        plt.title(f"AVERGAGE Prediction")
        plt.plot(y_test.index[window_size:], y_test[f'Close_{i+0}'][:-window_size], label='Actual')
        plt.plot(y_test.index[window_size:], avg_pred[window_size:], label='Predicted', linestyle='--')
        plt.legend()
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        plt.show()
        
        # Visualize the predictions
        i=0
        plt.plot(y_test.index[i:], y_test[f'Close_{i+1}'][:-i], label='Actual')
        for i in range(window_size):
            # if i == 0:
                # i = 1
            # plt.figure(figsize=(10, 5))
            # plt.title(f"Day {i+1} Prediction")
                
            plt.plot(y_test.index[i:], y_preds[i][i:], label='Predicted', linestyle='--')
            # plt.legend()
            # plt.xlabel('Date')
            # plt.ylabel('Closing Price')
            #plt.grid(True)
            #plt.show()

        # Add a legend for the plotted lines
        plt.legend()

        # Show the plot
        plt.show()
        
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close_Tomorrow'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')

        plt.title(title)

        plt.show()

    def predict(self):
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "ADA-USD"  # Replace with your desired cryptocurrency symbol
    window = 5
    cp = CryptoPrediction(crypto_symbol, window)
    models = cp.predict_windows(window)
    data = cp.predict()
132/119:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.window_size = window_size
        self.data = self.add_features(data)
        
       

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2023-01-01', '2023-12-09')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)
        # data['Close_0'] = data['Close']

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        avg_pred = np.mean(y_preds, axis=0)
        plt.figure(figsize=(10, 5))
        plt.title(f"AVERGAGE Prediction")
        plt.plot(y_test.index[window_size:], y_test[f'Close_{i+0}'][:-window_size], label='Actual')
        plt.plot(y_test.index[window_size:], avg_pred[window_size:], label='Predicted', linestyle='--')
        plt.legend()
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        plt.show()
        
        # Visualize the predictions
        i=0
        plt.plot(y_test.index[i:], y_test[f'Close_{i+1}'][:-i], label='Actual')
        for i in range(window_size):
            # if i == 0:
                # i = 1
            # plt.figure(figsize=(10, 5))
            # plt.title(f"Day {i+1} Prediction")
                
            plt.plot(y_test.index[i:], y_preds[i][i:], label='Predicted', linestyle='--')
            # plt.legend()
            # plt.xlabel('Date')
            # plt.ylabel('Closing Price')
            #plt.grid(True)
            #plt.show()

        # Add a legend for the plotted lines
        plt.legend()

        # Show the plot
        plt.show()
        
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close_Tomorrow'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')

        plt.title(title)

        plt.show()

    def predict(self):
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "ADA-USD"  # Replace with your desired cryptocurrency symbol
    window = 5
    cp = CryptoPrediction(crypto_symbol, window)
    models = cp.predict_windows(window)
    data = cp.predict()
132/120:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.window_size = window_size
        self.data = self.add_features(data)
        
       

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2023-01-01', '2023-12-09')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)
        # data['Close_0'] = data['Close']

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        avg_pred = np.mean(y_preds, axis=0)
        plt.figure(figsize=(10, 5))
        plt.title(f"AVERGAGE Prediction")
        plt.plot(y_test.index[window_size:], y_test[f'Close_{i+0}'][:-window_size], label='Actual')
        plt.plot(y_test.index[window_size:], avg_pred[window_size:], label='Predicted', linestyle='--')
        plt.legend()
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        plt.show()
        
        # Visualize the predictions
        i=0
        plt.plot(y_test.index[i:], y_test[f'Close_{i+0}'][:-i], label='Actual')
        for i in range(window_size):
            # if i == 0:
                # i = 1
            # plt.figure(figsize=(10, 5))
            # plt.title(f"Day {i+1} Prediction")
                
            plt.plot(y_test.index[i:], y_preds[i][i:], label='Predicted', linestyle='--')
            # plt.legend()
            # plt.xlabel('Date')
            # plt.ylabel('Closing Price')
            #plt.grid(True)
            #plt.show()

        # Add a legend for the plotted lines
        plt.legend()

        # Show the plot
        plt.show()
        
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close_Tomorrow'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')

        plt.title(title)

        plt.show()

    def predict(self):
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "ADA-USD"  # Replace with your desired cryptocurrency symbol
    window = 5
    cp = CryptoPrediction(crypto_symbol, window)
    models = cp.predict_windows(window)
    data = cp.predict()
132/121:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.window_size = window_size
        self.data = self.add_features(data)
        
       

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2023-01-01', '2023-12-09')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        avg_pred = np.mean(y_preds, axis=0)
        plt.figure(figsize=(10, 5))
        plt.title(f"AVERGAGE Prediction")
        plt.plot(y_test.index[window_size:], y_test[f'Close_{i+0}'][:-window_size], label='Actual')
        plt.plot(y_test.index[window_size:], avg_pred[window_size:], label='Predicted', linestyle='--')
        plt.legend()
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        plt.show()
        
        # Visualize the predictions
        i=1
        plt.plot(y_test.index[i:], y_test[f'Close_{i+1}'][:-i], label='Actual')
        for i in range(window_size):
            # if i == 0:
                # i = 1
            # plt.figure(figsize=(10, 5))
            # plt.title(f"Day {i+1} Prediction")
                
            plt.plot(y_test.index[i:], y_preds[i][i:], label='Predicted', linestyle='--')
            # plt.legend()
            # plt.xlabel('Date')
            # plt.ylabel('Closing Price')
            #plt.grid(True)
            #plt.show()

        # Add a legend for the plotted lines
        plt.legend()

        # Show the plot
        plt.show()
        
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close_Tomorrow'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close_T'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()

    def predict(self):
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "ADA-USD"  # Replace with your desired cryptocurrency symbol
    window = 5
    cp = CryptoPrediction(crypto_symbol, window)
    models = cp.predict_windows(window)
    data = cp.predict()
132/122: from utilsforecast.plotting import plot_series
132/123:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.window_size = window_size
        self.data = self.add_features(data)
        
       

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2023-01-01', '2023-12-09')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        avg_pred = np.mean(y_preds, axis=0)
        plt.figure(figsize=(10, 5))
        plt.title(f"AVERGAGE Prediction")
        plt.plot(y_test.index[window_size:], y_test[f'Close_{i+0}'][:-window_size], label='Actual')
        plt.plot(y_test.index[window_size:], avg_pred[window_size:], label='Predicted', linestyle='--')
        plt.legend()
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        plt.show()
        
        # Visualize the predictions
        i=1
        plt.plot(y_test.index[i:], y_test[f'Close_{i+1}'][:-i], label='Actual')
        for i in range(window_size):
            plt.plot(y_test.index[i:], y_preds[i][i:], label='Predicted', linestyle='--')
        # Add a legend for the plotted lines
        plt.legend()

        # Show the plot
        plt.show()
        
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close_Tomorrow'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')
        # ax1.set_xlim(2023, 2024)
        # ax1.set_ylim(-1, 1)

        # Creating a secondary y-axis for the error plot
        # ax2 = ax1.twinx()  
        # error = (test_data['Close_T'] - predictions) / 100
        # ax2.plot(test_data.index, error, color='green', label='Prediction Error')
        # ax2.set_ylabel('Error', color='green')  
        # ax2.tick_params(axis='y', labelcolor='green')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()

    def predict(self):
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "ADA-USD"  # Replace with your desired cryptocurrency symbol
    window = 5
    cp = CryptoPrediction(crypto_symbol, window)
    models = cp.predict_windows(window)
    data = cp.predict()
132/124:
data = cp.data
data
132/125:
data = cp.data
data['unique_id' = crypto_symbol
data['df'] = data.index.values
132/126:
data = cp.data
data['unique_id'] = crypto_symbol
data['df'] = data.index.values
132/127:
data = cp.data
data['unique_id'] = crypto_symbol
data['df'] = data.index.values
132/128:
data = cp.data
data['unique_id'] = crypto_symbol
data['ds'] = data.index.values
132/129:
data = cp.data
data['unique_id'] = crypto_symbol
data['ds'] = data.index.values
data
132/130:
fig = plot_series(data)
fig
132/131:
data = cp.data
data['unique_id'] = crypto_symbol
data['ds'] = data.index.values
data['y'] = data['Close']
132/132:
fig = plot_series(data)
fig
132/133:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima_model import ARIMA
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from datetime import datetime, timedelta
from matplotlib.widgets import Slider

class CryptoPrediction:
    def __init__(self, symbol, window_size=30):
        self.symbol = symbol
        data = self.load_data(self.symbol)
        self.window_size = window_size
        self.data = self.add_features(data)
        self.save_data = pd.DataFrame()
        self.save_data['Close'] = self.data['Close']      

    # Load data from a CSV file
    def load_data(self, ticker='BTC-USD'):
        data = download_data(ticker, '2023-01-01', '2023-12-09')
        return data

    def add_features(self, data):
        data['SMA5'] = data['Close'].rolling(5).mean()
        data['SMA20'] = data['Close'].rolling(20).mean()
        data['SMA60'] = data['Close'].rolling(60).mean()
        data['Close_Tomorrow'] = data['Close'].shift(-1)

        for i in range(1, self.window_size + 1):
            data[f'Close_{i}'] = data['Close'].shift(-i)
        
        return data.dropna()
    
    # Split data into training and test sets
    def split_data(self, target, data, train_ratio=0.8):
        train_size = int(len(data) * train_ratio)
        train_data = data[:train_size]
        test_data = data[train_size:]

        self.train_data = train_data
        self.test_data = test_data

        X_train = train_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_train = train_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)


        X_test = test_data.drop(columns=[f'Close_{i}' for i in range(1, self.window_size + 1)])  # Features
        y_test = test_data[[f'Close_{i}' for i in range(1, self.window_size + 1)]]  # Target variable (next 'window_size' closing prices)

        
        return X_train, y_train, X_test, y_test

    def predict_windows(self, window_size=30):
        # Create and train the linear regression model for each day in the window
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        models = []
        for i in range(self.window_size):
            model = LinearRegression()
            model.fit(X_train, y_train[f'Close_{i+1}'])
            models.append(model)
        y_preds = []
        for model in models:
            y_pred = model.predict(X_test)
            y_preds.append(y_pred)
        
        avg_pred = np.mean(y_preds, axis=0)
        plt.figure(figsize=(10, 5))
        plt.title(f"AVERGAGE Prediction")
        plt.plot(y_test.index[window_size:], y_test[f'Close_{i+0}'][:-window_size], label='Actual')
        plt.plot(y_test.index[window_size:], avg_pred[window_size:], label='Predicted', linestyle='--')
        plt.legend()
        plt.xlabel('Date')
        plt.ylabel('Closing Price')
        plt.grid(True)
        plt.show()
        
        # Visualize the predictions
        i=1
        plt.plot(y_test.index[i:], y_test[f'Close_{i+1}'][:-i], label='Actual')
        for i in range(window_size):
            plt.plot(y_test.index[i:], y_preds[i][i:], label='Predicted', linestyle='--')
        # Add a legend for the plotted lines
        plt.legend()

        # Show the plot
        plt.show()
        
    # Plot the data
    def plot_data(self, full_data, test_data, predictions, title="Data"):
        fig, ax1 = plt.subplots(figsize=(10, 6))

        # Plotting the actual data and predictions on the primary y-axis
        ax1.plot(full_data['Close_Tomorrow'], label='Actual Data', color='blue')
        ax1.plot(test_data.index, predictions, color='red', label='Predictions')
        ax1.set_xlabel("Time")
        ax1.set_ylabel("Value")
        ax1.tick_params(axis='y', labelcolor='blue')

        # Adding legends and title
        ax1.legend(loc='upper left')
        # ax2.legend(loc='upper right')
        plt.title(title)

        plt.show()

    def predict(self):
        X_train, y_train, X_test, y_test = self.split_data('Close_Tomorrow', self.data)
        
        # Fit a Linear Regression model and make predictions
        model = LinearRegression()
        model.fit(X_train, y_train)

        # Make predictions on the testing data
        predictions = model.predict(X_test)
        self.model = model

        mse = mean_squared_error(y_test, predictions)
        print(mse, 'MSE')

        # Plot the full data and predictions
        self.plot_data(self.data, self.test_data, predictions)

        score= self.model.score(X_test, y_test)
        print(score)
        return predictions

if __name__ == "__main__":
    # Example usage
    crypto_symbol = "ADA-USD"  # Replace with your desired cryptocurrency symbol
    window = 5
    cp = CryptoPrediction(crypto_symbol, window)
    models = cp.predict_windows(window)
    p_data = cp.predict()
132/134:
avg = np.mean(predictions, axis=0)
plt.plot(avg)
132/135: from utilsforecast.plotting import plot_series
132/136:
data = cp.data
data['unique_id'] = crypto_symbol
data['ds'] = data.index.values
data['y'] = data['Close']
132/137:
fig = plot_series(data, p_data)
fig
132/138: p_data
132/139:
lgb_params = {
    'verbosity': -1,
    'num_leaves': 512,
}

fcst = MLForecast(
    models={
        'avg': lgb.LGBMRegressor(**lgb_params),
        'q75': lgb.LGBMRegressor(**lgb_params, objective='quantile', alpha=0.75),
        'q25': lgb.LGBMRegressor(**lgb_params, objective='quantile', alpha=0.25),
    },
    freq=1,
    target_transforms=[Differences([24])],
    lags=[1, 24],
    lag_transforms={
        1: [expanding_mean],
        24: [(rolling_mean, 48)],
    },
    date_features=[hour_index],
)
fcst.fit(df)
132/140:
from utilsforecast.plotting import plot_series
import lightgbm as lgb
from numba import njit
from window_ops.expanding import expanding_mean
from window_ops.rolling import rolling_mean
from mlforecast import MLForecast
from mlforecast.target_transforms import Differences
def hour_index(times):
    return times % 24
132/141:
lgb_params = {
    'verbosity': -1,
    'num_leaves': 512,
}

fcst = MLForecast(
    models={
        'avg': lgb.LGBMRegressor(**lgb_params),
        'q75': lgb.LGBMRegressor(**lgb_params, objective='quantile', alpha=0.75),
        'q25': lgb.LGBMRegressor(**lgb_params, objective='quantile', alpha=0.25),
    },
    freq=1,
    target_transforms=[Differences([24])],
    lags=[1, 24],
    lag_transforms={
        1: [expanding_mean],
        24: [(rolling_mean, 48)],
    },
    date_features=[hour_index],
)
fcst.fit(df)
132/142:
data = cp.data
data['unique_id'] = crypto_symbol
data['ds'] = data.index.values
data['y'] = data['Close']
132/143:
data = cp.data
data['unique_id'] = crypto_symbol
data['ds'] = data.index.values
data['y'] = data['Close']
df = data
132/144:
lgb_params = {
    'verbosity': -1,
    'num_leaves': 512,
}

fcst = MLForecast(
    models={
        'avg': lgb.LGBMRegressor(**lgb_params),
        'q75': lgb.LGBMRegressor(**lgb_params, objective='quantile', alpha=0.75),
        'q25': lgb.LGBMRegressor(**lgb_params, objective='quantile', alpha=0.25),
    },
    freq=1,
    target_transforms=[Differences([24])],
    lags=[1, 24],
    lag_transforms={
        1: [expanding_mean],
        24: [(rolling_mean, 48)],
    },
    date_features=[hour_index],
)
fcst.fit(df)
132/145:
fcst = MLForecast(
    models=[],  # we're not interested in modeling yet
    freq=1,  # our series have integer timestamps, so we'll just add 1 in every timestep
    target_transforms=[Differences([24])],
)
prep = fcst.preprocess(df)
prep
132/146:
data = cp.data
data['unique_id'] = crypto_symbol
data['ds'] = data.index.values
data['y'] = data['Close']
df = data
132/147:
fig = plot_series(data)
fig
132/148:
fcst = MLForecast(
    models=[],  # we're not interested in modeling yet
    freq=1,  # our series have integer timestamps, so we'll just add 1 in every timestep
    target_transforms=[Differences([24])],
)
prep = fcst.preprocess(df)
prep
132/149:
fcst = MLForecast(
    models=[],  # we're not interested in modeling yet
    freq=1,  # our series have integer timestamps, so we'll just add 1 in every timestep
    target_transforms=[Differences([24])],
)
prep = fcst.preprocess(data)
prep
132/150:
fcst = MLForecast(
    models=[],  # we're not interested in modeling yet
    freq=1,  # our series have integer timestamps, so we'll just add 1 in every timestep
    target_transforms=[Differences([24])],
)
prep = fcst.preprocess(data)
prep
132/151: data.index.values
132/152:
data = cp.data
data['unique_id'] = crypto_symbol
data['ds'] = pd.to_datetime(data.index.values)
pd.to_datetime
data['y'] = data['Close']
df = data
132/153: data.index.values
132/154:
fig = plot_series(data)
fig
132/155:
fcst = MLForecast(
    models=[],  # we're not interested in modeling yet
    freq=1,  # our series have integer timestamps, so we'll just add 1 in every timestep
    target_transforms=[Differences([24])],
)
prep = fcst.preprocess(data)
prep
132/156:
data = cp.data
data['unique_id'] = crypto_symbol
data['ds'] = pd.to_datetime(data.index.values)
pd.to_datetime
data['y'] = data['Close']
df = data
df['ds'] = pd.to_datetime(df['ds'])
df = df.set_index('ds')
132/157: data.index.values
132/158:
fig = plot_series(data)
fig
132/159:
fcst = MLForecast(
    models=[],  # we're not interested in modeling yet
    freq=1,  # our series have integer timestamps, so we'll just add 1 in every timestep
    target_transforms=[Differences([24])],
)
prep = fcst.preprocess(data)
prep
133/1:
import plyvel

# Open the LevelDB database
db = plyvel.DB('031321.ldb', create_if_missing=False)

# Iterate over items in the database
for key, value in db.iterator():
    print(key, value)

# Always close the database when you're done
db.close()
133/2: !pip install plyvel
133/3:
import plyvel

# Open the LevelDB database
db = plyvel.DB('031321.ldb', create_if_missing=False)

# Iterate over items in the database
for key, value in db.iterator():
    print(key, value)

# Always close the database when you're done
db.close()
133/4:
import plyvel

# Open the LevelDB database
db = plyvel.DB('', create_if_missing=False)

# Iterate over items in the database
for key, value in db.iterator():
    print(key, value)

# Always close the database when you're done
db.close()
133/5:
import os
import plyvel

# Specify your directory containing .ldb files
directory_path = '/path/to/your/ldb/directory'

# List all files in the directory and sort them
files = sorted(os.listdir(directory_path))

# Find the first .ldb file
ldb_file = next((file for file in files if file.endswith('.ldb')), None)

if ldb_file:
    # Construct the full path
    full_path = os.path.join(directory_path, ldb_file)

    # Open the LevelDB database
    # Assuming that the .ldb file is part of a LevelDB database
    db = plyvel.DB(directory_path, create_if_missing=False)

    # Iterate over items in the database (or a part of it)
    for key, value in db.iterator():
        print(key, value)

    # Close the database
    db.close()
else:
    print("No .ldb file found in the directory")
133/6:
import os
import plyvel

# Specify your directory containing .ldb files
directory_path = ''

# List all files in the directory and sort them
files = sorted(os.listdir(directory_path))

# Find the first .ldb file
ldb_file = next((file for file in files if file.endswith('.ldb')), None)

if ldb_file:
    # Construct the full path
    full_path = os.path.join(directory_path, ldb_file)

    # Open the LevelDB database
    # Assuming that the .ldb file is part of a LevelDB database
    db = plyvel.DB(directory_path, create_if_missing=False)

    # Iterate over items in the database (or a part of it)
    for key, value in db.iterator():
        print(key, value)

    # Close the database
    db.close()
else:
    print("No .ldb file found in the directory")
133/7:
import os
import plyvel

# Specify your directory containing .ldb files
directory_path = '/'

# List all files in the directory and sort them
files = sorted(os.listdir(directory_path))

# Find the first .ldb file
ldb_file = next((file for file in files if file.endswith('.ldb')), None)

if ldb_file:
    # Construct the full path
    full_path = os.path.join(directory_path, ldb_file)

    # Open the LevelDB database
    # Assuming that the .ldb file is part of a LevelDB database
    db = plyvel.DB(directory_path, create_if_missing=False)

    # Iterate over items in the database (or a part of it)
    for key, value in db.iterator():
        print(key, value)

    # Close the database
    db.close()
else:
    print("No .ldb file found in the directory")
133/8:
import os
import plyvel

# Specify your directory containing .ldb files
directory_path = '../'

# List all files in the directory and sort them
files = sorted(os.listdir(directory_path))

# Find the first .ldb file
ldb_file = next((file for file in files if file.endswith('.ldb')), None)

if ldb_file:
    # Construct the full path
    full_path = os.path.join(directory_path, ldb_file)

    # Open the LevelDB database
    # Assuming that the .ldb file is part of a LevelDB database
    db = plyvel.DB(directory_path, create_if_missing=False)

    # Iterate over items in the database (or a part of it)
    for key, value in db.iterator():
        print(key, value)

    # Close the database
    db.close()
else:
    print("No .ldb file found in the directory")
133/9:
import os
import plyvel

# Specify your directory containing .ldb files
directory_path = '../objects/'

# List all files in the directory and sort them
files = sorted(os.listdir(directory_path))

# Find the first .ldb file
ldb_file = next((file for file in files if file.endswith('.ldb')), None)

if ldb_file:
    # Construct the full path
    full_path = os.path.join(directory_path, ldb_file)

    # Open the LevelDB database
    # Assuming that the .ldb file is part of a LevelDB database
    db = plyvel.DB(directory_path, create_if_missing=False)

    # Iterate over items in the database (or a part of it)
    for key, value in db.iterator():
        print(key, value)

    # Close the database
    db.close()
else:
    print("No .ldb file found in the directory")
134/1:
import os
import plyvel

# Specify your directory containing .ldb files
directory_path = '../history/index/'

# List all files in the directory and sort them
files = sorted(os.listdir(directory_path))

# Find the first .ldb file
ldb_file = next((file for file in files if file.endswith('.ldb')), None)

if ldb_file:
    # Construct the full path
    full_path = os.path.join(directory_path, ldb_file)

    # Open the LevelDB database
    # Assuming that the .ldb file is part of a LevelDB database
    db = plyvel.DB(directory_path, create_if_missing=False)

    # Iterate over items in the database (or a part of it)
    for key, value in db.iterator():
        print(key, value)

    # Close the database
    db.close()
else:
    print("No .ldb file found in the directory")
134/2:
import os
import plyvel

# Specify your directory containing .ldb files
directory_path = 'history/index/'

# List all files in the directory and sort them
files = sorted(os.listdir(directory_path))

# Find the first .ldb file
ldb_file = next((file for file in files if file.endswith('.ldb')), None)

if ldb_file:
    # Construct the full path
    full_path = os.path.join(directory_path, ldb_file)

    # Open the LevelDB database
    # Assuming that the .ldb file is part of a LevelDB database
    db = plyvel.DB(directory_path, create_if_missing=False)

    # Iterate over items in the database (or a part of it)
    for key, value in db.iterator():
        print(key, value)

    # Close the database
    db.close()
else:
    print("No .ldb file found in the directory")
134/3:
import os
import plyvel

# Specify your directory containing .ldb files
directory_path = 'test'

# List all files in the directory and sort them
files = sorted(os.listdir(directory_path))

# Find the first .ldb file
ldb_file = next((file for file in files if file.endswith('.ldb')), None)

if ldb_file:
    # Construct the full path
    full_path = os.path.join(directory_path, ldb_file)

    # Open the LevelDB database
    # Assuming that the .ldb file is part of a LevelDB database
    
    db = plyvel.DB(directory_path, create_if_missing=False)

    # Iterate over items in the database (or a part of it)
    for key, value in db.iterator():
        print(key, value)

    # Close the database
    db.close()
else:
    print("No .ldb file found in the directory")
134/4:
import os
import plyvel

# Specify your directory containing .ldb files
directory_path = 'test'

# List all files in the directory and sort them
files = sorted(os.listdir(directory_path))

# Find the first .ldb file
ldb_file = next((file for file in files if file.endswith('.ldb')), None)

if ldb_file:
    # Construct the full path
    full_path = os.path.join(directory_path, ldb_file)

    # Open the LevelDB database
    # Assuming that the .ldb file is part of a LevelDB database
    
    db = plyvel.DB(directory_path,) # create_if_missing=False)

    # Iterate over items in the database (or a part of it)
    for key, value in db.iterator():
        print(key, value)

    # Close the database
    db.close()
else:
    print("No .ldb file found in the directory")
134/5:
import os
import plyvel

# Specify your directory containing .ldb files
directory_path = 'test'

# List all files in the directory and sort them
files = sorted(os.listdir(directory_path))

# Find the first .ldb file
ldb_file = next((file for file in files if file.endswith('.ldb')), None)

if ldb_file:
    # Construct the full path
    full_path = os.path.join(directory_path, ldb_file)

    # Open the LevelDB database
    # Assuming that the .ldb file is part of a LevelDB database
    
    db = plyvel.DB(directory_path,) # create_if_missing=False)

    # Iterate over items in the database (or a part of it)
    for key, value in db.iterator():
        print(key, value)

    # Close the database
    db.close()
else:
    print("No .ldb file found in the directory")
134/6:
import os
import plyvel

# Specify your directory containing .ldb files
directory_path = 'test/'

# List all files in the directory and sort them
files = sorted(os.listdir(directory_path))

# Find the first .ldb file
ldb_file = next((file for file in files if file.endswith('.ldb')), None)

if ldb_file:
    # Construct the full path
    full_path = os.path.join(directory_path, ldb_file)

    # Open the LevelDB database
    # Assuming that the .ldb file is part of a LevelDB database
    
    db = plyvel.DB(directory_path,) # create_if_missing=False)

    # Iterate over items in the database (or a part of it)
    for key, value in db.iterator():
        print(key, value)

    # Close the database
    db.close()
else:
    print("No .ldb file found in the directory")
134/7:
import os
import plyvel

# Specify your directory containing .ldb files
directory_path = '/test/'

# List all files in the directory and sort them
files = sorted(os.listdir(directory_path))

# Find the first .ldb file
ldb_file = next((file for file in files if file.endswith('.ldb')), None)

if ldb_file:
    # Construct the full path
    full_path = os.path.join(directory_path, ldb_file)

    # Open the LevelDB database
    # Assuming that the .ldb file is part of a LevelDB database
    
    db = plyvel.DB(directory_path,) # create_if_missing=False)

    # Iterate over items in the database (or a part of it)
    for key, value in db.iterator():
        print(key, value)

    # Close the database
    db.close()
else:
    print("No .ldb file found in the directory")
134/8:
import os
import plyvel

# Specify your directory containing .ldb files
directory_path = 'test/'

# List all files in the directory and sort them
files = sorted(os.listdir(directory_path))

# Find the first .ldb file
ldb_file = next((file for file in files if file.endswith('.ldb')), None)

if ldb_file:
    # Construct the full path
    full_path = os.path.join(directory_path, ldb_file)

    # Open the LevelDB database
    # Assuming that the .ldb file is part of a LevelDB database
    
    db = plyvel.DB(directory_path,) # create_if_missing=False)

    # Iterate over items in the database (or a part of it)
    for key, value in db.iterator():
        print(key, value)

    # Close the database
    db.close()
else:
    print("No .ldb file found in the directory")
134/9:
import os
import plyvel

# Specify your directory containing .ldb files
directory_path = 'test/005693.ldb'

# List all files in the directory and sort them
files = sorted(os.listdir(directory_path))

# Find the first .ldb file
ldb_file = next((file for file in files if file.endswith('.ldb')), None)

if ldb_file:
    # Construct the full path
    full_path = os.path.join(directory_path, ldb_file)

    # Open the LevelDB database
    # Assuming that the .ldb file is part of a LevelDB database
    
    db = plyvel.DB(directory_path,) # create_if_missing=False)

    # Iterate over items in the database (or a part of it)
    for key, value in db.iterator():
        print(key, value)

    # Close the database
    db.close()
else:
    print("No .ldb file found in the directory")
134/10:
import os
import plyvel

# Specify your directory containing .ldb files
directory_path = 'test/005693.ldb'

# List all files in the directory and sort them
files = sorted(os.listdir(directory_path))

# Find the first .ldb file
ldb_file = next((file for file in files if file.endswith('.ldb')), None)

if ldb_file:
    # Construct the full path
    full_path = os.path.join(directory_path, ldb_file)

    # Open the LevelDB database
    # Assuming that the .ldb file is part of a LevelDB database
    
    db = plyvel.DB('test',) # create_if_missing=False)

    # Iterate over items in the database (or a part of it)
    for key, value in db.iterator():
        print(key, value)

    # Close the database
    db.close()
else:
    print("No .ldb file found in the directory")
134/11:
import os
import plyvel

# Specify your directory containing .ldb files
directory_path = 'test/005693.ldb'

# List all files in the directory and sort them
files = sorted(os.listdir(directory_path))

# Find the first .ldb file
ldb_file = next((file for file in files if file.endswith('.ldb')), None)

if ldb_file:
    # Construct the full path
    full_path = os.path.join(directory_path, ldb_file)

    # Open the LevelDB database
    # Assuming that the .ldb file is part of a LevelDB database
    
    db = plyvel.DB('test',) # create_if_missing=False)

    # Iterate over items in the database (or a part of it)
    for key, value in db.iterator():
        print(key, value)

    # Close the database
    db.close()
else:
    print("No .ldb file found in the directory")
134/12:
import os
import plyvel

# Specify your directory containing .ldb files
directory_path = 'test/005693.ldb'

# List all files in the directory and sort them
files = sorted(os.listdir(directory_path))

# Find the first .ldb file
ldb_file = next((file for file in files if file.endswith('.ldb')), None)

if ldb_file:
    # Construct the full path
    # full_path = os.path.join(directory_path, ldb_file)

    # Open the LevelDB database
    # Assuming that the .ldb file is part of a LevelDB database
    
    db = plyvel.DB('test',) # create_if_missing=False)

    # Iterate over items in the database (or a part of it)
    for key, value in db.iterator():
        print(key, value)

    # Close the database
    db.close()
else:
    print("No .ldb file found in the directory")
134/13:
import os
import plyvel

# Specify your directory containing .ldb files
directory_path = 'test/005693.ldb'

# List all files in the directory and sort them
# files = sorted(os.listdir(directory_path))

# Find the first .ldb file
ldb_file = next((file for file in files if file.endswith('.ldb')), None)

if ldb_file:
    # Construct the full path
    # full_path = os.path.join(directory_path, ldb_file)

    # Open the LevelDB database
    # Assuming that the .ldb file is part of a LevelDB database
    
    db = plyvel.DB('test',) # create_if_missing=False)

    # Iterate over items in the database (or a part of it)
    for key, value in db.iterator():
        print(key, value)

    # Close the database
    db.close()
else:
    print("No .ldb file found in the directory")
134/14:
import os
import plyvel

# Specify your directory containing .ldb files
directory_path = 'test/005693.ldb'

# List all files in the directory and sort them
# files = sorted(os.listdir(directory_path))

# Find the first .ldb file
ldb_file = next((file for file in files if file.endswith('.ldb')), None)

if ldb_file:
    # Construct the full path
    # full_path = os.path.join(directory_path, ldb_file)

    # Open the LevelDB database
    # Assuming that the .ldb file is part of a LevelDB database
    
    db = plyvel.DB('test/',) # create_if_missing=False)

    # Iterate over items in the database (or a part of it)
    for key, value in db.iterator():
        print(key, value)

    # Close the database
    db.close()
else:
    print("No .ldb file found in the directory")
134/15:
import os
import plyvel

# Specify your directory containing .ldb files
directory_path = 'test/005693.ldb'

# List all files in the directory and sort them
# files = sorted(os.listdir(directory_path))

# Find the first .ldb file
ldb_file = next((file for file in files if file.endswith('.ldb')), None)

if ldb_file:
    # Construct the full path
    # full_path = os.path.join(directory_path, ldb_file)

    # Open the LevelDB database
    # Assuming that the .ldb file is part of a LevelDB database
    
    db = plyvel.DB('test/', create_if_missing=False)

    # Iterate over items in the database (or a part of it)
    for key, value in db.iterator():
        print(key, value)

    # Close the database
    db.close()
else:
    print("No .ldb file found in the directory")
134/16:
import plyvel

def read_leveldb(ldb_path):
    try:
        # Open the LevelDB database
        db = plyvel.DB(ldb_path, create_if_missing=False)

        # Print the first few key-value pairs
        for key, value in db.iterator():
            print(key, value)
            break  # Remove this line to iterate over more items

        db.close()

    except Exception as e:
        print(f"An error occurred: {e}")

if __name__ == "__main__":
    ldb_file_path = 'test'  # Replace with the path to your .ldb file
    read_leveldb(ldb_file_path)
134/17:
import plyvel

def read_leveldb(ldb_path):
    try:
        # Open the LevelDB database
        db = plyvel.DB(ldb_path, create_if_missing=False)

        # Print the first few key-value pairs
        for key, value in db.iterator():
            print(key, value)
            break  # Remove this line to iterate over more items

        db.close()

    except Exception as e:
        print(f"An error occurred: {e}")

if __name__ == "__main__":
    ldb_file_path = 'test/005693.ldb'  # Replace with the path to your .ldb file
    read_leveldb(ldb_file_path)
134/18:
import plyvel

def read_leveldb(ldb_path):
    try:
        # Open the LevelDB database
        db = plyvel.DB(ldb_path)#, create_if_missing=False)

        # Print the first few key-value pairs
        for key, value in db.iterator():
            print(key, value)
            break  # Remove this line to iterate over more items

        db.close()

    except Exception as e:
        print(f"An error occurred: {e}")

if __name__ == "__main__":
    ldb_file_path = 'test/005693.ldb'  # Replace with the path to your .ldb file
    read_leveldb(ldb_file_path)
134/19:
import plyvel

def read_leveldb(ldb_path):
    try:
        # Open the LevelDB database
        db = plyvel.DB(ldb_path)#, create_if_missing=False)

        # Print the first few key-value pairs
        for key, value in db.iterator():
            print(key, value)
            break  # Remove this line to iterate over more items

        db.close()

    except Exception as e:
        print(f"An error occurred: {e}")

if __name__ == "__main__":
    ldb_file_path = 'test/'  # Replace with the path to your .ldb file
    read_leveldb(ldb_file_path)
134/20:
import plyvel

def read_leveldb(directory_path):
    try:
        # Open the LevelDB database
        db = plyvel.DB(directory_path, create_if_missing=False)

        # Print the first few key-value pairs
        for key, value in db.iterator():
            print(key, value)
            break  # Remove this line to iterate over more items

        db.close()

    except Exception as e:
        print(f"An error occurred: {e}")

if __name__ == "__main__":
    ldb_directory_path = 'test'  # Replace with the path to your .ldb directory
    read_leveldb(ldb_directory_path)
135/1: import main
135/2:
from consts import pools
from interest import get_historical_rates



# Example, switch pool index for different pool
address = pools[1]["child"]
print(get_historical_rates(pools[1], address))
135/3:
from consts import pools
from interest import get_historical_rates



# Example, switch pool index for different pool
address = pools[1]["child"]
data = get_historical_rates(pools[1], address)
print(data)
135/4: data.keys()
135/5: data['projected_borrow_rates']
135/6: data['projected_lender_apy']
135/7: data['raw_rates']
135/8: address
138/1:
import requests

def get_api_data(api_url):
    try:
        # Send a GET request to the API
        response = requests.get(api_url)

        # Check if the request was successful (status code 200)
        if response.status_code == 200:
            # Parse the response as JSON (assuming the API returns JSON data)
            data = response.json()
            return data
        else:
            print(f"Failed to retrieve data: Status code {response.status_code}")
            return None

    except requests.exceptions.RequestException as e:
        # Handle any exceptions that occur during the request
        print(f"An error occurred: {e}")
        return None
138/2:
# Replace 'your_api_url' with the actual URL of the API you want to access


wallet_api_url = "https://api.ergo.aap.cornell.edu/api/v1/boxes/unspent/byAddress/9eZPTmn8zp5GJ7KZwTo8cEuxNdezWaY3hBbLeWid7EAZedzb9tD"
token_id_url = 'https://api.ergo.aap.cornell.edu/api/v1/tokens/9f087ebb5d7baf7eb8f13b742e9a9b5b1b8d78b7a7f84d1f9b9d393f4888d679'
data = get_api_data(wallet_api_url)

if data is not None:
    print("Data retrieved from the API:")
    print(data)
else:
    print("No data retrieved.")
138/3:
import requests

def get_api_data(api_url):
    try:
        # Send a GET request to the API
        response = requests.get(api_url)

        # Check if the request was successful (status code 200)
        if response.status_code == 200:
            # Parse the response as JSON (assuming the API returns JSON data)
            data = response.json()
            return data
        else:
            print(f"Failed to retrieve data: Status code {response.status_code}")
            return None

    except requests.exceptions.RequestException as e:
        # Handle any exceptions that occur during the request
        print(f"An error occurred: {e}")
        return None

# Replace 'your_api_url' with the actual URL of the API you want to access
api_url = "your_api_url"
data = get_api_data(api_url)

if data is not None:
    print("Data retrieved from the API:")
    print(data)
else:
    print("No data retrieved.")
138/4:
# Replace 'your_api_url' with the actual URL of the API you want to access


wallet_api_url = "https://api.ergo.aap.cornell.edu/api/v1/boxes/unspent/byAddress/9eZPTmn8zp5GJ7KZwTo8cEuxNdezWaY3hBbLeWid7EAZedzb9tD"
token_id_url = 'https://api.ergo.aap.cornell.edu/api/v1/tokens/9f087ebb5d7baf7eb8f13b742e9a9b5b1b8d78b7a7f84d1f9b9d393f4888d679'
data = get_api_data(wallet_api_url)

if data is not None:
    print("Data retrieved from the API:")
    print(data)
else:
    print("No data retrieved.")
138/5:
# Replace 'your_api_url' with the actual URL of the API you want to access


wallet_api_url = "https://api.ergo.aap.cornell.edu/api/v1/boxes/unspent/byAddress/9eZPTmn8zp5GJ7KZwTo8cEuxNdezWaY3hBbLeWid7EAZedzb9tD"
token_id_url = 'https://api.ergo.aap.cornell.edu/api/v1/tokens/9f087ebb5d7baf7eb8f13b742e9a9b5b1b8d78b7a7f84d1f9b9d393f4888d679'
data = get_api_data(wallet_api_url)

data.keys()
138/6:
# Replace 'your_api_url' with the actual URL of the API you want to access


wallet_api_url = "https://api.ergo.aap.cornell.edu/api/v1/boxes/unspent/byAddress/9eZPTmn8zp5GJ7KZwTo8cEuxNdezWaY3hBbLeWid7EAZedzb9tD"
token_id_url = 'https://api.ergo.aap.cornell.edu/api/v1/tokens/9f087ebb5d7baf7eb8f13b742e9a9b5b1b8d78b7a7f84d1f9b9d393f4888d679'
data = get_api_data(wallet_api_url)

data
138/7:
# Replace 'your_api_url' with the actual URL of the API you want to access


wallet_api_url = "https://api.ergo.aap.cornell.edu/api/v1/boxes/unspent/byAddress/9eZPTmn8zp5GJ7KZwTo8cEuxNdezWaY3hBbLeWid7EAZedzb9tD"
token_id_url = 'https://api.ergo.aap.cornell.edu/api/v1/tokens/9f087ebb5d7baf7eb8f13b742e9a9b5b1b8d78b7a7f84d1f9b9d393f4888d679'
data = get_api_data(wallet_api_url)

data['items']['assets']
138/8:
# Replace 'your_api_url' with the actual URL of the API you want to access


wallet_api_url = "https://api.ergo.aap.cornell.edu/api/v1/boxes/unspent/byAddress/9eZPTmn8zp5GJ7KZwTo8cEuxNdezWaY3hBbLeWid7EAZedzb9tD"
token_id_url = 'https://api.ergo.aap.cornell.edu/api/v1/tokens/9f087ebb5d7baf7eb8f13b742e9a9b5b1b8d78b7a7f84d1f9b9d393f4888d679'
data = get_api_data(wallet_api_url)

data
138/9:
# Replace 'your_api_url' with the actual URL of the API you want to access


wallet_api_url = "https://api.ergo.aap.cornell.edu/api/v1/boxes/unspent/byAddress/9eZPTmn8zp5GJ7KZwTo8cEuxNdezWaY3hBbLeWid7EAZedzb9tD"
token_id_url = 'https://api.ergo.aap.cornell.edu/api/v1/tokens/9f087ebb5d7baf7eb8f13b742e9a9b5b1b8d78b7a7f84d1f9b9d393f4888d679'
data = get_api_data(wallet_api_url)

data['item']
138/10:
# Replace 'your_api_url' with the actual URL of the API you want to access


wallet_api_url = "https://api.ergo.aap.cornell.edu/api/v1/boxes/unspent/byAddress/9eZPTmn8zp5GJ7KZwTo8cEuxNdezWaY3hBbLeWid7EAZedzb9tD"
token_id_url = 'https://api.ergo.aap.cornell.edu/api/v1/tokens/9f087ebb5d7baf7eb8f13b742e9a9b5b1b8d78b7a7f84d1f9b9d393f4888d679'
data = get_api_data(wallet_api_url)

data['items']
138/11:
# Replace 'your_api_url' with the actual URL of the API you want to access


wallet_api_url = "https://api.ergo.aap.cornell.edu/api/v1/boxes/unspent/byAddress/9eZPTmn8zp5GJ7KZwTo8cEuxNdezWaY3hBbLeWid7EAZedzb9tD"
token_id_url = 'https://api.ergo.aap.cornell.edu/api/v1/tokens/9f087ebb5d7baf7eb8f13b742e9a9b5b1b8d78b7a7f84d1f9b9d393f4888d679'
data = get_api_data(wallet_api_url)

data['items'][0]
138/12:
# Replace 'your_api_url' with the actual URL of the API you want to access


wallet_api_url = "https://api.ergo.aap.cornell.edu/api/v1/boxes/unspent/byAddress/9eZPTmn8zp5GJ7KZwTo8cEuxNdezWaY3hBbLeWid7EAZedzb9tD"
token_id_url = 'https://api.ergo.aap.cornell.edu/api/v1/tokens/9f087ebb5d7baf7eb8f13b742e9a9b5b1b8d78b7a7f84d1f9b9d393f4888d679'
data = get_api_data(wallet_api_url)

data['items']
138/13: data['items'][1]
138/14: data['items'][1]['assets']
138/15:
ls = []
if ls:
    True
138/16:
ls = []
if ls:
    True
else:
    False
138/17:
ls = []
if ls:
    a = True
else:
    a = False
a
139/1:
import requests

class SigmaWalletReader:
    def __init__(self, api, token_id):
        self.api = api
        self.token_id = token_id
    
    def get_api_data(self, api_url):
        try:
            # Send a GET request to the API
            response = requests.get(api_url)
    
            # Check if the request was successful (status code 200)
            if response.status_code == 200:
                # Parse the response as JSON (assuming the API returns JSON data)
                data = response.json()
                return data
            else:
                print(f"Failed to retrieve data: Status code {response.status_code}")
                return None
    
        except requests.exceptions.RequestException as e:
            # Handle any exceptions that occur during the request
            print(f"An error occurred: {e}")
            return None

    def find_token_in_wallet(self, wallet, token='9f087ebb5d7baf7eb8f13b742e9a9b5b1b8d78b7a7f84d1f9b9d393f4888d679'):
        url = '{}/{}'.format(self.api, wallet)
        wallet_data = self.get_api_data(url)

        wallet_contents = wallet_data['items']
        for contents in wallet_contents:
            if contents['assets']:
                for items in contents['assets']:
                    token_id = items['token_id']
                    if token == token_id:
                        return True
                    else:
                        return False
139/2:
# Replace 'your_api_url' with the actual URL of the API you want to access

url = 'https://api.ergo.aap.cornell.edu/api/v1/boxes/unspent/byAddress/'
wallet = '9eZPTmn8zp5GJ7KZwTo8cEuxNdezWaY3hBbLeWid7EAZedzb9tD'
token_id_url = 'https://api.ergo.aap.cornell.edu/api/v1/tokens/9f087ebb5d7baf7eb8f13b742e9a9b5b1b8d78b7a7f84d1f9b9d393f4888d679'

reader = SigmaWalletReader(url, token_id='9f087ebb5d7baf7eb8f13b742e9a9b5b1b8d78b7a7f84d1f9b9d393f4888d679')
result = reader.find_token_in_wallet(wallet)
result
139/3:
import requests

class SigmaWalletReader:
    def __init__(self, api, token_id):
        self.api = api
        self.token_id = token_id
    
    def get_api_data(self, api_url):
        try:
            # Send a GET request to the API
            response = requests.get(api_url)
    
            # Check if the request was successful (status code 200)
            if response.status_code == 200:
                # Parse the response as JSON (assuming the API returns JSON data)
                data = response.json()
                return data
            else:
                print(f"Failed to retrieve data: Status code {response.status_code}")
                return None
    
        except requests.exceptions.RequestException as e:
            # Handle any exceptions that occur during the request
            print(f"An error occurred: {e}")
            return None

    def find_token_in_wallet(self, wallet,): # token='9f087ebb5d7baf7eb8f13b742e9a9b5b1b8d78b7a7f84d1f9b9d393f4888d679'):
        url = '{}/{}'.format(self.api, wallet)
        wallet_data = self.get_api_data(url)

        wallet_contents = wallet_data['items']
        for contents in wallet_contents:
            if contents['assets']:
                for items in contents['assets']:
                    token_id = items['tokenId']
                    if token == self.token_id:
                        return True
                    else:
                        return False
139/4:
# Replace 'your_api_url' with the actual URL of the API you want to access

url = 'https://api.ergo.aap.cornell.edu/api/v1/boxes/unspent/byAddress/'
wallet = '9eZPTmn8zp5GJ7KZwTo8cEuxNdezWaY3hBbLeWid7EAZedzb9tD'
token_id_url = 'https://api.ergo.aap.cornell.edu/api/v1/tokens/9f087ebb5d7baf7eb8f13b742e9a9b5b1b8d78b7a7f84d1f9b9d393f4888d679'

reader = SigmaWalletReader(url, token_id='9f087ebb5d7baf7eb8f13b742e9a9b5b1b8d78b7a7f84d1f9b9d393f4888d679')
result = reader.find_token_in_wallet(wallet)
result
139/5:
import requests

class SigmaWalletReader:
    def __init__(self, api, token_id):
        self.api = api
        self.token_id = token_id
    
    def get_api_data(self, api_url):
        try:
            # Send a GET request to the API
            response = requests.get(api_url)
    
            # Check if the request was successful (status code 200)
            if response.status_code == 200:
                # Parse the response as JSON (assuming the API returns JSON data)
                data = response.json()
                return data
            else:
                print(f"Failed to retrieve data: Status code {response.status_code}")
                return None
    
        except requests.exceptions.RequestException as e:
            # Handle any exceptions that occur during the request
            print(f"An error occurred: {e}")
            return None

    def find_token_in_wallet(self, wallet,): # token='9f087ebb5d7baf7eb8f13b742e9a9b5b1b8d78b7a7f84d1f9b9d393f4888d679'):
        url = '{}/{}'.format(self.api, wallet)
        wallet_data = self.get_api_data(url)

        wallet_contents = wallet_data['items']
        for contents in wallet_contents:
            if contents['assets']:
                for items in contents['assets']:
                    token_id = items['tokenId']
                    if token_id == self.token_id:
                        return True
                    else:
                        return False
139/6:
# Replace 'your_api_url' with the actual URL of the API you want to access

url = 'https://api.ergo.aap.cornell.edu/api/v1/boxes/unspent/byAddress/'
wallet = '9eZPTmn8zp5GJ7KZwTo8cEuxNdezWaY3hBbLeWid7EAZedzb9tD'
token_id_url = 'https://api.ergo.aap.cornell.edu/api/v1/tokens/9f087ebb5d7baf7eb8f13b742e9a9b5b1b8d78b7a7f84d1f9b9d393f4888d679'

reader = SigmaWalletReader(url, token_id='9f087ebb5d7baf7eb8f13b742e9a9b5b1b8d78b7a7f84d1f9b9d393f4888d679')
result = reader.find_token_in_wallet(wallet)
result
139/7:
import requests

class SigmaWalletReader:
    def __init__(self, api, token_id):
        self.api = api
        self.token_id = token_id
    
    def get_api_data(self, api_url):
        try:
            # Send a GET request to the API
            response = requests.get(api_url)
    
            # Check if the request was successful (status code 200)
            if response.status_code == 200:
                # Parse the response as JSON (assuming the API returns JSON data)
                data = response.json()
                return data
            else:
                print(f"Failed to retrieve data: Status code {response.status_code}")
                return None
    
        except requests.exceptions.RequestException as e:
            # Handle any exceptions that occur during the request
            print(f"An error occurred: {e}")
            return None

    def find_token_in_wallet(self, wallet,): # token='9f087ebb5d7baf7eb8f13b742e9a9b5b1b8d78b7a7f84d1f9b9d393f4888d679'):
        url = '{}/{}'.format(self.api, wallet)
        wallet_data = self.get_api_data(url)

        wallet_contents = wallet_data['items']
        for contents in wallet_contents:
            if contents['assets']:
                for items in contents['assets']:
                    token_id = items['tokenId']
                    print(items)
                    if token_id == self.token_id:
                        return True
                    else:
                        return False
139/8:
# Replace 'your_api_url' with the actual URL of the API you want to access

url = 'https://api.ergo.aap.cornell.edu/api/v1/boxes/unspent/byAddress/'
wallet = '9eZPTmn8zp5GJ7KZwTo8cEuxNdezWaY3hBbLeWid7EAZedzb9tD'
token_id_url = 'https://api.ergo.aap.cornell.edu/api/v1/tokens/9f087ebb5d7baf7eb8f13b742e9a9b5b1b8d78b7a7f84d1f9b9d393f4888d679'

reader = SigmaWalletReader(url, token_id='9f087ebb5d7baf7eb8f13b742e9a9b5b1b8d78b7a7f84d1f9b9d393f4888d679')
result = reader.find_token_in_wallet(wallet)
result
139/9:
import requests

class SigmaWalletReader:
    def __init__(self, api, token_id):
        self.api = api
        self.token_id = token_id
    
    def get_api_data(self, api_url):
        try:
            # Send a GET request to the API
            response = requests.get(api_url)
    
            # Check if the request was successful (status code 200)
            if response.status_code == 200:
                # Parse the response as JSON (assuming the API returns JSON data)
                data = response.json()
                return data
            else:
                print(f"Failed to retrieve data: Status code {response.status_code}")
                return None
    
        except requests.exceptions.RequestException as e:
            # Handle any exceptions that occur during the request
            print(f"An error occurred: {e}")
            return None

    def find_token_in_wallet(self, wallet,): # token='9f087ebb5d7baf7eb8f13b742e9a9b5b1b8d78b7a7f84d1f9b9d393f4888d679'):
        url = '{}/{}'.format(self.api, wallet)
        wallet_data = self.get_api_data(url)

        wallet_contents = wallet_data['items']
        for contents in wallet_contents:
            if contents['assets']:
                for items in contents['assets']:
                    token_id = items['tokenId']
                    print(items)
                    if token_id == self.token_id:
                        return True
139/10:
# Replace 'your_api_url' with the actual URL of the API you want to access

url = 'https://api.ergo.aap.cornell.edu/api/v1/boxes/unspent/byAddress/'
wallet = '9eZPTmn8zp5GJ7KZwTo8cEuxNdezWaY3hBbLeWid7EAZedzb9tD'
token_id_url = 'https://api.ergo.aap.cornell.edu/api/v1/tokens/9f087ebb5d7baf7eb8f13b742e9a9b5b1b8d78b7a7f84d1f9b9d393f4888d679'

reader = SigmaWalletReader(url, token_id='9f087ebb5d7baf7eb8f13b742e9a9b5b1b8d78b7a7f84d1f9b9d393f4888d679')
result = reader.find_token_in_wallet(wallet)
result
139/11:
import requests

class SigmaWalletReader:
    def __init__(self, api, token_id, token_ls_url='https://api.ergo.aap.cornell.edu/api/v1/tokens/'):
        self.api = api
        self.token_id = token_id
        self.token_ls = token_ls_url
    
    def get_api_data(self, api_url):
        try:
            # Send a GET request to the API
            response = requests.get(api_url)
    
            # Check if the request was successful (status code 200)
            if response.status_code == 200:
                # Parse the response as JSON (assuming the API returns JSON data)
                data = response.json()
                return data
            else:
                print(f"Failed to retrieve data: Status code {response.status_code}")
                return None
    
        except requests.exceptions.RequestException as e:
            # Handle any exceptions that occur during the request
            print(f"An error occurred: {e}")
            return None

    def find_token_in_wallet(self, wallet,): # token='9f087ebb5d7baf7eb8f13b742e9a9b5b1b8d78b7a7f84d1f9b9d393f4888d679'):
        url = '{}/{}'.format(self.api, wallet)
        wallet_data = self.get_api_data(url)

        wallet_contents = wallet_data['items']
        for contents in wallet_contents:
            if contents['assets']:
                for items in contents['assets']:
                    token_id = items['tokenId']
                    print(items)
                    if token_id == self.token_id:
                        return True
                        
    def get_token_description(self):
        url = '{}/{}'.format(self.token_ls, self.token_id)
        data = self.get_api_data(url)
139/12:
# Replace 'your_api_url' with the actual URL of the API you want to access

url = 'https://api.ergo.aap.cornell.edu/api/v1/boxes/unspent/byAddress/'
wallet = '9eZPTmn8zp5GJ7KZwTo8cEuxNdezWaY3hBbLeWid7EAZedzb9tD'
token_id_url = 'https://api.ergo.aap.cornell.edu/api/v1/tokens/9f087ebb5d7baf7eb8f13b742e9a9b5b1b8d78b7a7f84d1f9b9d393f4888d679'

reader = SigmaWalletReader(url,
                           token_id='9f087ebb5d7baf7eb8f13b742e9a9b5b1b8d78b7a7f84d1f9b9d393f4888d679',
                           token_ls_url='https://api.ergo.aap.cornell.edu/api/v1/tokens')

result = reader.find_token_in_wallet(wallet)
result
139/13:
# Replace 'your_api_url' with the actual URL of the API you want to access

url = 'https://api.ergo.aap.cornell.edu/api/v1/boxes/unspent/byAddress/'
wallet = '9eZPTmn8zp5GJ7KZwTo8cEuxNdezWaY3hBbLeWid7EAZedzb9tD'
token_id_url = 'https://api.ergo.aap.cornell.edu/api/v1/tokens/9f087ebb5d7baf7eb8f13b742e9a9b5b1b8d78b7a7f84d1f9b9d393f4888d679'

reader = SigmaWalletReader(url,
                           token_id='9f087ebb5d7baf7eb8f13b742e9a9b5b1b8d78b7a7f84d1f9b9d393f4888d679',
                           token_ls_url='https://api.ergo.aap.cornell.edu/api/v1/tokens')

result = reader.find_token_in_wallet(wallet)

desc = reader.get_token_description()
139/14:
# Replace 'your_api_url' with the actual URL of the API you want to access

url = 'https://api.ergo.aap.cornell.edu/api/v1/boxes/unspent/byAddress/'
wallet = '9eZPTmn8zp5GJ7KZwTo8cEuxNdezWaY3hBbLeWid7EAZedzb9tD'
token_id_url = 'https://api.ergo.aap.cornell.edu/api/v1/tokens/9f087ebb5d7baf7eb8f13b742e9a9b5b1b8d78b7a7f84d1f9b9d393f4888d679'

reader = SigmaWalletReader(url,
                           token_id='9f087ebb5d7baf7eb8f13b742e9a9b5b1b8d78b7a7f84d1f9b9d393f4888d679',
                           token_ls_url='https://api.ergo.aap.cornell.edu/api/v1/tokens')

result = reader.find_token_in_wallet(wallet)

desc = reader.get_token_description()
desc
139/15:
import requests

class SigmaWalletReader:
    def __init__(self, api, token_id, token_ls_url='https://api.ergo.aap.cornell.edu/api/v1/tokens/'):
        self.api = api
        self.token_id = token_id
        self.token_ls = token_ls_url
    
    def get_api_data(self, api_url):
        try:
            # Send a GET request to the API
            response = requests.get(api_url)
    
            # Check if the request was successful (status code 200)
            if response.status_code == 200:
                # Parse the response as JSON (assuming the API returns JSON data)
                data = response.json()
                return data
            else:
                print(f"Failed to retrieve data: Status code {response.status_code}")
                return None
    
        except requests.exceptions.RequestException as e:
            # Handle any exceptions that occur during the request
            print(f"An error occurred: {e}")
            return None

    def find_token_in_wallet(self, wallet,): # token='9f087ebb5d7baf7eb8f13b742e9a9b5b1b8d78b7a7f84d1f9b9d393f4888d679'):
        url = '{}/{}'.format(self.api, wallet)
        wallet_data = self.get_api_data(url)

        wallet_contents = wallet_data['items']
        for contents in wallet_contents:
            if contents['assets']:
                for items in contents['assets']:
                    token_id = items['tokenId']
                    # print(items)
                    if token_id == self.token_id:
                        return True
                        
    def get_token_description(self):
        url = '{}/{}'.format(self.token_ls, self.token_id)
        data = self.get_api_data(url)
139/16:
# Replace 'your_api_url' with the actual URL of the API you want to access

url = 'https://api.ergo.aap.cornell.edu/api/v1/boxes/unspent/byAddress/'
wallet = '9eZPTmn8zp5GJ7KZwTo8cEuxNdezWaY3hBbLeWid7EAZedzb9tD'
token_id_url = 'https://api.ergo.aap.cornell.edu/api/v1/tokens/9f087ebb5d7baf7eb8f13b742e9a9b5b1b8d78b7a7f84d1f9b9d393f4888d679'

reader = SigmaWalletReader(url,
                           token_id='9f087ebb5d7baf7eb8f13b742e9a9b5b1b8d78b7a7f84d1f9b9d393f4888d679',
                           token_ls_url='https://api.ergo.aap.cornell.edu/api/v1/tokens')

result = reader.find_token_in_wallet(wallet)

desc = reader.get_token_description()
desc
139/17:
import requests

class SigmaWalletReader:
    def __init__(self, api, token_id, token_ls_url='https://api.ergo.aap.cornell.edu/api/v1/tokens/'):
        self.api = api
        self.token_id = token_id
        self.token_ls = token_ls_url
    
    def get_api_data(self, api_url):
        try:
            # Send a GET request to the API
            response = requests.get(api_url)
    
            # Check if the request was successful (status code 200)
            if response.status_code == 200:
                # Parse the response as JSON (assuming the API returns JSON data)
                data = response.json()
                return data
            else:
                print(f"Failed to retrieve data: Status code {response.status_code}")
                return None
    
        except requests.exceptions.RequestException as e:
            # Handle any exceptions that occur during the request
            print(f"An error occurred: {e}")
            return None

    def find_token_in_wallet(self, wallet,): # token='9f087ebb5d7baf7eb8f13b742e9a9b5b1b8d78b7a7f84d1f9b9d393f4888d679'):
        url = '{}/{}'.format(self.api, wallet)
        wallet_data = self.get_api_data(url)

        wallet_contents = wallet_data['items']
        for contents in wallet_contents:
            if contents['assets']:
                for items in contents['assets']:
                    token_id = items['tokenId']
                    # print(items)
                    if token_id == self.token_id:
                        return True
                        
    def get_token_description(self):
        url = '{}/{}'.format(self.token_ls, self.token_id)
        data = self.get_api_data(url)
        return data
139/18:
# Replace 'your_api_url' with the actual URL of the API you want to access

url = 'https://api.ergo.aap.cornell.edu/api/v1/boxes/unspent/byAddress/'
wallet = '9eZPTmn8zp5GJ7KZwTo8cEuxNdezWaY3hBbLeWid7EAZedzb9tD'
token_id_url = 'https://api.ergo.aap.cornell.edu/api/v1/tokens/9f087ebb5d7baf7eb8f13b742e9a9b5b1b8d78b7a7f84d1f9b9d393f4888d679'

reader = SigmaWalletReader(url,
                           token_id='9f087ebb5d7baf7eb8f13b742e9a9b5b1b8d78b7a7f84d1f9b9d393f4888d679',
                           token_ls_url='https://api.ergo.aap.cornell.edu/api/v1/tokens')

result = reader.find_token_in_wallet(wallet)

desc = reader.get_token_description()
desc
139/19:
import requests

class SigmaWalletReader:
    def __init__(self, api, token_id, token_ls_url='https://api.ergo.aap.cornell.edu/api/v1/tokens/'):
        self.api = api
        self.token_id = token_id
        self.token_ls = token_ls_url
    
    def get_api_data(self, api_url):
        try:
            # Send a GET request to the API
            response = requests.get(api_url)
    
            # Check if the request was successful (status code 200)
            if response.status_code == 200:
                # Parse the response as JSON (assuming the API returns JSON data)
                data = response.json()
                return data
            else:
                print(f"Failed to retrieve data: Status code {response.status_code}")
                return None
    
        except requests.exceptions.RequestException as e:
            # Handle any exceptions that occur during the request
            print(f"An error occurred: {e}")
            return None

    def find_token_in_wallet(self, wallet,): # token='9f087ebb5d7baf7eb8f13b742e9a9b5b1b8d78b7a7f84d1f9b9d393f4888d679'):
        url = '{}/{}'.format(self.api, wallet)
        wallet_data = self.get_api_data(url)

        wallet_contents = wallet_data['items']
        for contents in wallet_contents:
            if contents['assets']:
                for items in contents['assets']:
                    token_id = items['tokenId']
                    if token_id == self.token_id:
                        return True
                        
    def get_token_description(self):
        url = '{}/{}'.format(self.token_ls, self.token_id)
        data = self.get_api_data(url)

        token_description = data['description']
        return token_description

    def run(self, wallet):

        token_in_wallet = self.find_token_in_wallet(wallet)
        if token_in_wallet:
            description = self.get_token_description()
            print('THE ADDRESS {} CONTAINS THE TOKEN {} WITH THE DESCRIPTION OF {}'.format(wallet,
                                                                                           self.token_id,
                                                                                           description))
            return description
        else:
            print('THE ADDRESS {} DOES NOT CONTAIN THE TOKEN {}'.format(wallet, self.token_id))
139/20:
# Replace 'your_api_url' with the actual URL of the API you want to access

url = 'https://api.ergo.aap.cornell.edu/api/v1/boxes/unspent/byAddress/'
wallet = '9eZPTmn8zp5GJ7KZwTo8cEuxNdezWaY3hBbLeWid7EAZedzb9tD'
token_id_url = 'https://api.ergo.aap.cornell.edu/api/v1/tokens/9f087ebb5d7baf7eb8f13b742e9a9b5b1b8d78b7a7f84d1f9b9d393f4888d679'

reader = SigmaWalletReader(url,
                           token_id='9f087ebb5d7baf7eb8f13b742e9a9b5b1b8d78b7a7f84d1f9b9d393f4888d679',
                           token_ls_url='https://api.ergo.aap.cornell.edu/api/v1/tokens')

result = reader.find_token_in_wallet(wallet)

desc = reader.get_token_description()
desc

reader.run(wallet)
139/21:
# Replace 'your_api_url' with the actual URL of the API you want to access

url = 'https://api.ergo.aap.cornell.edu/api/v1/boxes/unspent/byAddress/'
wallet = '9eZPTmn8zp5GJ7KZwTo8cEuxNdezWaY3hBbLeWid7EAZedzb9tD'
token_id_url = 'https://api.ergo.aap.cornell.edu/api/v1/tokens/9f087ebb5d7baf7eb8f13b742e9a9b5b1b8d78b7a7f84d1f9b9d393f4888d679'

reader = SigmaWalletReader(url,
                           token_id='9f087ebb5d7baf7eb8f13b742e9a9b5b1b8d78b7a7f84d1f9b9d393f4888d679',
                           token_ls_url='https://api.ergo.aap.cornell.edu/api/v1/tokens')
reader.run(wallet)
139/22:
# Replace 'your_api_url' with the actual URL of the API you want to access

url = 'https://api.ergo.aap.cornell.edu/api/v1/boxes/unspent/byAddress/'
wallet = '9eZPTmn8zp5GJ7KZwTo8cEuxNdezWaY3hBbLeWid7EAZedzb9tD'
token_id_url = 'https://api.ergo.aap.cornell.edu/api/v1/tokens/9f087ebb5d7baf7eb8f13b742e9a9b5b1b8d78b7a7f84d1f9b9d393f4888d679'

reader = SigmaWalletReader(url,
                           token_id='9f087ebb5d7baf7eb8f13b742e9a9b5b1b8d78b7a7f84d1f9b9d393f4888d679',
                           token_ls_url='https://api.ergo.aap.cornell.edu/api/v1/tokens')
desc = reader.run(wallet)
139/23:
# Replace 'your_api_url' with the actual URL of the API you want to access

url = 'https://api.ergo.aap.cornell.edu/api/v1/boxes/unspent/byAddress/'
wallet = '9eZPTmn8zp5GJ7KZwTo8cEuxNdezWaY3hBbLeWid7EAZedzb9tD'
token_id='9f087ebb5d7baf7eb8f13b742e9a9b5b1b8d78b7a7f84d1f9b9d393f4888d679',
token_ls_url='https://api.ergo.aap.cornell.edu/api/v1/tokens'

reader = SigmaWalletReader(url, token_id,token_ls_url)
desc = reader.run(wallet)
139/24:
url = 'https://api.ergo.aap.cornell.edu/api/v1/boxes/unspent/byAddress/'
wallet = '9eZPTmn8zp5GJ7KZwTo8cEuxNdezWaY3hBbLeWid7EAZedzb9tD'
token_id='9f087ebb5d7baf7eb8f13b742e9a9b5b1b8d78b7a7f84d1f9b9d393f4888d679'
token_ls_url='https://api.ergo.aap.cornell.edu/api/v1/tokens'

reader = SigmaWalletReader(url, token_id,token_ls_url)
desc = reader.run(wallet)
139/25:
wallet = '9ehJZvPDgvCNNd2zTQHxnSpcCAtb1kHbEN1VAgeoRD5DPVApYkk'
desc = reader.run(wallet)
140/1:
import requests

class SigmaWalletReader:
    def __init__(self, api, token_id, token_ls_url='https://api.ergo.aap.cornell.edu/api/v1/tokens/'):
        self.api = api
        self.token_id = token_id
        self.token_ls = token_ls_url
    
    def get_api_data(self, api_url):
        try:
            # Send a GET request to the API
            response = requests.get(api_url)
    
            # Check if the request was successful (status code 200)
            if response.status_code == 200:
                # Parse the response as JSON (assuming the API returns JSON data)
                data = response.json()
                return data
            else:
                print(f"Failed to retrieve data: Status code {response.status_code}")
                return None
    
        except requests.exceptions.RequestException as e:
            # Handle any exceptions that occur during the request
            print(f"An error occurred: {e}")
            return None

    def find_token_in_wallet(self, wallet,): # token='9f087ebb5d7baf7eb8f13b742e9a9b5b1b8d78b7a7f84d1f9b9d393f4888d679'):
        url = '{}/{}'.format(self.api, wallet)
        wallet_data = self.get_api_data(url)

        wallet_contents = wallet_data['items']
        for contents in wallet_contents:
            if contents['assets']:
                for items in contents['assets']:
                    token_id = items['tokenId']
                    if token_id == self.token_id:
                        return True
                        
    def get_token_description(self):
        url = '{}/{}'.format(self.token_ls, self.token_id)
        data = self.get_api_data(url)

        token_description = data['description']
        return token_description

    def run(self, wallet):

        token_in_wallet = self.find_token_in_wallet(wallet)
        if token_in_wallet:
            description = self.get_token_description()
            print('THE ADDRESS {} CONTAINS THE TOKEN {} WITH THE DESCRIPTION OF {}'.format(wallet,
                                                                                           self.token_id,
                                                                                           description))
            return description
        else:
            print('THE ADDRESS {} DOES NOT CONTAIN THE TOKEN {}'.format(wallet, self.token_id))
140/2:
url = 'https://api.ergo.aap.cornell.edu/api/v1/boxes/unspent/byAddress/'
wallet = '9eZPTmn8zp5GJ7KZwTo8cEuxNdezWaY3hBbLeWid7EAZedzb9tD'
token_id='9f087ebb5d7baf7eb8f13b742e9a9b5b1b8d78b7a7f84d1f9b9d393f4888d679'
token_ls_url='https://api.ergo.aap.cornell.edu/api/v1/tokens'

reader = SigmaWalletReader(url, token_id,token_ls_url)
desc = reader.run(wallet)
140/3:
wallet = '9ehJZvPDgvCNNd2zTQHxnSpcCAtb1kHbEN1VAgeoRD5DPVApYkk'
desc = reader.run(wallet)
142/1:
url = 'http://74.69.128.24:4000/api/pools/'
reader = SigmaReader('')
data = reader.get_api_data(url)
142/2:
import requests

class SigmaReader:
    def __init__(self, api, token_id=None, token_ls_url='https://api.ergo.aap.cornell.edu/api/v1/tokens/'):
        self.api = api
        self.token_id = token_id
        self.token_ls = token_ls_url
    
    def get_api_data(self, url):
        try:
            # Send a GET request to the API
            response = requests.get(url)
    
            # Check if the request was successful (status code 200)
            if response.status_code == 200:
                # Parse the response as JSON (assuming the API returns JSON data)
                data = response.json()
                return data
            else:
                print(f"Failed to retrieve data: Status code {response.status_code}")
                return None
    
        except requests.exceptions.RequestException as e:
            # Handle any exceptions that occur during the request
            print(f"An error occurred: {e}")
            return None

    def find_token_in_wallet(self, wallet,):
        url = '{}/{}'.format(self.api, wallet)
        wallet_data = self.get_api_data(url)

        wallet_contents = wallet_data['items']
        for contents in wallet_contents:
            if contents['assets']:
                for items in contents['assets']:
                    token_id = items['tokenId']
                    if token_id == self.token_id:
                        return True
                        
    def get_token_description(self):
        url = '{}/{}'.format(self.token_ls, self.token_id)
        data = self.get_api_data(url)

        token_description = data['description']
        return token_description

    def run(self, wallet):

        token_in_wallet = self.find_token_in_wallet(wallet)
        if token_in_wallet:
            description = self.get_token_description()
            print('THE ADDRESS {} CONTAINS THE TOKEN {} WITH THE DESCRIPTION OF {}'.format(wallet,
                                                                                           self.token_id,
                                                                                           description))
            return description
        else:
            print('THE ADDRESS {} DOES NOT CONTAIN THE TOKEN {}'.format(wallet, self.token_id))
142/3:
url = 'https://api.ergo.aap.cornell.edu/api/v1/boxes/unspent/byAddress/'
wallet = '9eZPTmn8zp5GJ7KZwTo8cEuxNdezWaY3hBbLeWid7EAZedzb9tD'
token_id='9f087ebb5d7baf7eb8f13b742e9a9b5b1b8d78b7a7f84d1f9b9d393f4888d679'
token_ls_url='https://api.ergo.aap.cornell.edu/api/v1/tokens'

reader = SigmaReader(url, token_id,token_ls_url)
desc = reader.run(wallet)
142/4:
wallet = '9ehJZvPDgvCNNd2zTQHxnSpcCAtb1kHbEN1VAgeoRD5DPVApYkk'
desc = reader.run(wallet)
142/5:
url = 'http://74.69.128.24:4000/api/pools/'
reader = SigmaReader('')
data = reader.get_api_data(url)
142/6:
url = 'http://74.69.128.24:4000/api/pools/'
reader = SigmaReader('')
data = reader.get_api_data(url)
data
142/7: data.keys()
142/8: data.pools.keys()
142/9: data.pools.
142/10: data.pools
142/11: data['pools']
142/12: data['pools'][1]
142/13: data['pools'][0]
142/14: data['pools'][0].keys()
142/15:
d = data['pools'][0]
for key in d.keys():
    print(d[key])
142/16:
d = data['pools'][0]
for key in d.keys():
    print(d[key], '/n')
142/17:
d = data['pools'][0]
for key in d.keys():
    print(d[key], '\n')
142/18:
d = data['pools'][0]
for key in d.keys():
    print(key, d[key], '\n')
142/19:
url = 'http://74.69.128.24:4000/api/pools/'
reader = SigmaReader('')
data = reader.get_api_data(url)
data
142/20: data['pools'][0].keys()
142/21:
d = data['pools'][0]
for key in d.keys():
    print(key, d[key], '\n')
144/1:
import requests

class SigmaReader:
    def __init__(self, api, token_id=None, token_ls_url='https://api.ergo.aap.cornell.edu/api/v1/tokens/'):
        self.api = api
        self.token_id = token_id
        self.token_ls = token_ls_url
    
    def get_api_data(self, url):
        try:
            # Send a GET request to the API
            response = requests.get(url)
    
            # Check if the request was successful (status code 200)
            if response.status_code == 200:
                # Parse the response as JSON (assuming the API returns JSON data)
                data = response.json()
                return data
            else:
                print(f"Failed to retrieve data: Status code {response.status_code}")
                return None
    
        except requests.exceptions.RequestException as e:
            # Handle any exceptions that occur during the request
            print(f"An error occurred: {e}")
            return None

    def find_token_in_wallet(self, wallet,):
        url = '{}/{}'.format(self.api, wallet)
        wallet_data = self.get_api_data(url)

        wallet_contents = wallet_data['items']
        for contents in wallet_contents:
            if contents['assets']:
                for items in contents['assets']:
                    token_id = items['tokenId']
                    if token_id == self.token_id:
                        return True
                        
    def get_token_description(self):
        url = '{}/{}'.format(self.token_ls, self.token_id)
        data = self.get_api_data(url)

        token_description = data['description']
        return token_description

    def run(self, wallet):

        token_in_wallet = self.find_token_in_wallet(wallet)
        if token_in_wallet:
            description = self.get_token_description()
            print('THE ADDRESS {} CONTAINS THE TOKEN {} WITH THE DESCRIPTION OF {}'.format(wallet,
                                                                                           self.token_id,
                                                                                           description))
            return description
        else:
            print('THE ADDRESS {} DOES NOT CONTAIN THE TOKEN {}'.format(wallet, self.token_id))
144/2:
url = 'https://api.ergo.aap.cornell.edu/api/v1/boxes/unspent/byAddress/'
wallet = '9eZPTmn8zp5GJ7KZwTo8cEuxNdezWaY3hBbLeWid7EAZedzb9tD'
token_id='9f087ebb5d7baf7eb8f13b742e9a9b5b1b8d78b7a7f84d1f9b9d393f4888d679'
token_ls_url='https://api.ergo.aap.cornell.edu/api/v1/tokens'

reader = SigmaReader(url, token_id,token_ls_url)
desc = reader.run(wallet)
144/3:
wallet = '9ehJZvPDgvCNNd2zTQHxnSpcCAtb1kHbEN1VAgeoRD5DPVApYkk'
desc = reader.run(wallet)
144/4:
url = 'http://74.69.128.24:4000/api/pools/'
reader = SigmaReader('')
data = reader.get_api_data(url)
data
144/5: data['pools'][0].keys()
144/6:
d = data['pools'][0]
for key in d.keys():
    print(key, d[key], '\n')
144/7:
url = 'http://74.69.128.24:4000/api/pools/ErgoSigmanauts/miners/9ehJZvPDgvCNNd2zTQHxnSpcCAtb1kHbEN1VAgeoRD5DPVApYkk'
reader = SigmaReader('')
data = reader.get_api_data(url)
data
144/8:
url = 'http://74.69.128.24:4000/api/' #pools/ErgoSigmanauts/miners/9ehJZvPDgvCNNd2zTQHxnSpcCAtb1kHbEN1VAgeoRD5DPVApYkk'
reader = SigmaReader('')
data = reader.get_api_data(url)
data
144/9:
url = 'http://74.69.128.24:4000/api/pools' #/ErgoSigmanauts/miners/9ehJZvPDgvCNNd2zTQHxnSpcCAtb1kHbEN1VAgeoRD5DPVApYkk'
reader = SigmaReader('')
data = reader.get_api_data(url)
data
144/10:
url = 'http://74.69.128.24:4000/api/pools/ErgoSigmanauts' #/miners/9ehJZvPDgvCNNd2zTQHxnSpcCAtb1kHbEN1VAgeoRD5DPVApYkk'
reader = SigmaReader('')
data = reader.get_api_data(url)
data
144/11:
url = 'http://74.69.128.24:4000/api/pools/ErgoSigmanauts/miners' #/9ehJZvPDgvCNNd2zTQHxnSpcCAtb1kHbEN1VAgeoRD5DPVApYkk'
reader = SigmaReader('')
data = reader.get_api_data(url)
data
144/12:
url = 'http://74.69.128.24:4000/api/pools/ErgoSigmanauts/miners' #/9ehJZvPDgvCNNd2zTQHxnSpcCAtb1kHbEN1VAgeoRD5DPVApYkk'
reader = SigmaReader('')
data = reader.get_api_data(url)
data
144/13:
url = 'http://74.69.128.24:4000/api/pools/ErgoSigmanauts/miners' #/9ehJZvPDgvCNNd2zTQHxnSpcCAtb1kHbEN1VAgeoRD5DPVApYkk'
reader = SigmaReader('')
data = reader.get_api_data(url)
data
144/14:
url = 'http://74.69.128.24:4000/api/pools/ErgoSigmanauts/miners/9ehJZvPDgvCNNd2zTQHxnSpcCAtb1kHbEN1VAgeoRD5DPVApYkk'
reader = SigmaReader('')
data = reader.get_api_data(url)
data
144/15:
url = 'http://74.69.128.24:4000/api/pools/ErgoSigmanauts/miners/9ehJZvPDgvCNNd2zTQHxnSpcCAtb1kHbEN1VAgeoRD5DPVApYkk'
reader = SigmaReader('')
data = reader.get_api_data(url)
data
144/16:
url = 'http://74.69.128.24:4000/api/pools/'
reader = SigmaReader('')
data = reader.get_api_data(url)
data
145/1:
url='https://my.ergoport.dev/cgi-bin/mining/mining_all.html?a=9ehJZvPDgvCNNd2zTQHxnSpcCAtb1kHbEN1VAgeoRD5DPVApYkk'
reader = SigmaReader('')
data = reader.get_api_data(url)
data
146/1:
import requests

class SigmaReader:
    def __init__(self, api, token_id=None, token_ls_url='https://api.ergo.aap.cornell.edu/api/v1/tokens/'):
        self.api = api
        self.token_id = token_id
        self.token_ls = token_ls_url
    
    def get_api_data(self, url):
        try:
            # Send a GET request to the API
            response = requests.get(url)
    
            # Check if the request was successful (status code 200)
            if response.status_code == 200:
                # Parse the response as JSON (assuming the API returns JSON data)
                data = response.json()
                return data
            else:
                print(f"Failed to retrieve data: Status code {response.status_code}")
                return None
    
        except requests.exceptions.RequestException as e:
            # Handle any exceptions that occur during the request
            print(f"An error occurred: {e}")
            return None

    def find_token_in_wallet(self, wallet,):
        url = '{}/{}'.format(self.api, wallet)
        wallet_data = self.get_api_data(url)

        wallet_contents = wallet_data['items']
        for contents in wallet_contents:
            if contents['assets']:
                for items in contents['assets']:
                    token_id = items['tokenId']
                    if token_id == self.token_id:
                        return True
                        
    def get_token_description(self):
        url = '{}/{}'.format(self.token_ls, self.token_id)
        data = self.get_api_data(url)

        token_description = data['description']
        return token_description

    def run(self, wallet):

        token_in_wallet = self.find_token_in_wallet(wallet)
        if token_in_wallet:
            description = self.get_token_description()
            print('THE ADDRESS {} CONTAINS THE TOKEN {} WITH THE DESCRIPTION OF {}'.format(wallet,
                                                                                           self.token_id,
                                                                                           description))
            return description
        else:
            print('THE ADDRESS {} DOES NOT CONTAIN THE TOKEN {}'.format(wallet, self.token_id))
146/2:
url = 'https://api.ergo.aap.cornell.edu/api/v1/boxes/unspent/byAddress/'
wallet = '9eZPTmn8zp5GJ7KZwTo8cEuxNdezWaY3hBbLeWid7EAZedzb9tD'
token_id='9f087ebb5d7baf7eb8f13b742e9a9b5b1b8d78b7a7f84d1f9b9d393f4888d679'
token_ls_url='https://api.ergo.aap.cornell.edu/api/v1/tokens'

reader = SigmaReader(url, token_id,token_ls_url)
desc = reader.run(wallet)
146/3:
wallet = '9ehJZvPDgvCNNd2zTQHxnSpcCAtb1kHbEN1VAgeoRD5DPVApYkk'
desc = reader.run(wallet)
146/4:
url = 'http://74.69.128.24:4000/api/pools/'
reader = SigmaReader('')
data = reader.get_api_data(url)
data
146/5:
url = 'http://74.69.128.24:4000/api/pools/'
reader = SigmaReader('')
data = reader.get_api_data(url)
data
146/6: data['pools'][0].keys()
146/7:
d = data['pools'][0]
for key in d.keys():
    print(key, d[key], '\n')
146/8:
url = 'http://74.69.128.24:4000/api/pools/ErgoSigmanauts/miners/9ehJZvPDgvCNNd2zTQHxnSpcCAtb1kHbEN1VAgeoRD5DPVApYkk'
reader = SigmaReader('')
data = reader.get_api_data(url)
data
146/9:
url='https://my.ergoport.dev/cgi-bin/mining/mining_all.html?a=9ehJZvPDgvCNNd2zTQHxnSpcCAtb1kHbEN1VAgeoRD5DPVApYkk'
reader = SigmaReader('')
data = reader.get_api_data(url)
data
146/10:
url='my.ergoport.dev/cgi-bin/mining/mining_all.html?a=9ehJZvPDgvCNNd2zTQHxnSpcCAtb1kHbEN1VAgeoRD5DPVApYkk'
reader = SigmaReader('')
data = reader.get_api_data(url)
data
146/11:
url='https://my.ergoport.dev/cgi-bin/mining/mining_all.html?a=9ehJZvPDgvCNNd2zTQHxnSpcCAtb1kHbEN1VAgeoRD5DPVApYkk'
reader = SigmaReader('')
data = reader.get_api_data(url)
data
147/1:
url='http://74.69.128.24:4000/api/pools/ErgoSigmanauts/Blocks'
reader = SigmaReader('')
data = reader.get_api_data(url)
data
148/1:
import requests

class SigmaReader:
    def __init__(self, api, token_id=None, token_ls_url='https://api.ergo.aap.cornell.edu/api/v1/tokens/'):
        self.api = api
        self.token_id = token_id
        self.token_ls = token_ls_url
    
    def get_api_data(self, url):
        try:
            # Send a GET request to the API
            response = requests.get(url)
    
            # Check if the request was successful (status code 200)
            if response.status_code == 200:
                # Parse the response as JSON (assuming the API returns JSON data)
                data = response.json()
                return data
            else:
                print(f"Failed to retrieve data: Status code {response.status_code}")
                return None
    
        except requests.exceptions.RequestException as e:
            # Handle any exceptions that occur during the request
            print(f"An error occurred: {e}")
            return None

    def find_token_in_wallet(self, wallet,):
        url = '{}/{}'.format(self.api, wallet)
        wallet_data = self.get_api_data(url)

        wallet_contents = wallet_data['items']
        for contents in wallet_contents:
            if contents['assets']:
                for items in contents['assets']:
                    token_id = items['tokenId']
                    if token_id == self.token_id:
                        return True
                        
    def get_token_description(self):
        url = '{}/{}'.format(self.token_ls, self.token_id)
        data = self.get_api_data(url)

        token_description = data['description']
        return token_description

    def run(self, wallet):

        token_in_wallet = self.find_token_in_wallet(wallet)
        if token_in_wallet:
            description = self.get_token_description()
            print('THE ADDRESS {} CONTAINS THE TOKEN {} WITH THE DESCRIPTION OF {}'.format(wallet,
                                                                                           self.token_id,
                                                                                           description))
            return description
        else:
            print('THE ADDRESS {} DOES NOT CONTAIN THE TOKEN {}'.format(wallet, self.token_id))
148/2:
url = 'https://api.ergo.aap.cornell.edu/api/v1/boxes/unspent/byAddress/'
wallet = '9eZPTmn8zp5GJ7KZwTo8cEuxNdezWaY3hBbLeWid7EAZedzb9tD'
token_id='9f087ebb5d7baf7eb8f13b742e9a9b5b1b8d78b7a7f84d1f9b9d393f4888d679'
token_ls_url='https://api.ergo.aap.cornell.edu/api/v1/tokens'

reader = SigmaReader(url, token_id,token_ls_url)
desc = reader.run(wallet)
148/3:
wallet = '9ehJZvPDgvCNNd2zTQHxnSpcCAtb1kHbEN1VAgeoRD5DPVApYkk'
desc = reader.run(wallet)
148/4:
url = 'http://74.69.128.24:4000/api/pools/'
reader = SigmaReader('')
data = reader.get_api_data(url)
data
148/5:
url = 'http://74.69.128.24:4000/api/pools/'
reader = SigmaReader('')
data = reader.get_api_data(url)
data
148/6: data['pools'][0].keys()
148/7:
d = data['pools'][0]
for key in d.keys():
    print(key, d[key], '\n')
148/8:
url = 'http://74.69.128.24:4000/api/pools/ErgoSigmanauts/miners/9ehJZvPDgvCNNd2zTQHxnSpcCAtb1kHbEN1VAgeoRD5DPVApYkk'
reader = SigmaReader('')
data = reader.get_api_data(url)
data
148/9:
url='http://74.69.128.24:4000/api/pools/ErgoSigmanauts/Blocks'
reader = SigmaReader('')
data = reader.get_api_data(url)
data
148/10: data['pendingShares']
148/11:
miner_data = data[0]
miner_data['pendingShares']
148/12:
miner_data = data[0]
miner_data['pendingShares']
148/13:
url = 'http://74.69.128.24:4000/api/pools/ErgoSigmanauts/miners/9ehJZvPDgvCNNd2zTQHxnSpcCAtb1kHbEN1VAgeoRD5DPVApYkk'
reader = SigmaReader('')
data = reader.get_api_data(url)
data
148/14:
miner_data = data[0]
miner_data['pendingShares']
148/15: data['pendingShares']
148/16:
url = 'http://74.69.128.24:4000/api/pools/ErgoSigmanauts/miners/9ehJZvPDgvCNNd2zTQHxnSpcCAtb1kHbEN1VAgeoRD5DPVApYkk'
reader = SigmaReader('')
data = reader.get_api_data(url)
data
148/17: data['performance']
148/18:
url='http://74.69.128.24:4000/api/pools/ErgoSigmanauts/Blocks/'
reader = SigmaReader('')
data = reader.get_api_data(url)
data
148/19:
url='http://74.69.128.24:4000/api/pools/ErgoSigmanauts/Blocks/'
reader = SigmaReader('')
data = reader.get_api_data(url)
data[0]
148/20:
url='http://74.69.128.24:4000/api/pools/ErgoSigmanauts/Blocks/'
reader = SigmaReader('')
data = reader.get_api_data(url)
data
148/21:
url='http://74.69.128.24:4000/api/pools/ErgoSigmanauts/'
reader = SigmaReader('')
data = reader.get_api_data(url)
data
148/22:
url='http://74.69.128.24:4000/api/pools/ErgoSigmanauts/'
reader = SigmaReader('')
data = reader.get_api_data(url)
data['poolStats']
148/23:
url='http://74.69.128.24:4000/api/pools/ErgoSigmanauts/'
reader = SigmaReader('')
data = reader.get_api_data(url)
data
148/24:
url='http://74.69.128.24:4000/api/pools/ErgoSigmanauts/'
reader = SigmaReader('')
data = reader.get_api_data(url)
data.keys()
148/25:
url='http://74.69.128.24:4000/api/pools/ErgoSigmanauts/'
reader = SigmaReader('')
data = reader.get_api_data(url)
data['pool']
148/26:
url='http://74.69.128.24:4000/api/pools/ErgoSigmanauts/'
reader = SigmaReader('')
data = reader.get_api_data(url)
data['pool']['poolStats']
148/27: data['pool']
148/28: data['pool']['networkStats']
148/29: data['pool']['topMiners']
148/30: data['pool']
148/31:
url='http://74.69.128.24:4000/api/pools/ErgoSigmanauts/Blocks'
reader = SigmaReader('')
data = reader.get_api_data(url)
data['pool']['poolStats']
data['pool']['networkStats']
data['pool']['topMiners']
148/32:
url='http://74.69.128.24:4000/api/pools/ErgoSigmanauts/Blocks'
reader = SigmaReader('')
data = reader.get_api_data(url)
# data['pool']['poolStats']
# data['pool']['networkStats']
# data['pool']['topMiners']
148/33: data
149/1:
from utils.reader import SigmaWalletReader
reader = SigmaWalletReader(config_path="../conf")
149/2:
data = reader.run_app()
data
149/3:
data = reader.run_app()
x, y, z = data
149/4: x
149/5: x[0]
149/6: block_df = pd.DataFrame(x[0])
149/7:
from utils.reader import SigmaWalletReader
import pandas as pd
reader = SigmaWalletReader(config_path="../conf")
149/8: block_df = pd.DataFrame(x[0])
150/1:
from utils.reader import SigmaWalletReader
import pandas as pd
reader = SigmaWalletReader(config_path="../conf")
150/2:
data = reader.run_app()
x, y, z = data
150/3: block_df = pd.DataFrame(x[0])
150/4:
block_df = pd.DataFrame(x[0])
block_df
150/5: y
150/6: x[1]
150/7: miner_found_blocks = pd.DataFrame(x[1])
150/8: x[1]
150/9:
miner_found_blocks = pd.DataFrame([x[1]])
miner_found_blocks
150/10:

# Convert to DataFrame
df = pd.DataFrame.from_dict(x[1], orient='index', columns=['Value'])

# Reset the index to make the keys a separate column
df.reset_index(inplace=True)

# Rename columns as desired
df.columns = ['Key', 'Value']
150/11:

# Convert to DataFrame
df = pd.DataFrame.from_dict(x[1], orient='index', columns=['Value'])

# Reset the index to make the keys a separate column
df.reset_index(inplace=True)

# Rename columns as desired
df.columns = ['Key', 'Value']
df
150/12:

# Convert to DataFrame
df = pd.DataFrame.from_dict(x[1], orient='index', columns=['Value'])

# Reset the index to make the keys a separate column
df.reset_index(inplace=True)

# Rename columns as desired
df.columns = ['Miner', 'Number of Blocks Found']
df
150/13: x[2]
150/14: average_effort = {'Average Effort': x[2]}
150/15:
average_effort = {'Average Effort': x[2]}
average_effort
150/16: df = pd.DataFrame(average_effort)
150/17: df = pd.DataFrame.from_dict(average_effort, orient='index', columns=['Value'])
150/18:
df = pd.DataFrame.from_dict(average_effort, orient='index', columns=['Value'])
df
150/19:
df = pd.DataFrame.from_dict(average_effort, orient='index', columns=['Value'])
df.reset_index(inplace=True)
df
150/20:
df = pd.DataFrame.from_dict(average_effort, orient='index', columns=['Average Effort'])
df.reset_index(inplace=True)
df
150/21:
df = pd.DataFrame.from_dict(average_effort, orient='index', columns=['Average Effort'])
# df.reset_index(inplace=True)
df
150/22:
df = pd.DataFrame.from_dict(average_effort, columns=['Average Effort'])
# df.reset_index(inplace=True)
df
150/23:
df = pd.DataFrame.from_dict(average_effort, orient='index', columns=['Average Effort'])
# df.reset_index(inplace=True)
df
151/1:
from utils.reader import SigmaWalletReader
import pandas as pd
reader = SigmaWalletReader(config_path="../conf")
151/2:
data = reader.run_app()
x, y, z = data
x, y, z
152/1:
from utils.reader import SigmaWalletReader
import pandas as pd
reader = SigmaWalletReader(config_path="../conf")
152/2:
data = reader.run_app()
x, y, z = data
x, y, z
152/3:
data = reader.run_app()
x, y, z = data
x
152/4: x
152/5: x.head()
152/6: x.head
152/7:
data = reader.run_app()
x, y, z = data
q, w, e = x
152/8: q
152/9: w
152/10: e
152/11:
data = reader.run_app()
x, y, z = data
y
152/12:
from utils.reader import SigmaWalletReader
import pandas as pd
reader = SigmaWalletReader(config_path="../conf")
153/1:
from utils.reader import SigmaWalletReader
import pandas as pd
reader = SigmaWalletReader(config_path="../conf")
153/2:
data = reader.run_app()
x, y, z = data
y
154/1:
from utils.reader import SigmaWalletReader
import pandas as pd
reader = SigmaWalletReader(config_path="../conf")
154/2:
data = reader.run_app()
x, y, z = data
y
155/1:
from utils.reader import SigmaWalletReader
import pandas as pd
reader = SigmaWalletReader(config_path="../conf")
155/2:
data = reader.run_app()
x, y, z = data
y
155/3:
data = reader.run_app()
x, y, z = data
z
155/4:
data = reader.run_app()
x, y, z = data
len(z)
155/5: x, y, z = z
155/6: z
155/7: x
155/8: y
155/9: z
155/10: x, y
155/11:
# x, y\

df1 = pd.DataFrame(list(x.items()), columns=['Key', 'Value'])
df2 = pd.DataFrame(list(y.items()), columns=['Key', 'Value'])

# Concatenate the two DataFrames
df_combined = pd.concat([df1, df2], ignore_index=True)

df_combined
155/12:
# x, y\

df1 = pd.DataFrame(list(x.items()), columns=['Key', 'Value'])
df2 = pd.DataFrame(list(y.items()), columns=['Key', 'Value'])

# Concatenate the two DataFrames
df_combined = pd.concat([df1, df2], ignore_index=True)
df_combined.columns = ['Pool Stats', 'Values')
df_combined
155/13:
# x, y\

df1 = pd.DataFrame(list(x.items()), columns=['Key', 'Value'])
df2 = pd.DataFrame(list(y.items()), columns=['Key', 'Value'])

# Concatenate the two DataFrames
df_combined = pd.concat([df1, df2], ignore_index=True)
df_combined.columns = ['Pool Stats', 'Values']
df_combined
155/14: z
155/15: pd.Dataframe(z)
155/16: pd.DataFrame(z)
156/1:
from utils.reader import SigmaWalletReader
import pandas as pd
reader = SigmaWalletReader(config_path="../conf")
156/2:
data = reader.run_app()
x, y, z = data
156/3: z[0]
156/4: z[1]
156/5: mining_data_df = reader.get_mining_stats()
156/6:
mining_data_df = reader.get_mining_stats()
mining_data_df
156/7:
mining_data_df = reader.get_mining_stats()
mining_data_df[:-1]
156/8:
mining_data_df = reader.get_mining_stats()
mining_data_df
156/9: mining_data_df[-1]
156/10: mining_data_df[-1:]
156/11: mining_data_df[-1:]['Values']
156/12: mining_data_df[-1:]['Values'].keys()
156/13: mining_data_df[-1:]['Values']
156/14: mining_data_df[-1:]['Values'][0]
156/15: mining_data_df[-1:]['Values']
156/16: mining_data_df[-1:]['Values'].values()
157/1:
from utils.reader import SigmaWalletReader
import pandas as pd
reader = SigmaWalletReader(config_path="../conf")
157/2:
mining_data_df = reader.get_mining_stats()
mining_data_df
158/1:
from utils.reader import SigmaWalletReader
import pandas as pd
reader = SigmaWalletReader(config_path="../conf")
158/2:
mining_data_df = reader.get_mining_stats()
mining_data_df
159/1:
from utils.reader import SigmaWalletReader
import pandas as pd
reader = SigmaWalletReader(config_path="../conf")
159/2:
mining_data_df = reader.get_mining_stats()
mining_data_df
160/1:
from utils.reader import SigmaWalletReader
import pandas as pd
reader = SigmaWalletReader(config_path="../conf")
160/2:
mining_data_df = reader.get_mining_stats()
mining_data_df
160/3:
mining_data_df = reader.get_mining_stats()
mining_data_df[1]
161/1:
from utils.reader import SigmaWalletReader
import pandas as pd
reader = SigmaWalletReader(config_path="../conf")
161/2:
mining_data_df = reader.get_mining_stats()
mining_data_df[1]
163/1:
from pycoingecko import CoinGeckoAPI
cg = CoinGeckoAPI()

# Fetch current price of Bitcoin (BTC) and Ergo (ERG) in USD
prices = cg.get_price(ids=['bitcoin', 'ergo'], vs_currencies='usd')

btc_price = prices['bitcoin']['usd']
erg_price = prices['ergo']['usd']

print(f"BTC Price: ${btc_price}")
print(f"ERG Price: ${erg_price}")
164/1:
from pycoingecko import CoinGeckoAPI
cg = CoinGeckoAPI()

# Fetch current price of Bitcoin (BTC) and Ergo (ERG) in USD
prices = cg.get_price(ids=['bitcoin', 'ergo'], vs_currencies='usd')

btc_price = prices['bitcoin']['usd']
erg_price = prices['ergo']['usd']

print(f"BTC Price: ${btc_price}")
print(f"ERG Price: ${erg_price}")
166/1:
from pycoingecko import CoinGeckoAPI
cg = CoinGeckoAPI()
166/2: cg.get_coins_list()
166/3: prices = cg.get_price(ids=['rosen-bridge', 'ergo'], vs_currencies='usd')
166/4: prices
166/5: prices = cg.get_price(ids=['rosen-bridge', 'ergo', 'spectrum-finance'], vs_currencies='usd')
166/6: prices
166/7: prices = cg.get_price(ids=['rosen-bridge', 'ergo', 'spectrum-finance'], vs_currencies='btc')
166/8: prices
166/9: prices = cg.get_price(ids=['rosen-bridge', 'ergo', 'spectrum-finance'], vs_currencies='erg')
166/10: prices
166/11: prices = cg.get_price(ids=['rosen-bridge', 'ergo', 'spectrum-finance'], vs_currencies='ergo')
166/12: prices
166/13: prices = cg.get_price(ids=['rosen-bridge', 'ergo', 'spectrum-finance'], vs_currencies='usd')
166/14: prices
166/15: df = DataFrame(prices)
166/16:
from pycoingecko import CoinGeckoAPI
from pandas import DataFrame
cg = CoinGeckoAPI()
166/17: prices = cg.get_price(ids=['rosen-bridge', 'ergo', 'spectrum-finance'], vs_currencies='usd')
166/18: df = DataFrame(prices)
166/19:
df = DataFrame(prices)
df
167/1: from polls.models import Choice, Question
167/2: Question.objects.all()
167/3: from django.utils import timezone
167/4: q = Question(question_text="What's new?", pub_date=timezone.now())
167/5: q.save()
167/6: q.id
167/7: q.question_text
167/8: q.pub_date
167/9: q.question_text = "What's up?"
167/10: q.save
167/11: q.save()
167/12: Question.objects.all()
168/1: from polls.models import Choice, Question
168/2: Question.objects.all()
168/3: Question.objects.filter(id=1)
168/4: Question.objects.filter(question_text__startswith="What")
168/5: current_year = timezone.now().year
168/6: from django.utils import timezone
168/7: current_year = timezone.now().year
168/8: Question.objects.get(pub_date__year=current_year)
168/9: Question.objects.get(pk=1)
168/10: q = Question.objects.get(pk=1)
168/11: q.was_published_recently()
168/12: q.choice_set.all()
168/13: q.choice_set.create(choice_text="Not much", votes=0)
168/14: q.choice_set.create(choice_text="The sky", votes=0)
168/15: c = q.choice_set.create(choice_text="Just hacking again", votes=0)
168/16: c.question
168/17: q.choice_set.all()
169/1: from reader import SigmaWalletReader
169/2: from ../reader import SigmaWalletReader
170/1: from reader import SigmaWalletReader
170/2: from utils.reader import SigmaWalletReader
169/3: from utils.reader import SigmaWalletReader
169/4: from utils.reader import SigmaWalletReader
169/5: from utils.reader import SigmaWalletReader
171/1: from utils.reader import SigmaWalletReader
171/2: 0+0
171/3: reader = SigmaWalletReader(config_path="../conf")
171/4: reader.get_api_data('http://15.204.211.130:4000/api/pools/ErgoSigmanauts/miners/')
171/5:
data = reader.get_api_data('http://15.204.211.130:4000/api/pools/ErgoSigmanauts/miners/')
data
171/6:
miners = {}
for sample in data:
    miner[sample['miner']: 0]
171/7:
miners = {}
for sample in data:
    miners[sample['miner']: 0]
171/8:
miners = {}
for sample in data:
    miners{sample['miner']: 0}
171/9:
miners = {}
for sample in data:
    miners[sample['miner'] = 0
171/10:
miners = {}
for sample in data:
    miners[sample['miner']] = 0
171/11:
miners = {}
for sample in data:
    miners[sample['miner']] = 0
miners
171/12:
miners = {}
for sample in data:
    miners[sample['miner']] = 0
for key in miners.keys():
    url = '{}/{}'.format('http://15.204.211.130:4000/api/pools/ErgoSigmanauts/miners', key)
    data = reader.get_api_data(url)
data
171/13:
miners = {}
for sample in data:
    miners[sample['miner']] = 0
for key in miners.keys():
    url = '{}/{}'.format('http://15.204.211.130:4000/api/pools/ErgoSigmanauts/miners', key)
    data = reader.get_api_data(url)
    miners[key] = data['pendingShares']
miners
171/14:
data = reader.get_api_data('http://15.204.211.130:4000/api/pools/ErgoSigmanauts/miners/')
data
171/15:
miners = {}
for sample in data:
    miners[sample['miner']] = 0
for key in miners.keys():
    url = '{}/{}'.format('http://15.204.211.130:4000/api/pools/ErgoSigmanauts/miners', key)
    sample = reader.get_api_data(url)
    miners[key] = sample['pendingShares']
miners
171/16:
# Total of all values
total = sum(miners.values())

# Assume a reward variable, say 10000 for this example
reward = 30

# Calculate the percentage for each key based on its value and then determine the reward based on this percentage
rewards = {key: (value / total) * reward for key, value in miners.items()}

rewards
171/17:
import pandas as pd
df = pd.DataFrame(rewards)
171/18:
import pandas as pd
df = pd.DataFrame.from_dict(rewards)
171/19:
import pandas as pd
df = pd.DataFrame.from_dict(rewards, orient='index')
171/20:
import pandas as pd
df = pd.DataFrame.from_dict(rewards, orient='index')
df
171/21:
import pandas as pd
df = pd.DataFrame.from_dict(rewards, orient='index', 'columns':['Miner', 'Reward'])
df
171/22:
import pandas as pd
df = pd.DataFrame.from_dict(rewards, orient='index', 'columns'= ['Miner', 'Reward'])
df
171/23:
import pandas as pd
df = pd.DataFrame.from_dict(rewards, orient='index', columns= ['Miner', 'Reward'])
df
171/24:
import pandas as pd
df = pd.DataFrame.from_dict(rewards,
                        columns= ['Miner', 'Reward'])
df
171/25:
import pandas as pd
df = pd.DataFrame.from_dict(rewards, orient='columns',
                        columns= ['Miner', 'Reward'])
df
171/26:
import pandas as pd
df = pd.DataFrame.from_dict(rewards, orient='index',
                        columns= ['Miner', 'Reward'])
df
171/27:
import pandas as pd
rewards_df = pd.DataFrame(list(rewards.items()), columns=['miner', 'reward'])
rewards_df
171/28:
url = 'http://15.204.211.130:4000/api/pools/ErgoSigmanauts/miners/9gwk97nY8Uc6kLcSYs4ueWttY5EKyfsrbiyVQWFdUaWvd4Xhqys'
data = reader.get_api_data('http://15.204.211.130:4000/api/pools/ErgoSigmanauts/miners/')
data
171/29:
url = 'http://15.204.211.130:4000/api/pools/ErgoSigmanauts/miners/9gwk97nY8Uc6kLcSYs4ueWttY5EKyfsrbiyVQWFdUaWvd4Xhqys'
data = reader.get_api_data(url)
data
171/30:
url = 'http://15.204.211.130:4000/api/pools/ErgoSigmanauts/miners/9gwk97nY8Uc6kLcSYs4ueWttY5EKyfsrbiyVQWFdUaWvd4Xhqys'
data = reader.get_api_data(url)
data['performance']
171/31:
url = 'http://15.204.211.130:4000/api/pools/ErgoSigmanauts/miners/9gwk97nY8Uc6kLcSYs4ueWttY5EKyfsrbiyVQWFdUaWvd4Xhqys'
data = reader.get_api_data(url)
data
171/32:
url = 'http://15.204.211.130:4000/api/pools/ErgoSigmanauts/miners/9gwk97nY8Uc6kLcSYs4ueWttY5EKyfsrbiyVQWFdUaWvd4Xhqys'
data = reader.get_api_data(url)
data['performanceSamples']
171/33:
url = 'http://15.204.211.130:4000/api/pools/ErgoSigmanauts/miners/9ehJZvPDgvCNNd2zTQHxnSpcCAtb1kHbEN1VAgeoRD5DPVApYkk'
data = reader.get_api_data(url)
data['performanceSamples']
171/34:
url = 'http://15.204.211.130:4000/api/pools/ErgoSigmanauts/miners/9ehJZvPDgvCNNd2zTQHxnSpcCAtb1kHbEN1VAgeoRD5DPVApYkk'
data = reader.get_api_data(url)
data['performanceSamples']
171/35: pd
171/36:
url = 'http://15.204.211.130:4000/api/pools/ErgoSigmanauts/miners/9ehJZvPDgvCNNd2zTQHxnSpcCAtb1kHbEN1VAgeoRD5DPVApYkk'
data = reader.get_api_data(url)
samples = data['performanceSamples']
samples
171/37: pd.DataFrame(samples)
171/38:
def convert_to_dataframe(data):
    # Initialize an empty list to hold the flattened data
    flattened_data = []
    
    # Iterate over each entry in the data
    for entry in data:
        created_time = entry['created']
        
        # Iterate over each worker in the 'workers' dictionary
        for worker_name, metrics in entry['workers'].items():
            # Create a flat dictionary for each worker
            flat_entry = {
                'created': created_time,
                'worker': worker_name,
                'hashrate': metrics['hashrate'],
                'sharesPerSecond': metrics['sharesPerSecond']
            }
            # Append the flat dictionary to the list
            flattened_data.append(flat_entry)
    
    # Convert the list of flat dictionaries to a DataFrame
    return pd.DataFrame(flattened_data)

# Create the DataFrame
df = convert_to_dataframe(samples)
df
171/39:
import plotly.express as px

fig = px.line(df, x='created', y='hashrate', color='worker', title='Hashrate Over Time for Each Worker')
fig.show()
173/1: from utils.reader import SigmaWalletReader
173/2: reader = SigmaWalletReader(config_path="../conf")
173/3:
data = reader.get_api_data('http://15.204.211.130:4000/api/pools/ErgoSigmanauts/miners/')
data
173/4:
miners = {}
for sample in data:
    miners[sample['miner']] = 0
for key in miners.keys():
    url = '{}/{}'.format('http://15.204.211.130:4000/api/pools/ErgoSigmanauts/miners', key)
    sample = reader.get_api_data(url)
    miners[key] = sample['pendingShares']
miners
173/5:
# Total of all values
total = sum(miners.values())

# Assume a reward variable, say 10000 for this example
reward = 30

# Calculate the percentage for each key based on its value and then determine the reward based on this percentage
rewards = {key: (value / total) * reward for key, value in miners.items()}

rewards
173/6:
import pandas as pd
rewards_df = pd.DataFrame(list(rewards.items()), columns=['miner', 'reward'])
rewards_df
173/7:
url = 'http://15.204.211.130:4000/api/pools/ErgoSigmanauts/miners/9ehJZvPDgvCNNd2zTQHxnSpcCAtb1kHbEN1VAgeoRD5DPVApYkk'
data = reader.get_api_data(url)
samples = data['performanceSamples']
samples
173/8: SigmaWalletReader.get_miner_samples('9ehJZvPDgvCNNd2zTQHxnSpcCAtb1kHbEN1VAgeoRD5DPVApYkk')
173/9: df = SigmaWalletReader.get_miner_samples('9ehJZvPDgvCNNd2zTQHxnSpcCAtb1kHbEN1VAgeoRD5DPVApYkk')
174/1: from utils.reader import SigmaWalletReader
174/2: reader = SigmaWalletReader(config_path="../conf")
174/3:
data = reader.get_api_data('http://15.204.211.130:4000/api/pools/ErgoSigmanauts/miners/')
data
174/4:
miners = {}
for sample in data:
    miners[sample['miner']] = 0
for key in miners.keys():
    url = '{}/{}'.format('http://15.204.211.130:4000/api/pools/ErgoSigmanauts/miners', key)
    sample = reader.get_api_data(url)
    miners[key] = sample['pendingShares']
miners
174/5:
# Total of all values
total = sum(miners.values())

# Assume a reward variable, say 10000 for this example
reward = 30

# Calculate the percentage for each key based on its value and then determine the reward based on this percentage
rewards = {key: (value / total) * reward for key, value in miners.items()}

rewards
174/6:
import pandas as pd
rewards_df = pd.DataFrame(list(rewards.items()), columns=['miner', 'reward'])
rewards_df
174/7:
url = 'http://15.204.211.130:4000/api/pools/ErgoSigmanauts/miners/9ehJZvPDgvCNNd2zTQHxnSpcCAtb1kHbEN1VAgeoRD5DPVApYkk'
data = reader.get_api_data(url)
samples = data['performanceSamples']
samples
174/8: df = SigmaWalletReader.get_miner_samples('9ehJZvPDgvCNNd2zTQHxnSpcCAtb1kHbEN1VAgeoRD5DPVApYkk')
176/1: from utils.reader import SigmaWalletReader
176/2: reader = SigmaWalletReader(config_path="../conf")
176/3:
data = reader.get_api_data('http://15.204.211.130:4000/api/pools/ErgoSigmanauts/miners/')
data
176/4:
miners = {}
for sample in data:
    miners[sample['miner']] = 0
for key in miners.keys():
    url = '{}/{}'.format('http://15.204.211.130:4000/api/pools/ErgoSigmanauts/miners', key)
    sample = reader.get_api_data(url)
    miners[key] = sample['pendingShares']
miners
176/5:
# Total of all values
total = sum(miners.values())

# Assume a reward variable, say 10000 for this example
reward = 30

# Calculate the percentage for each key based on its value and then determine the reward based on this percentage
rewards = {key: (value / total) * reward for key, value in miners.items()}

rewards
176/6:
import pandas as pd
rewards_df = pd.DataFrame(list(rewards.items()), columns=['miner', 'reward'])
rewards_df
176/7:
url = 'http://15.204.211.130:4000/api/pools/ErgoSigmanauts/miners/9ehJZvPDgvCNNd2zTQHxnSpcCAtb1kHbEN1VAgeoRD5DPVApYkk'
data = reader.get_api_data(url)
samples = data['performanceSamples']
samples
176/8: df = SigmaWalletReader.get_miner_samples(wallet='9ehJZvPDgvCNNd2zTQHxnSpcCAtb1kHbEN1VAgeoRD5DPVApYkk')
176/9: df = reader.get_miner_samples(wallet='9ehJZvPDgvCNNd2zTQHxnSpcCAtb1kHbEN1VAgeoRD5DPVApYkk')
177/1: from utils.reader import SigmaWalletReader
177/2: reader = SigmaWalletReader(config_path="../conf")
177/3:
data = reader.get_api_data('http://15.204.211.130:4000/api/pools/ErgoSigmanauts/miners/')
data
177/4:
miners = {}
for sample in data:
    miners[sample['miner']] = 0
for key in miners.keys():
    url = '{}/{}'.format('http://15.204.211.130:4000/api/pools/ErgoSigmanauts/miners', key)
    sample = reader.get_api_data(url)
    miners[key] = sample['pendingShares']
miners
177/5:
# Total of all values
total = sum(miners.values())

# Assume a reward variable, say 10000 for this example
reward = 30

# Calculate the percentage for each key based on its value and then determine the reward based on this percentage
rewards = {key: (value / total) * reward for key, value in miners.items()}

rewards
177/6:
import pandas as pd
rewards_df = pd.DataFrame(list(rewards.items()), columns=['miner', 'reward'])
rewards_df
177/7:
url = 'http://15.204.211.130:4000/api/pools/ErgoSigmanauts/miners/9ehJZvPDgvCNNd2zTQHxnSpcCAtb1kHbEN1VAgeoRD5DPVApYkk'
data = reader.get_api_data(url)
samples = data['performanceSamples']
samples
177/8: df = reader.get_miner_samples(wallet='9ehJZvPDgvCNNd2zTQHxnSpcCAtb1kHbEN1VAgeoRD5DPVApYkk')
178/1: from utils.reader import SigmaWalletReader
178/2: reader = SigmaWalletReader(config_path="../conf")
178/3:
data = reader.get_api_data('http://15.204.211.130:4000/api/pools/ErgoSigmanauts/miners/')
data
178/4:
miners = {}
for sample in data:
    miners[sample['miner']] = 0
for key in miners.keys():
    url = '{}/{}'.format('http://15.204.211.130:4000/api/pools/ErgoSigmanauts/miners', key)
    sample = reader.get_api_data(url)
    miners[key] = sample['pendingShares']
miners
178/5:
# Total of all values
total = sum(miners.values())

# Assume a reward variable, say 10000 for this example
reward = 30

# Calculate the percentage for each key based on its value and then determine the reward based on this percentage
rewards = {key: (value / total) * reward for key, value in miners.items()}

rewards
178/6:
import pandas as pd
rewards_df = pd.DataFrame(list(rewards.items()), columns=['miner', 'reward'])
rewards_df
178/7:
url = 'http://15.204.211.130:4000/api/pools/ErgoSigmanauts/miners/9ehJZvPDgvCNNd2zTQHxnSpcCAtb1kHbEN1VAgeoRD5DPVApYkk'
data = reader.get_api_data(url)
samples = data['performanceSamples']
samples
178/8: df = reader.get_miner_samples(wallet='9ehJZvPDgvCNNd2zTQHxnSpcCAtb1kHbEN1VAgeoRD5DPVApYkk')
178/9:
import plotly.express as px

fig = px.line(df, x='created', y='hashrate', color='worker', title='Hashrate Over Time for Each Worker')
fig.show()
178/10: df.empty
178/11: pd.DataFrame({'created': 0, 'hashrate': 0})
178/12: pd.DataFrame({'created': 0, 'hashrate': 0}, index=0)
178/13: pd.DataFrame({'created': 0, 'hashrate': 0}, index=1)
178/14: pd.DataFrame([0,0], columns=['a','b'])
178/15: pd.DataFrame([0,0], columns=['a','b'], index=1)
178/16:
d = {'a': 1, 
     'b': 2}
pd.DataFrame.from_dict(d)
178/17:
d = {'a': 1, 
     'b': 2}
pd.DataFrame.from_dict(d, index=1)
178/18:
d = {'a': 1, 
     'b': 2}
pd.DataFrame.from_dict(d, orient='index')
178/19:
d = {'a': 1, 
     'b': 2}
pd.DataFrame.from_dict(d, orient='columns')
178/20:
d = {'a': 1, 
     'b': 2}
pd.DataFrame.from_dict(d, orient='columns', columns=['a', 'b'])
178/21:
d = {'a': 1, 
     'b': 2}
pd.DataFrame.from_dict(d, columns=['a', 'b'])
178/22:
d = {'a': [1], 
     'b': [2]}
pd.DataFrame.from_dict(d)
178/23: import random
178/24: random.randint(0,1)
178/25: random.randint(0,5)
178/26: random.randrange(0,5)
178/27: random.randrange(0,5)
178/28: random.randrange(0,5)
178/29: random.randrange(0,5)
178/30:
import numpy as np
np.random.uniform(low=0.5, high=13.3, size=(50,))
178/31:
import numpy as np
np.random.uniform(low=0.3, high=5, size=(50,))
178/32:
import numpy as np
y = np.random.uniform(low=0.3, high=5, size=(50,))
x = [range(0, 50)]
178/33:
import numpy as np
y = np.random.uniform(low=0.3, high=5, size=(50,))
x = [range(0, 50)]
x, y
178/34:
import numpy as np
y = np.random.uniform(low=0.3, high=5, size=(50,))
x = [*range(0, 50)]
x, y
178/35:
import numpy as np
y = np.random.uniform(low=0.3, high=5, size=(50,))
x = [*range(0, 50)]

df = pd.DataFrame({'x': x, 'y':y})
df.plot()
178/36:
import numpy as np
y = np.random.uniform(low=0.3, high=5, size=(50,))
x = [*range(0, 50)]

df = pd.DataFrame({'x': x, 'y':y})
df.plot(x=x, y=y)
178/37:
import numpy as np
y = np.random.uniform(low=0.3, high=5, size=(50,))
x = [*range(0, 50)]

df = pd.DataFrame({'x': x, 'y':y})
df.plot(x=df.x, y=df.y)
178/38:
import numpy as np
y = np.random.uniform(low=0.3, high=5, size=(50,))
x = [*range(0, 50)]

df = pd.DataFrame({'x': x, 'y':y})
178/39:
import numpy as np
y = np.random.uniform(low=0.3, high=5, size=(50,))
x = [*range(0, 50)]

df = pd.DataFrame({'x': x, 'y':y})
df
178/40:
import numpy as np
y = np.random.uniform(low=0.3, high=5, size=(50,))
x = [*range(0, 50)]

df = pd.DataFrame({'x': x, 'y':y})
df.plot(y=df.y)
178/41:
import numpy as np
y = np.random.uniform(low=0.3, high=5, size=(50,))
x = [*range(0, 50)]

df = pd.DataFrame({'x': x, 'y':y})
df
178/42:
import numpy as np
import matplotlib.pyplot as plt
y = np.random.uniform(low=0.3, high=5, size=(50,))
x = [*range(0, 50)]

df = pd.DataFrame({'x': x, 'y':y})
plt.figure(figsize=(8, 6)) # You can adjust the figure size as needed
plt.plot(df['x'], df['y'], marker='o', linestyle='-', color='b') # marker, linestyle, and color are customizable
plt.title('Plot of x vs y') # Adds a title to your plot
plt.xlabel('x values') # Label for the x-axis
plt.ylabel('y values') # Label for the y-axis
plt.grid(True) # Adds a grid for better readability
plt.show() # Displays the plot
178/43:
import numpy as np
import matplotlib.pyplot as plt
y = np.random.uniform(low=0.3, high=5, size=(50,))
x = [*range(0, 50)]

df = pd.DataFrame({'x': x, 'y':y})
df['z'] = df['y'].cumsum() / df['y'].expanding().count()


plt.plot(df['x'], df['y'], label='y')
plt.plot(df['x'], df['z'], label='z')
plt.xlabel('x')
plt.ylabel('y and z')
plt.title('Plotting y and z over x')
plt.legend()
plt.show()
178/44:
import numpy as np
import matplotlib.pyplot as plt
y = np.random.uniform(low=0.001, high=5, size=(50,))
x = [*range(0, 50)]

df = pd.DataFrame({'x': x, 'y':y})
df['z'] = df['y'].cumsum() / df['y'].expanding().count()


plt.plot(df['x'], df['y'], label='y')
plt.plot(df['x'], df['z'], label='z')
plt.xlabel('x')
plt.ylabel('y and z')
plt.title('Plotting y and z over x')
plt.legend()
plt.show()
178/45:
import numpy as np
import matplotlib.pyplot as plt
y = np.random.uniform(low=0.001, high=5, size=(10000,))
x = [*range(0, 50)]

df = pd.DataFrame({'x': x, 'y':y})
df['z'] = df['y'].cumsum() / df['y'].expanding().count()


plt.plot(df['x'], df['y'], label='y')
plt.plot(df['x'], df['z'], label='z')
plt.xlabel('x')
plt.ylabel('y and z')
plt.title('Plotting y and z over x')
plt.legend()
plt.show()
178/46:
import numpy as np
import matplotlib.pyplot as plt
n = 100000
y = np.random.uniform(low=0.001, high=5, size=(n,))
x = [*range(0, n)]

df = pd.DataFrame({'x': x, 'y':y})
df['z'] = df['y'].cumsum() / df['y'].expanding().count()


plt.plot(df['x'], df['y'], label='y')
plt.plot(df['x'], df['z'], label='z')
plt.xlabel('x')
plt.ylabel('y and z')
plt.title('Plotting y and z over x')
plt.legend()
plt.show()
178/47:
import numpy as np
import matplotlib.pyplot as plt
n = 1000
y = np.random.uniform(low=0.001, high=5, size=(n,))
x = [*range(0, n)]

df = pd.DataFrame({'x': x, 'y':y})
df['z'] = df['y'].cumsum() / df['y'].expanding().count()


plt.plot(df['x'], df['y'], label='y')
plt.plot(df['x'], df['z'], label='z')
plt.xlabel('x')
plt.ylabel('y and z')
plt.title('Plotting y and z over x')
plt.legend()
plt.show()
178/48:
import numpy as np
import matplotlib.pyplot as plt
n = 1000
y = np.random.uniform(low=0.001, high=4, size=(n,))
x = [*range(0, n)]

df = pd.DataFrame({'x': x, 'y':y})
df['z'] = df['y'].cumsum() / df['y'].expanding().count()


plt.plot(df['x'], df['y'], label='y')
plt.plot(df['x'], df['z'], label='z')
plt.xlabel('x')
plt.ylabel('y and z')
plt.title('Plotting y and z over x')
plt.legend()
plt.show()
178/49:
import numpy as np
import matplotlib.pyplot as plt

import random

def generate_random_variable_list(n):
    random_variable_list = []
    for i in range(n):
        random_variable = random.uniform(0.001, 5)
        random_variable_list.append(random_variable)
    return random_variable_list

n = 1000 # number of random variables
y = generate_random_variable_list(n)
print(y)

x = [*range(0, n)]

df = pd.DataFrame({'x': x, 'y':y})
df['z'] = df['y'].cumsum() / df['y'].expanding().count()


plt.plot(df['x'], df['y'], label='y')
plt.plot(df['x'], df['z'], label='z')
plt.xlabel('x')
plt.ylabel('y and z')
plt.title('Plotting y and z over x')
plt.legend()
plt.show()
178/50:
import numpy as np
import matplotlib.pyplot as plt

import random

def generate_random_variable_list(n):
    random_variable_list = []
    for i in range(n):
        random_variable = random.uniform(0.001, 5)
        random_variable_list.append(random_variable)
    return random_variable_list

n = 1000 # number of random variables
y = generate_random_variable_list(n)

x = [*range(0, n)]

df = pd.DataFrame({'x': x, 'y':y})
df['z'] = df['y'].cumsum() / df['y'].expanding().count()


plt.plot(df['x'], df['y'], label='y')
plt.plot(df['x'], df['z'], label='z')
plt.xlabel('x')
plt.ylabel('y and z')
plt.title('Plotting y and z over x')
plt.legend()
plt.show()
178/51:
import numpy as np
import matplotlib.pyplot as plt

import random

def generate_random_variable_list(n):
    random_variable_list = []
    for i in range(n):
        random_variable = random.uniform(0.001, 5)
        random_variable_list.append(random_variable)
    return random_variable_list

n = 100 # number of random variables
y = generate_random_variable_list(n)

x = [*range(0, n)]

df = pd.DataFrame({'x': x, 'y':y})
df['z'] = df['y'].cumsum() / df['y'].expanding().count()


plt.plot(df['x'], df['y'], label='y')
plt.plot(df['x'], df['z'], label='z')
plt.xlabel('x')
plt.ylabel('y and z')
plt.title('Plotting y and z over x')
plt.legend()
plt.show()
178/52:
import numpy as np
import matplotlib.pyplot as plt

import random

def generate_random_variable_list(n):
    random_variable_list = []
    for i in range(n):
        random_variable = random.uniform(0.001, 5)
        random_variable_list.append(random_variable)
    return random_variable_list

n = 10 # number of random variables
y = generate_random_variable_list(n)

x = [*range(0, n)]

df = pd.DataFrame({'x': x, 'y':y})
df['z'] = df['y'].cumsum() / df['y'].expanding().count()


plt.plot(df['x'], df['y'], label='y')
plt.plot(df['x'], df['z'], label='z')
plt.xlabel('x')
plt.ylabel('y and z')
plt.title('Plotting y and z over x')
plt.legend()
plt.show()
178/53:
import numpy as np
import matplotlib.pyplot as plt

import random

def generate_random_variable_list(n):
    random_variable_list = []
    for i in range(n):
        random_variable = random.uniform(0.001, 5)
        random_variable_list.append(random_variable)
    return random_variable_list

n = 10 # number of random variables
y = generate_random_variable_list(n)

x = [*range(0, n)]

df = pd.DataFrame({'x': x, 'y':y})
df['z'] = df['y'].cumsum() / df['y'].expanding().count()


plt.plot(df['x'], df['y'], label='y')
plt.plot(df['x'], df['z'], label='z')
plt.xlabel('x')
plt.ylabel('y and z')
plt.title('Plotting y and z over x')
plt.legend()
plt.show()
180/1: from utils.reader import SigmaWalletReader
181/1: from utils.reader import SigmaWalletReader
181/2: reader = SigmaWalletReader(config_path="../conf")
181/3:
data = reader.get_api_data('http://15.204.211.130:4000/api/pools/ErgoSigmanauts/miners/')
data
181/4:
miners = {}
for sample in data:
    miners[sample['miner']] = 0
for key in miners.keys():
    url = '{}/{}'.format('http://15.204.211.130:4000/api/pools/ErgoSigmanauts/miners', key)
    sample = reader.get_api_data(url)
    miners[key] = sample['pendingShares']
miners
181/5:
# Total of all values
total = sum(miners.values())

# Assume a reward variable, say 10000 for this example
reward = 30

# Calculate the percentage for each key based on its value and then determine the reward based on this percentage
rewards = {key: (value / total) * reward for key, value in miners.items()}

rewards
181/6:
import pandas as pd
rewards_df = pd.DataFrame(list(rewards.items()), columns=['miner', 'reward'])
rewards_df
181/7:
url = 'http://15.204.211.130:4000/api/pools/ErgoSigmanauts/miners/9ehJZvPDgvCNNd2zTQHxnSpcCAtb1kHbEN1VAgeoRD5DPVApYkk'
data = reader.get_api_data(url)
samples = data['performanceSamples']
samples
181/8: df = reader.get_miner_samples(wallet='9ehJZvPDgvCNNd2zTQHxnSpcCAtb1kHbEN1VAgeoRD5DPVApYkk')
181/9: df.empty
181/10:
d = {'a': [1], 
     'b': [2]}
pd.DataFrame.from_dict(d)
181/11:
import plotly.express as px

fig = px.line(df, x='created', y='hashrate', color='worker', title='Hashrate Over Time for Each Worker')
fig.show()
181/12:
import numpy as np
import matplotlib.pyplot as plt

import random

def generate_random_variable_list(n):
    random_variable_list = []
    for i in range(n):
        random_variable = random.uniform(0.001, 5)
        random_variable_list.append(random_variable)
    return random_variable_list

n = 10 # number of random variables
y = generate_random_variable_list(n)

x = [*range(0, n)]

df = pd.DataFrame({'x': x, 'y':y})
df['z'] = df['y'].cumsum() / df['y'].expanding().count()


plt.plot(df['x'], df['y'], label='y')
plt.plot(df['x'], df['z'], label='z')
plt.xlabel('x')
plt.ylabel('y and z')
plt.title('Plotting y and z over x')
plt.legend()
plt.show()
181/13: random.randrange(0,5)
181/14:
url ='http://15.204.211.130:4000/api/pools/ErgoSigmanauts'

data = reader.get_api_data(url)
data
181/15:
url ='http://15.204.211.130:4000/api/pools/ErgoSigmanauts'

data = reader.get_api_data(url)
data.keys()
181/16:
url ='http://15.204.211.130:4000/api/pools/ErgoSigmanauts'

pool = reader.get_api_data(url)['pool']
data.keys()
181/17:
url ='http://15.204.211.130:4000/api/pools/ErgoSigmanauts'

pool = reader.get_api_data(url)['pool']
pool.keys()
181/18: pool['coin']
181/19: pool['paymentProcessing']
181/20: pool['clientConnectionTimeout']
181/21:
url ='http://15.204.211.130:4000/api/pools/ErgoSigmanauts'

pool = reader.get_api_data(url)['pool']
pool.keys()
181/22: pool['poolFeePercent']
181/23: pool['poolStats']
181/24: pool['paymentProcessing']
181/25: pool['jobRebroadcastTimeout']
181/26: pool['blockRefreshInterval']
181/27: pool['poolFeePercent']
181/28: pool['ports']
181/29: pool['address']
181/30: pool['addressInfoLink']
181/31: pool['poolStats']
181/32: pool['networkStats']
181/33: pool['topMiners'']
181/34: pool['topMiners']
181/35: pool['totalPaid']
181/36: pool['totalBlocks']
181/37: pool['lastPoolBlockTime']
181/38: pool['poolEffort']
181/39:
payment_data = pool['paymentProcessing']
pool_fee = pool['poolFeePercent']
port_data = pool['ports'] # likely just use the port number and if TLS is true or not and why to use or not
pool_stats = pool['poolStats']
net_stats = pool['networkStats']
total_paid = pool['totalPaid']
total_blocks = pool['totalBlocks']
last_block_found = pool['lastPoolBlockTime']
pool_effort = pool['poolEffort']
181/40: payment_data
181/41: payment_data.pop('enable')
181/42: del payment_data('enable')
181/43: del payment_data('enable')
181/44:
payment_data = pool['paymentProcessing']
pool_fee = pool['poolFeePercent']
port_data = pool['ports'] # likely just use the port number and if TLS is true or not and why to use or not
pool_stats = pool['poolStats']
net_stats = pool['networkStats']
total_paid = pool['totalPaid']
total_blocks = pool['totalBlocks']
last_block_found = pool['lastPoolBlockTime']
pool_effort = pool['poolEffort']
181/45: del payment_data('enable')
181/46: del payment_data['enable']
181/47: payment_data
181/48: del payment_data['enabled']
181/49:
del payment_data['enabled']
payment_data
181/50:
payment_data = pool['paymentProcessing']
pool_fee = pool['poolFeePercent']
port_data = pool['ports'] # likely just use the port number and if TLS is true or not and why to use or not
pool_stats = pool['poolStats']
net_stats = pool['networkStats']
total_paid = pool['totalPaid']
total_blocks = pool['totalBlocks']
last_block_found = pool['lastPoolBlockTime']
pool_effort = pool['poolEffort']
181/51: payment_data
181/52:
del payment_data['enabled']
payment_data
181/53:
payment_data = pool['paymentProcessing']
pool_fee = pool['poolFeePercent']
port_data = pool['ports'] # likely just use the port number and if TLS is true or not and why to use or not
pool_stats = pool['poolStats']
net_stats = pool['networkStats']
total_paid = pool['totalPaid']
total_blocks = pool['totalBlocks']
last_block_found = pool['lastPoolBlockTime']
pool_effort = pool['poolEffort']
181/54: payment_data
181/55:
del payment_data['enabled']
payment_data
181/56:
url ='http://15.204.211.130:4000/api/pools/ErgoSigmanauts'

pool = reader.get_api_data(url)['pool']
pool.keys()
181/57: pool['poolEffort']
181/58:
payment_data = pool['paymentProcessing']
pool_fee = pool['poolFeePercent']
port_data = pool['ports'] # likely just use the port number and if TLS is true or not and why to use or not
pool_stats = pool['poolStats']
net_stats = pool['networkStats']
total_paid = pool['totalPaid']
total_blocks = pool['totalBlocks']
last_block_found = pool['lastPoolBlockTime']
pool_effort = pool['poolEffort']
181/59: payment_data
181/60:
del payment_data['enabled']
payment_data
181/61:
url ='http://15.204.211.130:4000/api/pools/ErgoSigmanauts'

pool = reader.get_api_data(url)['pool']
pool.keys()
181/62: pool['poolEffort']
181/63:
url ='http://15.204.211.130:4000/api/pools/ErgoSigmanauts'

pool = reader.get_api_data(url)['pool']
pool.keys()
181/64:
url ='http://15.204.211.130:4000/api/pools/ErgoSigmanauts'

pool = reader.get_api_data(url)['pool']
pool.keys()
181/65:
url ='http://15.204.211.130:4000/api/pools/ErgoSigmanauts'

pool = reader.get_api_data(url)['pool']
pool.keys()
181/66: pool['poolEffort']
181/67:
payment_data = pool['paymentProcessing']
del payment_data['enabled']
del payment_data['payoutSchemeConfig']
del payment_data['extra']

pool_fee = pool['poolFeePercent']
port_data = pool['ports'] # likely just use the port number and if TLS is true or not and why to use or not
pool_stats = pool['poolStats']
net_stats = pool['networkStats']
total_paid = pool['totalPaid']
total_blocks = pool['totalBlocks']
last_block_found = pool['lastPoolBlockTime']
pool_effort = pool['poolEffort']
181/68: payment_data
181/69:
del payment_data['enabled']
payment_data
181/70: pool_fee
181/71: port_data
181/72:
modified_port_data = {}
for port in port_data:
    temp = port_data[port]
    modified_port_data[port] = tls
modified_port_data
181/73:
modified_port_data = {}
for port in port_data:
    temp = port_data[port]
    modified_port_data[port] = 'TLS: {}'.format(temp['tls'])
modified_port_data
181/74:
modified_port_data = {}
for port in port_data:
    temp = port_data[port]
    high_or_low
    if 'pikes_peak' in temp['name']:
        high_or_low = '>10GH/s'
    else:
        high_or_low = '<10GH/s
        
    modified_port_data[port] = '{} TLS: {}'.format(high_or_low, temp['tls'])
modified_port_data
181/75:
modified_port_data = {}
for port in port_data:
    temp = port_data[port]
    high_or_low
    if 'pikes_peak' in temp['name']:
        high_or_low = '>10GH/s'
    else:
        high_or_low = '<10GH/s'
        
    modified_port_data[port] = '{} TLS: {}'.format(high_or_low, temp['tls'])
modified_port_data
181/76:
modified_port_data = {}
for port in port_data:
    temp = port_data[port]
    if 'pikes_peak' in temp['name']:
        high_or_low = '>10GH/s'
    else:
        high_or_low = '<10GH/s'
        
    modified_port_data[port] = '{} TLS: {}'.format(high_or_low, temp['tls'])
modified_port_data
181/77:
ls = []
for port in port_data:
    temp = port_data[port]
    if 'pikes_peak' in temp['name']:
        high_or_low = 'Greater Than 10GH/s'
    else:
        high_or_low = 'Lower Than 10GH/s'
    ls.append(temp['name'], port, high_or_low, temp['tls'])
df = pd.DataFrame(ls, columns=['Name', 'Port', 'Hashrate Threshold', 'TLS')
df
181/78:
ls = []
for port in port_data:
    temp = port_data[port]
    if 'pikes_peak' in temp['name']:
        high_or_low = 'Greater Than 10GH/s'
    else:
        high_or_low = 'Lower Than 10GH/s'
    ls.append(temp['name'], port, high_or_low, temp['tls'])
df = pd.DataFrame(ls, columns=['Name', 'Port', 'Hashrate Threshold', 'TLS'))
df
181/79:
ls = []
for port in port_data:
    temp = port_data[port]
    if 'pikes_peak' in temp['name']:
        high_or_low = 'Greater Than 10GH/s'
    else:
        high_or_low = 'Lower Than 10GH/s'
    ls.append(temp['name'], port, high_or_low, temp['tls'])
df = pd.DataFrame(ls, columns=['Name', 'Port', 'Hashrate Threshold', 'TLS'])
df
181/80:
ls = []
for port in port_data:
    temp = port_data[port]
    if 'pikes_peak' in temp['name']:
        high_or_low = 'Greater Than 10GH/s'
    else:
        high_or_low = 'Lower Than 10GH/s'
    ls.append([temp['name'], port, high_or_low, temp['tls']])
df = pd.DataFrame(ls, columns=['Name', 'Port', 'Hashrate Threshold', 'TLS'])
df
181/81: pool_stats
181/82: net_stats
181/83: last_block_found
181/84: total_paid
181/85: total_blocks
181/86: import dash
181/87:  help(dash.html.Img)
182/1: from utils.reader import SigmaWalletReader
183/1: from utils.reader import SigmaWalletReader
183/2: reader = SigmaWalletReader(config_path="../conf")
183/3:
data = reader.get_api_data('http://15.204.211.130:4000/api/pools/ErgoSigmanauts/miners/')
data
183/4:
miners = {}
for sample in data:
    miners[sample['miner']] = 0
for key in miners.keys():
    url = '{}/{}'.format('http://15.204.211.130:4000/api/pools/ErgoSigmanauts/miners', key)
    sample = reader.get_api_data(url)
    miners[key] = sample['pendingShares']
miners
183/5:
# Total of all values
total = sum(miners.values())

# Assume a reward variable, say 10000 for this example
reward = 30

# Calculate the percentage for each key based on its value and then determine the reward based on this percentage
rewards = {key: (value / total) * reward for key, value in miners.items()}

rewards
183/6:
import pandas as pd
rewards_df = pd.DataFrame(list(rewards.items()), columns=['miner', 'reward'])
rewards_df
183/7:
url = 'http://15.204.211.130:4000/api/pools/ErgoSigmanauts/miners/9ehJZvPDgvCNNd2zTQHxnSpcCAtb1kHbEN1VAgeoRD5DPVApYkk'
data = reader.get_api_data(url)
samples = data['performanceSamples']
samples
183/8: df = reader.get_miner_samples(wallet='9ehJZvPDgvCNNd2zTQHxnSpcCAtb1kHbEN1VAgeoRD5DPVApYkk')
183/9: df.empty
183/10:
d = {'a': [1], 
     'b': [2]}
pd.DataFrame.from_dict(d)
183/11:
import plotly.express as px

fig = px.line(df, x='created', y='hashrate', color='worker', title='Hashrate Over Time for Each Worker')
fig.show()
183/12:
import numpy as np
import matplotlib.pyplot as plt

import random

def generate_random_variable_list(n):
    random_variable_list = []
    for i in range(n):
        random_variable = random.uniform(0.001, 5)
        random_variable_list.append(random_variable)
    return random_variable_list

n = 10 # number of random variables
y = generate_random_variable_list(n)

x = [*range(0, n)]

df = pd.DataFrame({'x': x, 'y':y})
df['z'] = df['y'].cumsum() / df['y'].expanding().count()


plt.plot(df['x'], df['y'], label='y')
plt.plot(df['x'], df['z'], label='z')
plt.xlabel('x')
plt.ylabel('y and z')
plt.title('Plotting y and z over x')
plt.legend()
plt.show()
183/13: random.randrange(0,5)
183/14:
url ='http://15.204.211.130:4000/api/pools/ErgoSigmanauts'

pool = reader.get_api_data(url)['pool']
pool.keys()
183/15: pool['poolEffort']
183/16:
payment_data = pool['paymentProcessing']
del payment_data['enabled']
del payment_data['payoutSchemeConfig']
del payment_data['extra']
183/17:
port_data = pool['ports']

ls = []
for port in port_data:
    temp = port_data[port]
    if 'pikes_peak' in temp['name']:
        high_or_low = 'Greater Than 10GH/s'
    else:
        high_or_low = 'Lower Than 10GH/s'
    ls.append([temp['name'], port, high_or_low, temp['tls']])
df = pd.DataFrame(ls, columns=['Name', 'Port', 'Hashrate Threshold', 'TLS'])
df
183/18:
pool_fee = pool['poolFeePercent']
pool_stats = pool['poolStats']
net_stats = pool['networkStats']
total_paid = pool['totalPaid']
total_blocks = pool['totalBlocks']
last_block_found = pool['lastPoolBlockTime']
pool_effort = pool['poolEffort']
183/19:
net_stats
del net_stats['connectedPeers']
del net_stats['rewardType']
del net_stats['networkType']
183/20: total_blocks
183/21: import dash
183/22:  help(dash.html.Img)
183/23: net_stats
183/24: payment_data
183/25: pool_stats
183/26: reader.get_front_page_data()
184/1: from utils.reader import SigmaWalletReader
184/2: reader = SigmaWalletReader(config_path="../conf")
184/3:
data = reader.get_api_data('http://15.204.211.130:4000/api/pools/ErgoSigmanauts/miners/')
data
184/4:
miners = {}
for sample in data:
    miners[sample['miner']] = 0
for key in miners.keys():
    url = '{}/{}'.format('http://15.204.211.130:4000/api/pools/ErgoSigmanauts/miners', key)
    sample = reader.get_api_data(url)
    miners[key] = sample['pendingShares']
miners
184/5:
# Total of all values
total = sum(miners.values())

# Assume a reward variable, say 10000 for this example
reward = 30

# Calculate the percentage for each key based on its value and then determine the reward based on this percentage
rewards = {key: (value / total) * reward for key, value in miners.items()}

rewards
184/6:
import pandas as pd
rewards_df = pd.DataFrame(list(rewards.items()), columns=['miner', 'reward'])
rewards_df
184/7:
url = 'http://15.204.211.130:4000/api/pools/ErgoSigmanauts/miners/9ehJZvPDgvCNNd2zTQHxnSpcCAtb1kHbEN1VAgeoRD5DPVApYkk'
data = reader.get_api_data(url)
samples = data['performanceSamples']
samples
184/8: df = reader.get_miner_samples(wallet='9ehJZvPDgvCNNd2zTQHxnSpcCAtb1kHbEN1VAgeoRD5DPVApYkk')
184/9: df.empty
184/10:
d = {'a': [1], 
     'b': [2]}
pd.DataFrame.from_dict(d)
184/11:
import plotly.express as px

fig = px.line(df, x='created', y='hashrate', color='worker', title='Hashrate Over Time for Each Worker')
fig.show()
184/12:
import numpy as np
import matplotlib.pyplot as plt

import random

def generate_random_variable_list(n):
    random_variable_list = []
    for i in range(n):
        random_variable = random.uniform(0.001, 5)
        random_variable_list.append(random_variable)
    return random_variable_list

n = 10 # number of random variables
y = generate_random_variable_list(n)

x = [*range(0, n)]

df = pd.DataFrame({'x': x, 'y':y})
df['z'] = df['y'].cumsum() / df['y'].expanding().count()


plt.plot(df['x'], df['y'], label='y')
plt.plot(df['x'], df['z'], label='z')
plt.xlabel('x')
plt.ylabel('y and z')
plt.title('Plotting y and z over x')
plt.legend()
plt.show()
184/13: random.randrange(0,5)
184/14:
url ='http://15.204.211.130:4000/api/pools/ErgoSigmanauts'

pool = reader.get_api_data(url)['pool']
pool.keys()
184/15: pool['poolEffort']
184/16:
payment_data = pool['paymentProcessing']
del payment_data['enabled']
del payment_data['payoutSchemeConfig']
del payment_data['extra']
184/17: payment_data
184/18:
port_data = pool['ports']

ls = []
for port in port_data:
    temp = port_data[port]
    if 'pikes_peak' in temp['name']:
        high_or_low = 'Greater Than 10GH/s'
    else:
        high_or_low = 'Lower Than 10GH/s'
    ls.append([temp['name'], port, high_or_low, temp['tls']])
df = pd.DataFrame(ls, columns=['Name', 'Port', 'Hashrate Threshold', 'TLS'])
df
184/19:
pool_fee = pool['poolFeePercent']
pool_stats = pool['poolStats']
net_stats = pool['networkStats']
total_paid = pool['totalPaid']
total_blocks = pool['totalBlocks']
last_block_found = pool['lastPoolBlockTime']
pool_effort = pool['poolEffort']
184/20:
net_stats
del net_stats['connectedPeers']
del net_stats['rewardType']
del net_stats['networkType']
184/21: pool_stats
184/22: import dash
184/23: reader.get_front_page_data()
185/1: from utils.reader import SigmaWalletReader
185/2: reader = SigmaWalletReader(config_path="../conf")
185/3:
data = reader.get_api_data('http://15.204.211.130:4000/api/pools/ErgoSigmanauts/miners/')
data
185/4:
miners = {}
for sample in data:
    miners[sample['miner']] = 0
for key in miners.keys():
    url = '{}/{}'.format('http://15.204.211.130:4000/api/pools/ErgoSigmanauts/miners', key)
    sample = reader.get_api_data(url)
    miners[key] = sample['pendingShares']
miners
185/5:
# Total of all values
total = sum(miners.values())

# Assume a reward variable, say 10000 for this example
reward = 30

# Calculate the percentage for each key based on its value and then determine the reward based on this percentage
rewards = {key: (value / total) * reward for key, value in miners.items()}

rewards
185/6:
import pandas as pd
rewards_df = pd.DataFrame(list(rewards.items()), columns=['miner', 'reward'])
rewards_df
185/7:
url = 'http://15.204.211.130:4000/api/pools/ErgoSigmanauts/miners/9ehJZvPDgvCNNd2zTQHxnSpcCAtb1kHbEN1VAgeoRD5DPVApYkk'
data = reader.get_api_data(url)
samples = data['performanceSamples']
samples
185/8: df = reader.get_miner_samples(wallet='9ehJZvPDgvCNNd2zTQHxnSpcCAtb1kHbEN1VAgeoRD5DPVApYkk')
185/9: df.empty
185/10:
d = {'a': [1], 
     'b': [2]}
pd.DataFrame.from_dict(d)
185/11:
import plotly.express as px

fig = px.line(df, x='created', y='hashrate', color='worker', title='Hashrate Over Time for Each Worker')
fig.show()
185/12:
import numpy as np
import matplotlib.pyplot as plt

import random

def generate_random_variable_list(n):
    random_variable_list = []
    for i in range(n):
        random_variable = random.uniform(0.001, 5)
        random_variable_list.append(random_variable)
    return random_variable_list

n = 10 # number of random variables
y = generate_random_variable_list(n)

x = [*range(0, n)]

df = pd.DataFrame({'x': x, 'y':y})
df['z'] = df['y'].cumsum() / df['y'].expanding().count()


plt.plot(df['x'], df['y'], label='y')
plt.plot(df['x'], df['z'], label='z')
plt.xlabel('x')
plt.ylabel('y and z')
plt.title('Plotting y and z over x')
plt.legend()
plt.show()
185/13: random.randrange(0,5)
185/14:
url ='http://15.204.211.130:4000/api/pools/ErgoSigmanauts'

pool = reader.get_api_data(url)['pool']
pool.keys()
185/15: pool['poolEffort']
185/16:
payment_data = pool['paymentProcessing']
del payment_data['enabled']
del payment_data['payoutSchemeConfig']
del payment_data['extra']
185/17: payment_data
185/18:
port_data = pool['ports']

ls = []
for port in port_data:
    temp = port_data[port]
    if 'pikes_peak' in temp['name']:
        high_or_low = 'Greater Than 10GH/s'
    else:
        high_or_low = 'Lower Than 10GH/s'
    ls.append([temp['name'], port, high_or_low, temp['tls']])
df = pd.DataFrame(ls, columns=['Name', 'Port', 'Hashrate Threshold', 'TLS'])
df
185/19:
pool_fee = pool['poolFeePercent']
pool_stats = pool['poolStats']
net_stats = pool['networkStats']
total_paid = pool['totalPaid']
total_blocks = pool['totalBlocks']
last_block_found = pool['lastPoolBlockTime']
pool_effort = pool['poolEffort']
185/20:
net_stats
del net_stats['connectedPeers']
del net_stats['rewardType']
del net_stats['networkType']
185/21: pool_stats
185/22: import dash
185/23: reader.get_front_page_data()
185/24: data = reader.get_front_page_data()
185/25: data['poolHashrate'] = data['poolHashrate'] / 1e16
185/26:
data['poolHashrate'] = data['poolHashrate'] / 1e16
data['poolHashrate']
185/27: data = reader.get_front_page_data()
185/28:
data['poolHashrate'] = data['poolHashrate'] / 1e6
data['poolHashrate']
185/29: data = reader.get_front_page_data()
185/30:
data['poolHashrate'] = data['poolHashrate'] / 1e9
data['poolHashrate']
185/31: data
185/32: last_block_found
185/33:
from datetime import datetime

format_string = '%Y-%m-%dT%H:%M:%S.%fZ'

date_time_obj = datetime.strptime(last_block_found, format_string)
readable_format = date_time_obj.strftime('%A, %B %d, %Y at %I:%M:%S %p')

print(f"The converted date and time is: {readable_format}")
185/34: readable_format
185/35:
from datetime import datetime

format_string = '%Y-%m-%dT%H:%M:%S.%fZ'
l = data['lastNetworkBlockTime']
date_time_obj = datetime.strptime(l, format_string)
readable_format = date_time_obj.strftime('%A, %B %d, %Y at %I:%M:%S %p')

print(f"The converted date and time is: {readable_format}")
185/36:
from datetime import datetime

format_string =  '%Y-%m-%dT%H:%M:%S.%fZ'
l = data['lastNetworkBlockTime']
date_time_obj = datetime.strptime(l, format_string)
readable_format = date_time_obj.strftime('%A, %B %d, %Y at %I:%M:%S %p')

print(f"The converted date and time is: {readable_format}")
185/37:
from datetime import datetime

input_string = data['lastNetworkBlockTime']
format_string = '%Y-%m-%dT%H:%M:%S.%fZ'

date_time_obj = datetime.strptime(input_string, format_string)
readable_format = date_time_obj.strftime('%A, %B %d, %Y at %I:%M:%S %p')

print(f"The converted date and time is: {readable_format}")
185/38:
from datetime import datetime

input_string = data['lastNetworkBlockTime']
format_string = '%Y-%m-%dT%H:%M:%S.%fZ'

date_time_obj = datetime.strptime(input_string, format_string)
readable_format = date_time_obj.strftime('%A, %B %d, %Y at %I:%M:%S %p')


print(f"The converted date and time is: {readable_format}")
187/1: from utils.reader import SigmaWalletReader
187/2: reader = SigmaWalletReader(config_path="../conf")
187/3:
data = reader.get_api_data('http://15.204.211.130:4000/api/pools/ErgoSigmanauts/miners/')
data
187/4:
miners = {}
for sample in data:
    miners[sample['miner']] = 0
for key in miners.keys():
    url = '{}/{}'.format('http://15.204.211.130:4000/api/pools/ErgoSigmanauts/miners', key)
    sample = reader.get_api_data(url)
    miners[key] = sample['pendingShares']
miners
187/5:
# Total of all values
total = sum(miners.values())

# Assume a reward variable, say 10000 for this example
reward = 30

# Calculate the percentage for each key based on its value and then determine the reward based on this percentage
rewards = {key: (value / total) * reward for key, value in miners.items()}

rewards
187/6:
import pandas as pd
rewards_df = pd.DataFrame(list(rewards.items()), columns=['miner', 'reward'])
rewards_df
187/7:
url = 'http://15.204.211.130:4000/api/pools/ErgoSigmanauts/miners/9ehJZvPDgvCNNd2zTQHxnSpcCAtb1kHbEN1VAgeoRD5DPVApYkk'
data = reader.get_api_data(url)
samples = data['performanceSamples']
samples
187/8: df = reader.get_miner_samples(wallet='9ehJZvPDgvCNNd2zTQHxnSpcCAtb1kHbEN1VAgeoRD5DPVApYkk')
187/9: df.empty
187/10:
d = {'a': [1], 
     'b': [2]}
pd.DataFrame.from_dict(d)
187/11:
import plotly.express as px

fig = px.line(df, x='created', y='hashrate', color='worker', title='Hashrate Over Time for Each Worker')
fig.show()
187/12:
import numpy as np
import matplotlib.pyplot as plt

import random

def generate_random_variable_list(n):
    random_variable_list = []
    for i in range(n):
        random_variable = random.uniform(0.001, 5)
        random_variable_list.append(random_variable)
    return random_variable_list

n = 10 # number of random variables
y = generate_random_variable_list(n)

x = [*range(0, n)]

df = pd.DataFrame({'x': x, 'y':y})
df['z'] = df['y'].cumsum() / df['y'].expanding().count()


plt.plot(df['x'], df['y'], label='y')
plt.plot(df['x'], df['z'], label='z')
plt.xlabel('Blocks Found')
plt.ylabel('y and z')
plt.title('Y - Effort, Z - Effort Feeback Response')
plt.legend()
plt.show()
187/13: random.randrange(0,5)
187/14:
url ='http://15.204.211.130:4000/api/pools/ErgoSigmanauts'

pool = reader.get_api_data(url)['pool']
pool.keys()
187/15: pool['poolEffort']
187/16:
payment_data = pool['paymentProcessing']
del payment_data['enabled']
del payment_data['payoutSchemeConfig']
del payment_data['extra']
187/17: payment_data
187/18:
port_data = pool['ports']

ls = []
for port in port_data:
    temp = port_data[port]
    if 'pikes_peak' in temp['name']:
        high_or_low = 'Greater Than 10GH/s'
    else:
        high_or_low = 'Lower Than 10GH/s'
    ls.append([temp['name'], port, high_or_low, temp['tls']])
df = pd.DataFrame(ls, columns=['Name', 'Port', 'Hashrate Threshold', 'TLS'])
df
187/19:
pool_fee = pool['poolFeePercent']
pool_stats = pool['poolStats']
net_stats = pool['networkStats']
total_paid = pool['totalPaid']
total_blocks = pool['totalBlocks']
last_block_found = pool['lastPoolBlockTime']
pool_effort = pool['poolEffort']
187/20:
net_stats
del net_stats['connectedPeers']
del net_stats['rewardType']
del net_stats['networkType']
187/21: pool_stats
187/22: import dash
187/23: data = reader.get_front_page_data()
187/24: from utils.reader import SigmaWalletReader
187/25: reader = SigmaWalletReader(config_path="../conf")
187/26:
data = reader.get_api_data('http://15.204.211.130:4000/api/pools/ErgoSigmanauts/miners/')
data
188/1: from utils.reader import SigmaWalletReader
188/2: reader = SigmaWalletReader(config_path="../conf")
188/3:
data = reader.get_api_data('http://15.204.211.130:4000/api/pools/ErgoSigmanauts/miners/')
data
188/4:
miner_ls = []
for sample in data:
    miner_ls.append(sample['miner'])


miner_ls
190/1: from utils.reader import SigmaWalletReader
190/2: reader = SigmaWalletReader(config_path="../conf")
190/3:
data = reader.get_api_data('http://15.204.211.130:4000/api/pools/ErgoSigmanauts/miners/')
data
190/4:
miner_ls = []
for sample in data:
    miner_ls.append(sample['miner'])


miner_ls
190/5:
miners = {}
for sample in data:
    miners[sample['miner']] = 0
for key in miners.keys():
    url = '{}/{}'.format('http://15.204.211.130:4000/api/pools/ErgoSigmanauts/miners', key)
    sample = reader.get_api_data(url)
    miners[key] = sample['pendingShares']
miners
190/6:
# Total of all values
total = sum(miners.values())

# Assume a reward variable, say 10000 for this example
reward = 30

# Calculate the percentage for each key based on its value and then determine the reward based on this percentage
rewards = {key: (value / total) * reward for key, value in miners.items()}

rewards
190/7:
import pandas as pd
rewards_df = pd.DataFrame(list(rewards.items()), columns=['miner', 'reward'])
rewards_df
190/8:
url = 'http://15.204.211.130:4000/api/pools/ErgoSigmanauts/miners/9ehJZvPDgvCNNd2zTQHxnSpcCAtb1kHbEN1VAgeoRD5DPVApYkk'
data = reader.get_api_data(url)
samples = data['performanceSamples']
samples
190/9: df = reader.get_miner_samples(wallet='9ehJZvPDgvCNNd2zTQHxnSpcCAtb1kHbEN1VAgeoRD5DPVApYkk')
190/10: df.empty
190/11:
d = {'a': [1], 
     'b': [2]}
pd.DataFrame.from_dict(d)
190/12:
import plotly.express as px

fig = px.line(df, x='created', y='hashrate', color='worker', title='Hashrate Over Time for Each Worker')
fig.show()
190/13:
import numpy as np
import matplotlib.pyplot as plt

import random

def generate_random_variable_list(n):
    random_variable_list = []
    for i in range(n):
        random_variable = random.uniform(0.001, 5)
        random_variable_list.append(random_variable)
    return random_variable_list

n = 10 # number of random variables
y = generate_random_variable_list(n)

x = [*range(0, n)]

df = pd.DataFrame({'x': x, 'y':y})
df['z'] = df['y'].cumsum() / df['y'].expanding().count()


plt.plot(df['x'], df['y'], label='y')
plt.plot(df['x'], df['z'], label='z')
plt.xlabel('x')
plt.ylabel('y and z')
plt.title('Plotting y and z over x')
plt.legend()
plt.show()
190/14: random.randrange(0,5)
190/15:
url ='http://15.204.211.130:4000/api/pools/ErgoSigmanauts'

pool = reader.get_api_data(url)['pool']
pool.keys()
190/16: pool['poolEffort']
190/17:
payment_data = pool['paymentProcessing']
del payment_data['enabled']
del payment_data['payoutSchemeConfig']
del payment_data['extra']
190/18: payment_data
190/19:
port_data = pool['ports']

ls = []
for port in port_data:
    temp = port_data[port]
    if 'pikes_peak' in temp['name']:
        high_or_low = 'Greater Than 10GH/s'
    else:
        high_or_low = 'Lower Than 10GH/s'
    ls.append([temp['name'], port, high_or_low, temp['tls']])
df = pd.DataFrame(ls, columns=['Name', 'Port', 'Hashrate Threshold', 'TLS'])
df
190/20:
pool_fee = pool['poolFeePercent']
pool_stats = pool['poolStats']
net_stats = pool['networkStats']
total_paid = pool['totalPaid']
total_blocks = pool['totalBlocks']
last_block_found = pool['lastPoolBlockTime']
pool_effort = pool['poolEffort']
190/21:
net_stats
del net_stats['connectedPeers']
del net_stats['rewardType']
del net_stats['networkType']
190/22: pool_stats
190/23: import dash
190/24: data = reader.get_front_page_data()
190/25:
data['poolHashrate'] = data['poolHashrate'] / 1e9 #GIGA
data['poolHashrate']
190/26: data
190/27: last_block_found
190/28:
from datetime import datetime

input_string = data['lastNetworkBlockTime']
format_string = '%Y-%m-%dT%H:%M:%S.%fZ'

date_time_obj = datetime.strptime(input_string, format_string)
readable_format = date_time_obj.strftime('%A, %B %d, %Y at %I:%M:%S %p')


print(f"The converted date and time is: {readable_format}")
190/29: df
190/30:
import numpy as np
import matplotlib.pyplot as plt

import random

def generate_random_variable_list(n):
    random_variable_list = []
    for i in range(n):
        random_variable = random.uniform(0.001, 5)
        random_variable_list.append(random_variable)
    return random_variable_list

n = 10 # number of random variables
y = generate_random_variable_list(n)

x = [*range(0, n)]

df = pd.DataFrame({'x': x, 'y':y})
df['z'] = df['y'].cumsum() / df['y'].expanding().count()


plt.plot(df['x'], df['y'], label='y')
plt.plot(df['x'], df['z'], label='z')
plt.xlabel('x')
plt.ylabel('y and z')
plt.title('Plotting y and z over x')
plt.legend()
plt.show()
190/31: df
190/32:
df.melt(id_vars=['x', 'y'])
df
190/33:
df.melt(id_vars=['x', 'y'], values=['x', 'y'])
df
190/34:
df.melt(id_vars=['x', 'y'], value=['x', 'y'])
df
190/35:
df.melt(id_vars=['x', 'y'], value_vars=['x', 'y'])
df
190/36: df.melt(id_vars=['x', 'y'], value_vars=['x', 'y'])
190/37:
n = df.melt(id_vars=['x', 'y'], value_vars=['x', 'y'])
n
190/38:
n = df.melt(id_vars=['x', 'y'])
n
190/39:
n = df.melt(id_vars=['z', 'y'])
n
190/40:
n = df.melt(id_vars=['x'])
n
190/41:
import numpy as np
import matplotlib.pyplot as plt

import random

def generate_random_variable_list(n):
    random_variable_list = []
    for i in range(n):
        random_variable = random.uniform(0.001, 5)
        random_variable_list.append(random_variable)
    return random_variable_list

n = 10 # number of random variables
y = generate_random_variable_list(n)

x = [*range(0, n)]

df = pd.DataFrame({'x': x, 'y':y})
df['z'] = df['y'].expanding().count()


plt.plot(df['x'], df['y'], label='y')
plt.plot(df['x'], df['z'], label='z')
plt.xlabel('x')
plt.ylabel('y and z')
plt.title('Plotting y and z over x')
plt.legend()
plt.show()
190/42: df
190/43:
import numpy as np
import matplotlib.pyplot as plt

import random

def generate_random_variable_list(n):
    random_variable_list = []
    for i in range(n):
        random_variable = random.uniform(0.001, 5)
        random_variable_list.append(random_variable)
    return random_variable_list

n = 10 # number of random variables
y = generate_random_variable_list(n)

x = [*range(0, n)]

df = pd.DataFrame({'x': x, 'y':y})
df['z'] = df['y'].expanding().mean()


plt.plot(df['x'], df['y'], label='y')
plt.plot(df['x'], df['z'], label='z')
plt.xlabel('x')
plt.ylabel('y and z')
plt.title('Plotting y and z over x')
plt.legend()
plt.show()
190/44:
import numpy as np
import matplotlib.pyplot as plt

import random

def generate_random_variable_list(n):
    random_variable_list = []
    for i in range(n):
        random_variable = random.uniform(0.001, 5)
        random_variable_list.append(random_variable)
    return random_variable_list

n = 10 # number of random variables
y = generate_random_variable_list(n)

x = [*range(0, n)]

df = pd.DataFrame({'x': x, 'y':y})
df['z'] = df['y'].expanding().mean()


plt.plot(df['x'], df['y'], label='y')
plt.plot(df['x'], df['z'], label='z')
plt.xlabel('x')
plt.ylabel('y and z')
plt.title('Plotting y and z over x')
plt.legend()
plt.show()
192/1: from utils.reader import SigmaWalletReader
193/1: from utils.reader import SigmaWalletReader
193/2: reader = SigmaWalletReader(config_path="../conf")
193/3:
data = reader.get_api_data('http://15.204.211.130:4000/api/pools/ErgoSigmanauts/miners/')
data
193/4:
miner_ls = []
for sample in data:
    miner_ls.append(sample['miner'])


miner_ls
193/5:
miners = {}
for sample in data:
    miners[sample['miner']] = 0
for key in miners.keys():
    url = '{}/{}'.format('http://15.204.211.130:4000/api/pools/ErgoSigmanauts/miners', key)
    sample = reader.get_api_data(url)
    miners[key] = sample['pendingShares']
miners
193/6:
# Total of all values
total = sum(miners.values())

# Assume a reward variable, say 10000 for this example
reward = 30

# Calculate the percentage for each key based on its value and then determine the reward based on this percentage
rewards = {key: (value / total) * reward for key, value in miners.items()}

rewards
193/7:
import pandas as pd
rewards_df = pd.DataFrame(list(rewards.items()), columns=['miner', 'reward'])
rewards_df
193/8:
url = 'http://15.204.211.130:4000/api/pools/ErgoSigmanauts/miners/9ehJZvPDgvCNNd2zTQHxnSpcCAtb1kHbEN1VAgeoRD5DPVApYkk'
data = reader.get_api_data(url)
samples = data['performanceSamples']
samples
193/9: df = reader.get_miner_samples(wallet='9ehJZvPDgvCNNd2zTQHxnSpcCAtb1kHbEN1VAgeoRD5DPVApYkk')
193/10: df.empty
193/11:
d = {'a': [1], 
     'b': [2]}
pd.DataFrame.from_dict(d)
193/12:
import plotly.express as px

fig = px.line(df, x='created', y='hashrate', color='worker', title='Hashrate Over Time for Each Worker')
fig.show()
193/13:
import numpy as np
import matplotlib.pyplot as plt

import random

def generate_random_variable_list(n):
    random_variable_list = []
    for i in range(n):
        random_variable = random.uniform(0.001, 5)
        random_variable_list.append(random_variable)
    return random_variable_list

n = 10 # number of random variables
y = generate_random_variable_list(n)

x = [*range(0, n)]

df = pd.DataFrame({'x': x, 'y':y})
df['z'] = df['y'].expanding().mean()


plt.plot(df['x'], df['y'], label='y')
plt.plot(df['x'], df['z'], label='z')
plt.xlabel('x')
plt.ylabel('y and z')
plt.title('Plotting y and z over x')
plt.legend()
plt.show()
193/14: df
193/15: df
193/16:
n = df.melt(id_vars=['x'])
n
193/17: random.randrange(0,5)
193/18:
url ='http://15.204.211.130:4000/api/pools/ErgoSigmanauts'

pool = reader.get_api_data(url)['pool']
pool.keys()
193/19: pool['poolEffort']
193/20:
payment_data = pool['paymentProcessing']
del payment_data['enabled']
del payment_data['payoutSchemeConfig']
del payment_data['extra']
193/21: payment_data
193/22:
port_data = pool['ports']

ls = []
for port in port_data:
    temp = port_data[port]
    if 'pikes_peak' in temp['name']:
        high_or_low = 'Greater Than 10GH/s'
    else:
        high_or_low = 'Lower Than 10GH/s'
    ls.append([temp['name'], port, high_or_low, temp['tls']])
df = pd.DataFrame(ls, columns=['Name', 'Port', 'Hashrate Threshold', 'TLS'])
df
193/23:
pool_fee = pool['poolFeePercent']
pool_stats = pool['poolStats']
net_stats = pool['networkStats']
total_paid = pool['totalPaid']
total_blocks = pool['totalBlocks']
last_block_found = pool['lastPoolBlockTime']
pool_effort = pool['poolEffort']
193/24:
net_stats
del net_stats['connectedPeers']
del net_stats['rewardType']
del net_stats['networkType']
193/25: pool_stats
193/26: import dash
193/27: data = reader.get_front_page_data()
193/28:
data['poolHashrate'] = data['poolHashrate'] / 1e9 #GIGA
data['poolHashrate']
193/29: data
193/30: last_block_found
193/31:
from datetime import datetime

input_string = data['lastNetworkBlockTime']
format_string = '%Y-%m-%dT%H:%M:%S.%fZ'

date_time_obj = datetime.strptime(input_string, format_string)
readable_format = date_time_obj.strftime('%A, %B %d, %Y at %I:%M:%S %p')


print(f"The converted date and time is: {readable_format}")
193/32: df = reader.get_all_miner_data()
193/33:
df = reader.get_all_miner_data()
df
194/1: from utils.reader import SigmaWalletReader
194/2: reader = SigmaWalletReader(config_path="../conf")
194/3:
data = reader.get_api_data('http://15.204.211.130:4000/api/pools/ErgoSigmanauts/miners/')
data
194/4:
miner_ls = []
for sample in data:
    miner_ls.append(sample['miner'])


miner_ls
194/5:
miners = {}
for sample in data:
    miners[sample['miner']] = 0
for key in miners.keys():
    url = '{}/{}'.format('http://15.204.211.130:4000/api/pools/ErgoSigmanauts/miners', key)
    sample = reader.get_api_data(url)
    miners[key] = sample['pendingShares']
miners
194/6:
# Total of all values
total = sum(miners.values())

# Assume a reward variable, say 10000 for this example
reward = 30

# Calculate the percentage for each key based on its value and then determine the reward based on this percentage
rewards = {key: (value / total) * reward for key, value in miners.items()}

rewards
194/7:
import pandas as pd
rewards_df = pd.DataFrame(list(rewards.items()), columns=['miner', 'reward'])
rewards_df
194/8:
url = 'http://15.204.211.130:4000/api/pools/ErgoSigmanauts/miners/9ehJZvPDgvCNNd2zTQHxnSpcCAtb1kHbEN1VAgeoRD5DPVApYkk'
data = reader.get_api_data(url)
samples = data['performanceSamples']
samples
194/9: df = reader.get_miner_samples(wallet='9ehJZvPDgvCNNd2zTQHxnSpcCAtb1kHbEN1VAgeoRD5DPVApYkk')
194/10: df.empty
194/11:
d = {'a': [1], 
     'b': [2]}
pd.DataFrame.from_dict(d)
194/12:
import plotly.express as px

fig = px.line(df, x='created', y='hashrate', color='worker', title='Hashrate Over Time for Each Worker')
fig.show()
194/13:
import numpy as np
import matplotlib.pyplot as plt

import random

def generate_random_variable_list(n):
    random_variable_list = []
    for i in range(n):
        random_variable = random.uniform(0.001, 5)
        random_variable_list.append(random_variable)
    return random_variable_list

n = 10 # number of random variables
y = generate_random_variable_list(n)

x = [*range(0, n)]

df = pd.DataFrame({'x': x, 'y':y})
df['z'] = df['y'].expanding().mean()


plt.plot(df['x'], df['y'], label='y')
plt.plot(df['x'], df['z'], label='z')
plt.xlabel('x')
plt.ylabel('y and z')
plt.title('Plotting y and z over x')
plt.legend()
plt.show()
194/14: df
194/15: df
194/16:
n = df.melt(id_vars=['x'])
n
194/17: random.randrange(0,5)
194/18:
url ='http://15.204.211.130:4000/api/pools/ErgoSigmanauts'

pool = reader.get_api_data(url)['pool']
pool.keys()
194/19: pool['poolEffort']
194/20:
payment_data = pool['paymentProcessing']
del payment_data['enabled']
del payment_data['payoutSchemeConfig']
del payment_data['extra']
194/21: payment_data
194/22:
port_data = pool['ports']

ls = []
for port in port_data:
    temp = port_data[port]
    if 'pikes_peak' in temp['name']:
        high_or_low = 'Greater Than 10GH/s'
    else:
        high_or_low = 'Lower Than 10GH/s'
    ls.append([temp['name'], port, high_or_low, temp['tls']])
df = pd.DataFrame(ls, columns=['Name', 'Port', 'Hashrate Threshold', 'TLS'])
df
194/23:
pool_fee = pool['poolFeePercent']
pool_stats = pool['poolStats']
net_stats = pool['networkStats']
total_paid = pool['totalPaid']
total_blocks = pool['totalBlocks']
last_block_found = pool['lastPoolBlockTime']
pool_effort = pool['poolEffort']
194/24:
net_stats
del net_stats['connectedPeers']
del net_stats['rewardType']
del net_stats['networkType']
194/25: pool_stats
194/26: import dash
194/27: data = reader.get_front_page_data()
194/28:
data['poolHashrate'] = data['poolHashrate'] / 1e9 #GIGA
data['poolHashrate']
194/29: data
194/30: last_block_found
194/31: readable_format
194/32:
df = reader.get_all_miner_data()
df
194/33: df[df.wallet == '9ehJZvPDgvCNNd2zTQHxnSpcCAtb1kHbEN1VAgeoRD5DPVApYkk']
194/34:
df = reader.get_all_miner_data()
df['datetime'] = pd.to_datetime(df['created'])
df_sorted = df.sort_values(by='datetime', ascending=False)
latest_data = df_sorted.iloc[0]
latest_data
194/35:
df = reader.get_all_miner_data()
df['datetime'] = pd.to_datetime(df['created'])
df_sorted = df.sort_values(by='datetime', ascending=False)
df_sorted
194/36:
df = reader.get_all_miner_data()
df['datetime'] = pd.to_datetime(df['created'])
df_sorted = df.sort_values(by='datetime', ascending=False)
df_sorted['created']
194/37:
df = reader.get_all_miner_data()
df['datetime'] = pd.to_datetime(df['created'])
df_sorted = df.sort_values(by='datetime', ascending=False)
min(df_sorted['created'])
194/38:
df = reader.get_all_miner_data()
df['datetime'] = pd.to_datetime(df['created'])
df_sorted = df.sort_values(by='datetime', ascending=False)
max(df_sorted['created'])
194/39:
df = reader.get_all_miner_data()
latest_time = max(df_sorted['created'])
latest_df = df[df.created == latest_time]
194/40: latest_df[latest_df.wallet == '9ehJZvPDgvCNNd2zTQHxnSpcCAtb1kHbEN1VAgeoRD5DPVApYkk']
195/1: from utils.reader import SigmaWalletReader
195/2: reader = SigmaWalletReader(config_path="../conf")
195/3:
data = reader.get_api_data('http://15.204.211.130:4000/api/pools/ErgoSigmanauts/miners/')
data
195/4:
miner_ls = []
for sample in data:
    miner_ls.append(sample['miner'])


miner_ls
195/5:
miners = {}
for sample in data:
    miners[sample['miner']] = 0
for key in miners.keys():
    url = '{}/{}'.format('http://15.204.211.130:4000/api/pools/ErgoSigmanauts/miners', key)
    sample = reader.get_api_data(url)
    miners[key] = sample['pendingShares']
miners
195/6:
# Total of all values
total = sum(miners.values())

# Assume a reward variable, say 10000 for this example
reward = 30

# Calculate the percentage for each key based on its value and then determine the reward based on this percentage
rewards = {key: (value / total) * reward for key, value in miners.items()}

rewards
195/7:
import pandas as pd
rewards_df = pd.DataFrame(list(rewards.items()), columns=['miner', 'reward'])
rewards_df
195/8:
url = 'http://15.204.211.130:4000/api/pools/ErgoSigmanauts/miners/9ehJZvPDgvCNNd2zTQHxnSpcCAtb1kHbEN1VAgeoRD5DPVApYkk'
data = reader.get_api_data(url)
samples = data['performanceSamples']
samples
195/9: df = reader.get_miner_samples(wallet='9ehJZvPDgvCNNd2zTQHxnSpcCAtb1kHbEN1VAgeoRD5DPVApYkk')
195/10: df.empty
195/11:
d = {'a': [1], 
     'b': [2]}
pd.DataFrame.from_dict(d)
195/12:
import plotly.express as px

fig = px.line(df, x='created', y='hashrate', color='worker', title='Hashrate Over Time for Each Worker')
fig.show()
195/13:
import numpy as np
import matplotlib.pyplot as plt

import random

def generate_random_variable_list(n):
    random_variable_list = []
    for i in range(n):
        random_variable = random.uniform(0.001, 5)
        random_variable_list.append(random_variable)
    return random_variable_list

n = 10 # number of random variables
y = generate_random_variable_list(n)

x = [*range(0, n)]

df = pd.DataFrame({'x': x, 'y':y})
df['z'] = df['y'].expanding().mean()


plt.plot(df['x'], df['y'], label='y')
plt.plot(df['x'], df['z'], label='z')
plt.xlabel('x')
plt.ylabel('y and z')
plt.title('Plotting y and z over x')
plt.legend()
plt.show()
195/14: df
195/15: df
195/16:
n = df.melt(id_vars=['x'])
n
195/17: random.randrange(0,5)
195/18:
url ='http://15.204.211.130:4000/api/pools/ErgoSigmanauts'

pool = reader.get_api_data(url)['pool']
pool.keys()
195/19: pool['poolEffort']
195/20:
payment_data = pool['paymentProcessing']
del payment_data['enabled']
del payment_data['payoutSchemeConfig']
del payment_data['extra']
195/21: payment_data
195/22:
port_data = pool['ports']

ls = []
for port in port_data:
    temp = port_data[port]
    if 'pikes_peak' in temp['name']:
        high_or_low = 'Greater Than 10GH/s'
    else:
        high_or_low = 'Lower Than 10GH/s'
    ls.append([temp['name'], port, high_or_low, temp['tls']])
df = pd.DataFrame(ls, columns=['Name', 'Port', 'Hashrate Threshold', 'TLS'])
df
195/23:
pool_fee = pool['poolFeePercent']
pool_stats = pool['poolStats']
net_stats = pool['networkStats']
total_paid = pool['totalPaid']
total_blocks = pool['totalBlocks']
last_block_found = pool['lastPoolBlockTime']
pool_effort = pool['poolEffort']
195/24:
net_stats
del net_stats['connectedPeers']
del net_stats['rewardType']
del net_stats['networkType']
195/25: pool_stats
195/26: import dash
195/27: data = reader.get_front_page_data()
195/28:
data['poolHashrate'] = data['poolHashrate'] / 1e9 #GIGA
data['poolHashrate']
195/29: data
195/30: last_block_found
195/31:
df = reader.get_all_miner_data()
latest_time = max(df_sorted['created'])
latest_df = df[df.created == latest_time]
195/32: df = reader.get_all_miner_data()
195/33: df[df.wallet == '9ehJZvPDgvCNNd2zTQHxnSpcCAtb1kHbEN1VAgeoRD5DPVApYkk']
195/34:
df = reader.get_all_miner_data()
df
195/35:
def calculate_mining_effort(network_difficulty, network_hashrate, pool_hashrate, time_since_last_block):
    """
    Calculate the mining effort for the pool to find a block on Ergo blockchain.
    
    :param network_difficulty: The current difficulty of the Ergo network.
    :param network_hashrate: The total hash rate of the Ergo network (in hashes per second).
    :param pool_hashrate: The hash rate of the mining pool (in hashes per second).
    :param time_since_last_block: Time since the last block was found by the network (in seconds).
    :return: The estimated mining effort for the pool.
    """
    
    # Hashes to find a block at current difficulty
    hashes_to_find_block = network_difficulty  # This is a simplification
    
    # Total hashes by the network in the time since last block
    total_network_hashes = network_hashrate * time_since_last_block
    
    # Pool's share of the total network hashes
    pool_share_of_hashes = (pool_hashrate / network_hashrate) * total_network_hashes
    
    # Effort is the pool's share of hashes divided by the number of hashes to find a block
    effort = pool_share_of_hashes / hashes_to_find_block
    
    return effort

# Example usage:
network_difficulty = 2e12  # Example difficulty
network_hashrate = 1e15  # Example total network hash rate (1 PH/s)
pool_hashrate = 1e14  # Example pool hash rate (100 TH/s)
time_since_last_block = 600  # Example time since last block in seconds (10 minutes)

effort = calculate_mining_effort(network_difficulty, network_hashrate, pool_hashrate, time_since_last_block)
print(f"The estimated mining effort for the pool is: {effort}")
195/36:
def calculate_mining_effort(network_difficulty, network_hashrate, pool_hashrate, time_since_last_block):
    """
    Calculate the mining effort for the pool to find a block on Ergo blockchain.
    
    :param network_difficulty: The current difficulty of the Ergo network.
    :param network_hashrate: The total hash rate of the Ergo network (in hashes per second).
    :param pool_hashrate: The hash rate of the mining pool (in hashes per second).
    :param time_since_last_block: Time since the last block was found by the network (in seconds).
    :return: The estimated mining effort for the pool.
    """
    
    # Hashes to find a block at current difficulty
    hashes_to_find_block = network_difficulty  # This is a simplification
    
    # Total hashes by the network in the time since last block
    total_network_hashes = network_hashrate * time_since_last_block
    
    # Pool's share of the total network hashes
    pool_share_of_hashes = (pool_hashrate / network_hashrate) * total_network_hashes
    
    # Effort is the pool's share of hashes divided by the number of hashes to find a block
    effort = pool_share_of_hashes / hashes_to_find_block
    
    return effort / 100

# Example usage:
network_difficulty = 2e12  # Example difficulty
network_hashrate = 1e15  # Example total network hash rate (1 PH/s)
pool_hashrate = 1e14  # Example pool hash rate (100 TH/s)
time_since_last_block = 600  # Example time since last block in seconds (10 minutes)

effort = calculate_mining_effort(network_difficulty, network_hashrate, pool_hashrate, time_since_last_block)
print(f"The estimated mining effort for the pool is: {effort}")
195/37:
def calculate_mining_effort(network_difficulty, network_hashrate, pool_hashrate, time_since_last_block):
    """
    Calculate the mining effort for the pool to find a block on Ergo blockchain.
    
    :param network_difficulty: The current difficulty of the Ergo network.
    :param network_hashrate: The total hash rate of the Ergo network (in hashes per second).
    :param pool_hashrate: The hash rate of the mining pool (in hashes per second).
    :param time_since_last_block: Time since the last block was found by the network (in seconds).
    :return: The estimated mining effort for the pool.
    """
    
    # Hashes to find a block at current difficulty
    hashes_to_find_block = network_difficulty  # This is a simplification
    
    # Total hashes by the network in the time since last block
    total_network_hashes = network_hashrate * time_since_last_block
    
    # Pool's share of the total network hashes
    pool_share_of_hashes = (pool_hashrate / network_hashrate) * total_network_hashes
    
    # Effort is the pool's share of hashes divided by the number of hashes to find a block
    effort = pool_share_of_hashes / hashes_to_find_block
    
    return effort / 100

# Example usage:
network_difficulty = 1.73e15  # Example difficulty
network_hashrate = 14e15  # Example total network hash rate (1 PH/s)
pool_hashrate = 13e9  # Example pool hash rate (100 TH/s)
time_since_last_block = 600  # Example time since last block in seconds (10 minutes)

effort = calculate_mining_effort(network_difficulty, network_hashrate, pool_hashrate, time_since_last_block)
print(f"The estimated mining effort for the pool is: {effort}")
195/38:
def calculate_mining_effort(network_difficulty, network_hashrate, pool_hashrate, time_since_last_block):
    """
    Calculate the mining effort for the pool to find a block on Ergo blockchain.
    
    :param network_difficulty: The current difficulty of the Ergo network.
    :param network_hashrate: The total hash rate of the Ergo network (in hashes per second).
    :param pool_hashrate: The hash rate of the mining pool (in hashes per second).
    :param time_since_last_block: Time since the last block was found by the network (in seconds).
    :return: The estimated mining effort for the pool.
    """
    
    # Hashes to find a block at current difficulty
    hashes_to_find_block = network_difficulty  # This is a simplification
    
    # Total hashes by the network in the time since last block
    total_network_hashes = network_hashrate * time_since_last_block
    
    # Pool's share of the total network hashes
    pool_share_of_hashes = (pool_hashrate / network_hashrate) * total_network_hashes
    
    # Effort is the pool's share of hashes divided by the number of hashes to find a block
    effort = pool_share_of_hashes / hashes_to_find_block
    
    return effort

# Example usage:
network_difficulty = 1.73e15  # Example difficulty
network_hashrate = 14e15  # Example total network hash rate (1 PH/s)
pool_hashrate = 13e9  # Example pool hash rate (100 TH/s)
time_since_last_block = 600  # Example time since last block in seconds (10 minutes)

effort = calculate_mining_effort(network_difficulty, network_hashrate, pool_hashrate, time_since_last_block)
print(f"The estimated mining effort for the pool is: {effort}")
195/39:
def calculate_mining_effort(network_difficulty, network_hashrate, pool_hashrate, time_since_last_block):
    """
    Calculate the mining effort for the pool to find a block on Ergo blockchain.
    
    :param network_difficulty: The current difficulty of the Ergo network.
    :param network_hashrate: The total hash rate of the Ergo network (in hashes per second).
    :param pool_hashrate: The hash rate of the mining pool (in hashes per second).
    :param time_since_last_block: Time since the last block was found by the network (in seconds).
    :return: The estimated mining effort for the pool.
    """
    
    # Hashes to find a block at current difficulty
    hashes_to_find_block = network_difficulty  # This is a simplification
    
    # Total hashes by the network in the time since last block
    total_network_hashes = network_hashrate * time_since_last_block
    
    # Pool's share of the total network hashes
    pool_share_of_hashes = (pool_hashrate / network_hashrate) * total_network_hashes
    
    # Effort is the pool's share of hashes divided by the number of hashes to find a block
    effort = pool_share_of_hashes / hashes_to_find_block
    
    return effort

# Example usage:
network_difficulty = 1.73e15  # Example difficulty
network_hashrate = 14e15  # Example total network hash rate (1 PH/s)
pool_hashrate = 13e9  # Example pool hash rate (100 TH/s)
time_since_last_block = 600 *6 * 48  # Example time since last block in seconds (10 minutes)

effort = calculate_mining_effort(network_difficulty, network_hashrate, pool_hashrate, time_since_last_block)
print(f"The estimated mining effort for the pool is: {effort}")
195/40:
def calculate_mining_effort(network_difficulty, network_hashrate, pool_hashrate, time_since_last_block):
    """
    Calculate the mining effort for the pool to find a block on Ergo blockchain.
    
    :param network_difficulty: The current difficulty of the Ergo network.
    :param network_hashrate: The total hash rate of the Ergo network (in hashes per second).
    :param pool_hashrate: The hash rate of the mining pool (in hashes per second).
    :param time_since_last_block: Time since the last block was found by the network (in seconds).
    :return: The estimated mining effort for the pool.
    """
    
    # Hashes to find a block at current difficulty
    hashes_to_find_block = network_difficulty  # This is a simplification
    
    # Total hashes by the network in the time since last block
    total_network_hashes = network_hashrate * time_since_last_block
    
    # Pool's share of the total network hashes
    pool_share_of_hashes = (pool_hashrate / network_hashrate) * total_network_hashes
    
    # Effort is the pool's share of hashes divided by the number of hashes to find a block
    effort = pool_share_of_hashes / hashes_to_find_block
    
    return effort

# Example usage:
network_difficulty = 1.73e15  # Example difficulty
network_hashrate = 14e15  # Example total network hash rate (1 PH/s)
pool_hashrate = 13e9  # Example pool hash rate (100 TH/s)
time_since_last_block = 600 *6 * 24 * 7  # Example time since last block in seconds (10 minutes)

effort = calculate_mining_effort(network_difficulty, network_hashrate, pool_hashrate, time_since_last_block)
print(f"The estimated mining effort for the pool is: {effort}")
195/41:
from datetime import datetime
import pytz

def calculate_mining_effort(network_difficulty, network_hashrate, pool_hashrate, last_block_timestamp):
    """
    Calculate the mining effort for the pool to find a block on Ergo blockchain based on the given timestamp.
    
    :param network_difficulty: The current difficulty of the Ergo network.
    :param network_hashrate: The total hash rate of the Ergo network (in hashes per second).
    :param pool_hashrate: The hash rate of the mining pool (in hashes per second).
    :param last_block_timestamp: Timestamp of the last block found in ISO 8601 format.
    :return: The estimated mining effort for the pool.
    """
    # Parse the last block timestamp
    last_block_time = datetime.strptime(last_block_timestamp, '%Y-%m-%dT%H:%M:%SZ')
    last_block_time = last_block_time.replace(tzinfo=pytz.utc)  # Assume the timestamp is in UTC
    
    # Get the current time in UTC
    now = datetime.now(pytz.utc)
    
    # Calculate the time difference in seconds
    time_since_last_block = (now - last_block_time).total_seconds()
    
    # Hashes to find a block at current difficulty
    hashes_to_find_block = network_difficulty  # This is a simplification
    
    # Total hashes by the network in the time since last block
    total_network_hashes = network_hashrate * time_since_last_block
    
    # Pool's share of the total network hashes
    pool_share_of_hashes = (pool_hashrate / network_hashrate) * total_network_hashes
    
    # Effort is the pool's share of hashes divided by the number of hashes to find a block
    effort = pool_share_of_hashes / hashes_to_find_block
    
    return effort

# Example usage:
network_difficulty = 1.73e15  # Example difficulty
network_hashrate = 14e15  # Example total network hash rate (1 PH/s)
pool_hashrate = 13e9  # Example pool hash rate (100 TH/s)
last_block_timestamp = '2024-03-24T20:00:00Z'  # Example timestamp of the last block

effort = calculate_mining_effort(network_difficulty, network_hashrate, pool_hashrate, last_block_timestamp)
print(f"The estimated mining effort for the pool since the last block is: {effort}")
195/42:
from datetime import datetime
import pytz

def calculate_mining_effort(network_difficulty, network_hashrate, pool_hashrate, last_block_timestamp):
    """
    Calculate the mining effort for the pool to find a block on Ergo blockchain based on the given timestamp.
    
    :param network_difficulty: The current difficulty of the Ergo network.
    :param network_hashrate: The total hash rate of the Ergo network (in hashes per second).
    :param pool_hashrate: The hash rate of the mining pool (in hashes per second).
    :param last_block_timestamp: Timestamp of the last block found in ISO 8601 format.
    :return: The estimated mining effort for the pool.
    """
    # Parse the last block timestamp
    last_block_time = datetime.strptime(last_block_timestamp, '%Y-%m-%dT%H:%M:%SZ')
    last_block_time = last_block_time.replace(tzinfo=pytz.utc)  # Assume the timestamp is in UTC
    
    # Get the current time in UTC
    now = datetime.now(pytz.utc)
    
    # Calculate the time difference in seconds
    time_since_last_block = (now - last_block_time).total_seconds()
    
    # Hashes to find a block at current difficulty
    hashes_to_find_block = network_difficulty  # This is a simplification
    
    # Total hashes by the network in the time since last block
    total_network_hashes = network_hashrate * time_since_last_block
    
    # Pool's share of the total network hashes
    pool_share_of_hashes = (pool_hashrate / network_hashrate) * total_network_hashes
    
    # Effort is the pool's share of hashes divided by the number of hashes to find a block
    effort = pool_share_of_hashes / hashes_to_find_block
    
    return effort

# Example usage:
network_difficulty = 1.73e15  # Example difficulty
network_hashrate = 14e15  # Example total network hash rate (1 PH/s)
pool_hashrate = 13e9  # Example pool hash rate (100 TH/s)
last_block_timestamp = '2024-03-19T20:00:00Z'  # Example timestamp of the last block

effort = calculate_mining_effort(network_difficulty, network_hashrate, pool_hashrate, last_block_timestamp)
print(f"The estimated mining effort for the pool since the last block is: {effort}")
195/43:
from datetime import datetime
import pytz

def calculate_mining_effort(network_difficulty, network_hashrate, pool_hashrate, last_block_timestamp):
    """
    Calculate the mining effort for the pool to find a block on Ergo blockchain based on the given timestamp.
    
    :param network_difficulty: The current difficulty of the Ergo network.
    :param network_hashrate: The total hash rate of the Ergo network (in hashes per second).
    :param pool_hashrate: The hash rate of the mining pool (in hashes per second).
    :param last_block_timestamp: Timestamp of the last block found in ISO 8601 format.
    :return: The estimated mining effort for the pool.
    """
    # Parse the last block timestamp
    time_format = "%Y-%m-%dT%H:%M:%SZ"
    last_block_time = datetime.strptime(last_block_timestamp, time_format)
    last_block_time = last_block_time.replace(tzinfo=pytz.utc)  # Assume the timestamp is in UTC
    
    # Get the current time in UTC
    now = datetime.now(pytz.utc)
    
    # Calculate the time difference in seconds
    time_since_last_block = (now - last_block_time).total_seconds()
    
    # Hashes to find a block at current difficulty
    hashes_to_find_block = network_difficulty  # This is a simplification
    
    # Total hashes by the network in the time since last block
    total_network_hashes = network_hashrate * time_since_last_block
    
    # Pool's share of the total network hashes
    pool_share_of_hashes = (pool_hashrate / network_hashrate) * total_network_hashes
    
    # Effort is the pool's share of hashes divided by the number of hashes to find a block
    effort = pool_share_of_hashes / hashes_to_find_block
    
    return effort

# Example usage:
network_difficulty = 1.73e15  # Example difficulty
network_hashrate = 14e15  # Example total network hash rate (1 PH/s)
pool_hashrate = 13e9  # Example pool hash rate (100 TH/s)
last_block_timestamp = "2024-03-19 04:19:20"

effort = calculate_mining_effort(network_difficulty, network_hashrate, pool_hashrate, last_block_timestamp)
print(f"Mining Effort: {effort}")
last_block_timestamp = '2024-03-19T20:00:00Z'  # Example timestamp of the last block

effort = calculate_mining_effort(network_difficulty, network_hashrate, pool_hashrate, last_block_timestamp)
print(f"The estimated mining effort for the pool since the last block is: {effort}")
195/44:
from datetime import datetime
import pytz

def calculate_mining_effort(network_difficulty, network_hashrate, pool_hashrate, last_block_timestamp):
    """
    Calculate the mining effort for the pool to find a block on Ergo blockchain based on the given timestamp.
    
    :param network_difficulty: The current difficulty of the Ergo network.
    :param network_hashrate: The total hash rate of the Ergo network (in hashes per second).
    :param pool_hashrate: The hash rate of the mining pool (in hashes per second).
    :param last_block_timestamp: Timestamp of the last block found in ISO 8601 format.
    :return: The estimated mining effort for the pool.
    """
    # Parse the last block timestamp
    time_format = "%Y-%m-%dT%H:%M:%SZ"
    last_block_time = datetime.strptime(last_block_timestamp, time_format)
    last_block_time = last_block_time.replace(tzinfo=pytz.utc)  # Assume the timestamp is in UTC
    
    # Get the current time in UTC
    now = datetime.now(pytz.utc)
    
    # Calculate the time difference in seconds
    time_since_last_block = (now - last_block_time).total_seconds()
    
    # Hashes to find a block at current difficulty
    hashes_to_find_block = network_difficulty  # This is a simplification
    
    # Total hashes by the network in the time since last block
    total_network_hashes = network_hashrate * time_since_last_block
    
    # Pool's share of the total network hashes
    pool_share_of_hashes = (pool_hashrate / network_hashrate) * total_network_hashes
    
    # Effort is the pool's share of hashes divided by the number of hashes to find a block
    effort = pool_share_of_hashes / hashes_to_find_block
    
    return effort

# Example usage:
network_difficulty = 1.73e15  # Example difficulty
network_hashrate = 14e15  # Example total network hash rate (1 PH/s)
pool_hashrate = 13e9  # Example pool hash rate (100 TH/s)
last_block_timestamp = "2024-03-19 04:19:20"

effort = calculate_mining_effort(network_difficulty, network_hashrate, pool_hashrate, last_block_timestamp)
print(f"The estimated mining effort for the pool since the last block is: {effort}")
195/45:
from datetime import datetime

date_time_str = '2024-03-19 04:19:20'
format = '%Y-%m-%dT%H:%M:%S'
date_time_obj = datetime.strptime(date_time_str, format)

print(date_time_obj)
195/46:
from datetime import datetime

date_time_str = '2024-03-19 04:19:20'
format = '%Y-%m-%d %H:%M:%S'  # Added a space between '%d' and '%H'
date_time_obj = datetime.strptime(date_time_str, format)

print(date_time_obj)
195/47:
from datetime import datetime
import pytz

def calculate_mining_effort(network_difficulty, network_hashrate, pool_hashrate, last_block_timestamp):
    """
    Calculate the mining effort for the pool to find a block on Ergo blockchain based on the given timestamp.
    
    :param network_difficulty: The current difficulty of the Ergo network.
    :param network_hashrate: The total hash rate of the Ergo network (in hashes per second).
    :param pool_hashrate: The hash rate of the mining pool (in hashes per second).
    :param last_block_timestamp: Timestamp of the last block found in ISO 8601 format.
    :return: The estimated mining effort for the pool.
    """
    # Parse the last block timestamp
    time_format = '%Y-%m-%d %H:%M:%S' 
    last_block_time = datetime.strptime(last_block_timestamp, time_format)
    last_block_time = last_block_time.replace(tzinfo=pytz.utc)  # Assume the timestamp is in UTC
    
    # Get the current time in UTC
    now = datetime.now(pytz.utc)
    
    # Calculate the time difference in seconds
    time_since_last_block = (now - last_block_time).total_seconds()
    
    # Hashes to find a block at current difficulty
    hashes_to_find_block = network_difficulty  # This is a simplification
    
    # Total hashes by the network in the time since last block
    total_network_hashes = network_hashrate * time_since_last_block
    
    # Pool's share of the total network hashes
    pool_share_of_hashes = (pool_hashrate / network_hashrate) * total_network_hashes
    
    # Effort is the pool's share of hashes divided by the number of hashes to find a block
    effort = pool_share_of_hashes / hashes_to_find_block
    
    return effort

# Example usage:
network_difficulty = 1.73e15  # Example difficulty
network_hashrate = 14e15  # Example total network hash rate (1 PH/s)
pool_hashrate = 13e9  # Example pool hash rate (100 TH/s)
last_block_timestamp = "2024-03-19 04:19:20"

effort = calculate_mining_effort(network_difficulty, network_hashrate, pool_hashrate, last_block_timestamp)
print(f"The estimated mining effort for the pool since the last block is: {effort}")
196/1: from utils.reader import SigmaWalletReader
196/2: reader = SigmaWalletReader(config_path="../conf")
196/3:
data = reader.get_api_data('http://15.204.211.130:4000/api/pools/ErgoSigmanauts/miners/')
data
196/4:
miner_ls = []
for sample in data:
    miner_ls.append(sample['miner'])


miner_ls
196/5:
miners = {}
for sample in data:
    miners[sample['miner']] = 0
for key in miners.keys():
    url = '{}/{}'.format('http://15.204.211.130:4000/api/pools/ErgoSigmanauts/miners', key)
    sample = reader.get_api_data(url)
    miners[key] = sample['pendingShares']
miners
196/6:
# Total of all values
total = sum(miners.values())

# Assume a reward variable, say 10000 for this example
reward = 30

# Calculate the percentage for each key based on its value and then determine the reward based on this percentage
rewards = {key: (value / total) * reward for key, value in miners.items()}

rewards
196/7:
import pandas as pd
rewards_df = pd.DataFrame(list(rewards.items()), columns=['miner', 'reward'])
rewards_df
196/8:
url = 'http://15.204.211.130:4000/api/pools/ErgoSigmanauts/miners/9ehJZvPDgvCNNd2zTQHxnSpcCAtb1kHbEN1VAgeoRD5DPVApYkk'
data = reader.get_api_data(url)
samples = data['performanceSamples']
samples
196/9: df = reader.get_miner_samples(wallet='9ehJZvPDgvCNNd2zTQHxnSpcCAtb1kHbEN1VAgeoRD5DPVApYkk')
196/10: df.empty
196/11:
d = {'a': [1], 
     'b': [2]}
pd.DataFrame.from_dict(d)
196/12:
import plotly.express as px

fig = px.line(df, x='created', y='hashrate', color='worker', title='Hashrate Over Time for Each Worker')
fig.show()
196/13:
import numpy as np
import matplotlib.pyplot as plt

import random

def generate_random_variable_list(n):
    random_variable_list = []
    for i in range(n):
        random_variable = random.uniform(0.001, 5)
        random_variable_list.append(random_variable)
    return random_variable_list

n = 10 # number of random variables
y = generate_random_variable_list(n)

x = [*range(0, n)]

df = pd.DataFrame({'x': x, 'y':y})
df['z'] = df['y'].expanding().mean()


plt.plot(df['x'], df['y'], label='y')
plt.plot(df['x'], df['z'], label='z')
plt.xlabel('x')
plt.ylabel('y and z')
plt.title('Plotting y and z over x')
plt.legend()
plt.show()
196/14: df
196/15: df
196/16:
n = df.melt(id_vars=['x'])
n
196/17: random.randrange(0,5)
196/18:
url ='http://15.204.211.130:4000/api/pools/ErgoSigmanauts'

pool = reader.get_api_data(url)['pool']
pool.keys()
196/19: pool['poolEffort']
196/20:
payment_data = pool['paymentProcessing']
del payment_data['enabled']
del payment_data['payoutSchemeConfig']
del payment_data['extra']
196/21: payment_data
196/22:
port_data = pool['ports']

ls = []
for port in port_data:
    temp = port_data[port]
    if 'pikes_peak' in temp['name']:
        high_or_low = 'Greater Than 10GH/s'
    else:
        high_or_low = 'Lower Than 10GH/s'
    ls.append([temp['name'], port, high_or_low, temp['tls']])
df = pd.DataFrame(ls, columns=['Name', 'Port', 'Hashrate Threshold', 'TLS'])
df
196/23:
pool_fee = pool['poolFeePercent']
pool_stats = pool['poolStats']
net_stats = pool['networkStats']
total_paid = pool['totalPaid']
total_blocks = pool['totalBlocks']
last_block_found = pool['lastPoolBlockTime']
pool_effort = pool['poolEffort']
196/24:
net_stats
del net_stats['connectedPeers']
del net_stats['rewardType']
del net_stats['networkType']
196/25: pool_stats
196/26: import dash
196/27: data = reader.get_front_page_data()
196/28:
data['poolHashrate'] = data['poolHashrate'] / 1e9 #GIGA
data['poolHashrate']
196/29: data
196/30: last_block_found
196/31:
df = reader.get_all_miner_data()
df
196/32:
df = reader.get_all_miner_data('9ehJZvPDgvCNNd2zTQHxnSpcCAtb1kHbEN1VAgeoRD5DPVApYkk')
df
197/1: from utils.reader import SigmaWalletReader
197/2: reader = SigmaWalletReader(config_path="../conf")
197/3:
data = reader.get_api_data('http://15.204.211.130:4000/api/pools/ErgoSigmanauts/miners/')
data
197/4:
miner_ls = []
for sample in data:
    miner_ls.append(sample['miner'])


miner_ls
197/5:
miners = {}
for sample in data:
    miners[sample['miner']] = 0
for key in miners.keys():
    url = '{}/{}'.format('http://15.204.211.130:4000/api/pools/ErgoSigmanauts/miners', key)
    sample = reader.get_api_data(url)
    miners[key] = sample['pendingShares']
miners
197/6:
# Total of all values
total = sum(miners.values())

# Assume a reward variable, say 10000 for this example
reward = 30

# Calculate the percentage for each key based on its value and then determine the reward based on this percentage
rewards = {key: (value / total) * reward for key, value in miners.items()}

rewards
197/7:
import pandas as pd
rewards_df = pd.DataFrame(list(rewards.items()), columns=['miner', 'reward'])
rewards_df
197/8:
url = 'http://15.204.211.130:4000/api/pools/ErgoSigmanauts/miners/9ehJZvPDgvCNNd2zTQHxnSpcCAtb1kHbEN1VAgeoRD5DPVApYkk'
data = reader.get_api_data(url)
samples = data['performanceSamples']
samples
197/9: df = reader.get_miner_samples(wallet='9ehJZvPDgvCNNd2zTQHxnSpcCAtb1kHbEN1VAgeoRD5DPVApYkk')
197/10: df.empty
197/11:
d = {'a': [1], 
     'b': [2]}
pd.DataFrame.from_dict(d)
197/12:
import plotly.express as px

fig = px.line(df, x='created', y='hashrate', color='worker', title='Hashrate Over Time for Each Worker')
fig.show()
197/13:
import numpy as np
import matplotlib.pyplot as plt

import random

def generate_random_variable_list(n):
    random_variable_list = []
    for i in range(n):
        random_variable = random.uniform(0.001, 5)
        random_variable_list.append(random_variable)
    return random_variable_list

n = 10 # number of random variables
y = generate_random_variable_list(n)

x = [*range(0, n)]

df = pd.DataFrame({'x': x, 'y':y})
df['z'] = df['y'].expanding().mean()


plt.plot(df['x'], df['y'], label='y')
plt.plot(df['x'], df['z'], label='z')
plt.xlabel('x')
plt.ylabel('y and z')
plt.title('Plotting y and z over x')
plt.legend()
plt.show()
197/14: df
197/15: df
197/16:
n = df.melt(id_vars=['x'])
n
197/17: random.randrange(0,5)
197/18:
url ='http://15.204.211.130:4000/api/pools/ErgoSigmanauts'

pool = reader.get_api_data(url)['pool']
pool.keys()
197/19: pool['poolEffort']
197/20:
payment_data = pool['paymentProcessing']
del payment_data['enabled']
del payment_data['payoutSchemeConfig']
del payment_data['extra']
197/21: payment_data
197/22:
port_data = pool['ports']

ls = []
for port in port_data:
    temp = port_data[port]
    if 'pikes_peak' in temp['name']:
        high_or_low = 'Greater Than 10GH/s'
    else:
        high_or_low = 'Lower Than 10GH/s'
    ls.append([temp['name'], port, high_or_low, temp['tls']])
df = pd.DataFrame(ls, columns=['Name', 'Port', 'Hashrate Threshold', 'TLS'])
df
197/23:
pool_fee = pool['poolFeePercent']
pool_stats = pool['poolStats']
net_stats = pool['networkStats']
total_paid = pool['totalPaid']
total_blocks = pool['totalBlocks']
last_block_found = pool['lastPoolBlockTime']
pool_effort = pool['poolEffort']
197/24:
net_stats
del net_stats['connectedPeers']
del net_stats['rewardType']
del net_stats['networkType']
197/25: pool_stats
197/26: import dash
197/27: data = reader.get_front_page_data()
197/28:
data['poolHashrate'] = data['poolHashrate'] / 1e9 #GIGA
data['poolHashrate']
197/29: data
197/30: last_block_found
197/31:
df = reader.get_all_miner_data('9ehJZvPDgvCNNd2zTQHxnSpcCAtb1kHbEN1VAgeoRD5DPVApYkk')
df
197/32: df[df.wallet == '9ehJZvPDgvCNNd2zTQHxnSpcCAtb1kHbEN1VAgeoRD5DPVApYkk']
198/1: from utils.reader import SigmaWalletReader
198/2: reader = SigmaWalletReader(config_path="../conf")
198/3:
data = reader.get_api_data('http://15.204.211.130:4000/api/pools/ErgoSigmanauts/miners/')
data
198/4:
miner_ls = []
for sample in data:
    miner_ls.append(sample['miner'])


miner_ls
198/5:
miners = {}
for sample in data:
    miners[sample['miner']] = 0
for key in miners.keys():
    url = '{}/{}'.format('http://15.204.211.130:4000/api/pools/ErgoSigmanauts/miners', key)
    sample = reader.get_api_data(url)
    miners[key] = sample['pendingShares']
miners
198/6:
# Total of all values
total = sum(miners.values())

# Assume a reward variable, say 10000 for this example
reward = 30

# Calculate the percentage for each key based on its value and then determine the reward based on this percentage
rewards = {key: (value / total) * reward for key, value in miners.items()}

rewards
198/7:
import pandas as pd
rewards_df = pd.DataFrame(list(rewards.items()), columns=['miner', 'reward'])
rewards_df
198/8:
url = 'http://15.204.211.130:4000/api/pools/ErgoSigmanauts/miners/9ehJZvPDgvCNNd2zTQHxnSpcCAtb1kHbEN1VAgeoRD5DPVApYkk'
data = reader.get_api_data(url)
samples = data['performanceSamples']
samples
198/9: df = reader.get_miner_samples(wallet='9ehJZvPDgvCNNd2zTQHxnSpcCAtb1kHbEN1VAgeoRD5DPVApYkk')
198/10: df.empty
198/11:
d = {'a': [1], 
     'b': [2]}
pd.DataFrame.from_dict(d)
198/12:
import plotly.express as px

fig = px.line(df, x='created', y='hashrate', color='worker', title='Hashrate Over Time for Each Worker')
fig.show()
198/13:
import numpy as np
import matplotlib.pyplot as plt

import random

def generate_random_variable_list(n):
    random_variable_list = []
    for i in range(n):
        random_variable = random.uniform(0.001, 5)
        random_variable_list.append(random_variable)
    return random_variable_list

n = 10 # number of random variables
y = generate_random_variable_list(n)

x = [*range(0, n)]

df = pd.DataFrame({'x': x, 'y':y})
df['z'] = df['y'].expanding().mean()


plt.plot(df['x'], df['y'], label='y')
plt.plot(df['x'], df['z'], label='z')
plt.xlabel('x')
plt.ylabel('y and z')
plt.title('Plotting y and z over x')
plt.legend()
plt.show()
198/14: df
198/15: df
198/16:
n = df.melt(id_vars=['x'])
n
198/17: random.randrange(0,5)
198/18:
url ='http://15.204.211.130:4000/api/pools/ErgoSigmanauts'

pool = reader.get_api_data(url)['pool']
pool.keys()
198/19: pool['poolEffort']
198/20:
payment_data = pool['paymentProcessing']
del payment_data['enabled']
del payment_data['payoutSchemeConfig']
del payment_data['extra']
198/21: payment_data
198/22:
port_data = pool['ports']

ls = []
for port in port_data:
    temp = port_data[port]
    if 'pikes_peak' in temp['name']:
        high_or_low = 'Greater Than 10GH/s'
    else:
        high_or_low = 'Lower Than 10GH/s'
    ls.append([temp['name'], port, high_or_low, temp['tls']])
df = pd.DataFrame(ls, columns=['Name', 'Port', 'Hashrate Threshold', 'TLS'])
df
198/23:
pool_fee = pool['poolFeePercent']
pool_stats = pool['poolStats']
net_stats = pool['networkStats']
total_paid = pool['totalPaid']
total_blocks = pool['totalBlocks']
last_block_found = pool['lastPoolBlockTime']
pool_effort = pool['poolEffort']
198/24:
net_stats
del net_stats['connectedPeers']
del net_stats['rewardType']
del net_stats['networkType']
198/25: pool_stats
198/26: import dash
198/27: data = reader.get_front_page_data()
198/28:
data['poolHashrate'] = data['poolHashrate'] / 1e9 #GIGA
data['poolHashrate']
198/29: data
198/30: last_block_found
198/31:
df = reader.get_all_miner_data('9ehJZvPDgvCNNd2zTQHxnSpcCAtb1kHbEN1VAgeoRD5DPVApYkk')
df
198/32: df[df.wallet == '9ehJZvPDgvCNNd2zTQHxnSpcCAtb1kHbEN1VAgeoRD5DPVApYkk']
198/33:
miners = reader.get_miner_ls()
data = []
for miner in miners:
    temp = self.get_miner_samples(miner)
198/34:
miners = reader.get_miner_ls()
data = []
for miner in miners:
    temp = reader.get_miner_samples(miner)
198/35: temp
198/36:
miners = reader.get_miner_ls()
data = []
for miner in miners:
    temp = reader.get_miner_samples(miner)
    data.append(temp)

df = pd.concat(data)
198/37: df
198/38:
ls = []
for date in df.created.unique():
    temp = df[df.created == date]
    ls.append([date, temp.hashrate.sum()])

n = pd.DataFrame(ls, columns=['Date', 'Hashrate'])
198/39: n
198/40:
ls = []
for date in df.created.unique():
    temp = df[df.created == date]
    ls.append([date, temp.hashrate.sum() /1e9])

n = pd.DataFrame(ls, columns=['Date', 'Hashrate'])
198/41: n
198/42:
from datetime import datetime
import pytz

def calculate_mining_effort(network_difficulty, network_hashrate, pool_hashrate, last_block_timestamp):
    """
    Calculate the mining effort for the pool to find a block on Ergo blockchain based on the given timestamp.
    
    :param network_difficulty: The current difficulty of the Ergo network.
    :param network_hashrate: The total hash rate of the Ergo network (in hashes per second).
    :param pool_hashrate: The hash rate of the mining pool (in hashes per second).
    :param last_block_timestamp: Timestamp of the last block found in ISO 8601 format.
    :return: The estimated mining effort for the pool.
    """
    # Parse the last block timestamp
    time_format = '%Y-%m-%d %H:%M:%S' 
    last_block_time = datetime.strptime(last_block_timestamp, time_format)
    last_block_time = last_block_time.replace(tzinfo=pytz.utc)  # Assume the timestamp is in UTC
    
    # Get the current time in UTC
    now = datetime.now(pytz.utc)
    
    # Calculate the time difference in seconds
    time_since_last_block = (now - last_block_time).total_seconds()
    
    # Hashes to find a block at current difficulty
    hashes_to_find_block = network_difficulty  # This is a simplification
    
    # Total hashes by the network in the time since last block
    total_network_hashes = network_hashrate * time_since_last_block
    
    # Pool's share of the total network hashes
    pool_share_of_hashes = (pool_hashrate / network_hashrate) * total_network_hashes
    
    # Effort is the pool's share of hashes divided by the number of hashes to find a block
    effort = pool_share_of_hashes / hashes_to_find_block
    
    return effort

# Example usage:
network_difficulty = 1.73e15  # Example difficulty
network_hashrate = 14e15  # Example total network hash rate (1 PH/s)
pool_hashrate = 13e9  # Example pool hash rate (100 TH/s)
last_block_timestamp = "2024-03-19 04:19:20"

effort = calculate_mining_effort(network_difficulty, network_hashrate, pool_hashrate, last_block_timestamp)
print(f"The estimated mining effort for the pool since the last block is: {effort}")
198/43:
from datetime import datetime
import pytz

def calculate_mining_effort(network_difficulty, network_hashrate, pool_hashrate, last_block_timestamp):
    """
    Calculate the mining effort for the pool to find a block on Ergo blockchain based on the given timestamp.
    
    :param network_difficulty: The current difficulty of the Ergo network.
    :param network_hashrate: The total hash rate of the Ergo network (in hashes per second).
    :param pool_hashrate: The hash rate of the mining pool (in hashes per second).
    :param last_block_timestamp: Timestamp of the last block found in ISO 8601 format.
    :return: The estimated mining effort for the pool.
    """
    # Parse the last block timestamp
    time_format = '%Y-%m-%d %H:%M:%S' 
    last_block_time = datetime.strptime(last_block_timestamp, time_format)
    last_block_time = last_block_time.replace(tzinfo=pytz.utc)  # Assume the timestamp is in UTC
    
    # Get the current time in UTC
    now = datetime.now(pytz.utc)
    
    # Calculate the time difference in seconds
    time_since_last_block = (now - last_block_time).total_seconds()
    
    # Hashes to find a block at current difficulty
    hashes_to_find_block = network_difficulty  # This is a simplification
    
    # Total hashes by the network in the time since last block
    total_network_hashes = network_hashrate * time_since_last_block
    
    # Pool's share of the total network hashes
    pool_share_of_hashes = (pool_hashrate / network_hashrate) * total_network_hashes
    
    # Effort is the pool's share of hashes divided by the number of hashes to find a block
    effort = pool_share_of_hashes / hashes_to_find_block
    
    return effort

# Example usage:
network_difficulty = 1.73e15  # Example difficulty
network_hashrate = 12.4e15  # Example total network hash rate (1 PH/s)
pool_hashrate = 15e9  # Example pool hash rate (100 TH/s)
last_block_timestamp = "2024-03-19 04:19:20"

effort = calculate_mining_effort(network_difficulty, network_hashrate, pool_hashrate, last_block_timestamp)
print(f"The estimated mining effort for the pool since the last block is: {effort}")
200/1:
from datetime import datetime
import pytz

def calculate_mining_effort(network_difficulty, network_hashrate, pool_hashrate, last_block_timestamp):
    """
    Calculate the mining effort for the pool to find a block on Ergo blockchain based on the given timestamp.
    
    :param network_difficulty: The current difficulty of the Ergo network.
    :param network_hashrate: The total hash rate of the Ergo network (in hashes per second).
    :param pool_hashrate: The hash rate of the mining pool (in hashes per second).
    :param last_block_timestamp: Timestamp of the last block found in ISO 8601 format.
    :return: The estimated mining effort for the pool.
    """
    # Parse the last block timestamp
    time_format = '%Y-%m-%d %H:%M:%S' 
    last_block_time = datetime.strptime(last_block_timestamp, time_format)
    last_block_time = last_block_time.replace(tzinfo=pytz.utc)  # Assume the timestamp is in UTC
    
    # Get the current time in UTC
    now = datetime.now(pytz.utc)
    
    # Calculate the time difference in seconds
    time_since_last_block = (now - last_block_time).total_seconds()
    
    # Hashes to find a block at current difficulty
    hashes_to_find_block = network_difficulty  # This is a simplification
    
    # Total hashes by the network in the time since last block
    total_network_hashes = network_hashrate * time_since_last_block
    
    # Pool's share of the total network hashes
    pool_share_of_hashes = (pool_hashrate / network_hashrate) * total_network_hashes
    
    # Effort is the pool's share of hashes divided by the number of hashes to find a block
    effort = pool_share_of_hashes / hashes_to_find_block
    
    return effort

# Example usage:
network_difficulty = 1.73e15  # Example difficulty
network_hashrate = 12.4e12  # Example total network hash rate (1 PH/s)
pool_hashrate = 15e9  # Example pool hash rate (100 TH/s)
last_block_timestamp = "2024-03-19 04:19:20"

effort = calculate_mining_effort(network_difficulty, network_hashrate, pool_hashrate, last_block_timestamp)
print(f"The estimated mining effort for the pool since the last block is: {effort}")
200/2:
from datetime import datetime
import pytz

def calculate_mining_effort(network_difficulty, network_hashrate, pool_hashrate, last_block_timestamp):
    """
    Calculate the mining effort for the pool to find a block on Ergo blockchain based on the given timestamp.
    
    :param network_difficulty: The current difficulty of the Ergo network.
    :param network_hashrate: The total hash rate of the Ergo network (in hashes per second).
    :param pool_hashrate: The hash rate of the mining pool (in hashes per second).
    :param last_block_timestamp: Timestamp of the last block found in ISO 8601 format.
    :return: The estimated mining effort for the pool.
    """
    # Parse the last block timestamp
    time_format = '%Y-%m-%d %H:%M:%S' 
    last_block_time = datetime.strptime(last_block_timestamp, time_format)
    last_block_time = last_block_time.replace(tzinfo=pytz.utc)  # Assume the timestamp is in UTC
    
    # Get the current time in UTC
    now = datetime.now(pytz.utc)
    
    # Calculate the time difference in seconds
    time_since_last_block = (now - last_block_time).total_seconds()
    
    # Hashes to find a block at current difficulty
    hashes_to_find_block = network_difficulty  # This is a simplification
    
    # Total hashes by the network in the time since last block
    total_network_hashes = network_hashrate * time_since_last_block
    
    # Pool's share of the total network hashes
    pool_share_of_hashes = (pool_hashrate / network_hashrate) * total_network_hashes
    
    # Effort is the pool's share of hashes divided by the number of hashes to find a block
    effort = pool_share_of_hashes / hashes_to_find_block
    
    return effort

# Example usage:
network_difficulty = 1.73e15  # Example difficulty
network_hashrate = 12.4e12  # Example total network hash rate (1 PH/s)
pool_hashrate = 15e9  # Example pool hash rate (100 TH/s)
last_block_timestamp = "2024-03-31 07:40:29"

effort = calculate_mining_effort(network_difficulty, network_hashrate, pool_hashrate, last_block_timestamp)
print(f"The estimated mining effort for the pool since the last block is: {effort}")
200/3:
from datetime import datetime
import pytz

def calculate_mining_effort(network_difficulty, network_hashrate, pool_hashrate, last_block_timestamp):
    """
    Calculate the mining effort for the pool to find a block on Ergo blockchain based on the given timestamp.
    
    :param network_difficulty: The current difficulty of the Ergo network.
    :param network_hashrate: The total hash rate of the Ergo network (in hashes per second).
    :param pool_hashrate: The hash rate of the mining pool (in hashes per second).
    :param last_block_timestamp: Timestamp of the last block found in ISO 8601 format.
    :return: The estimated mining effort for the pool.
    """
    # Parse the last block timestamp
    time_format = '%Y-%m-%d %H:%M:%S' 
    last_block_time = datetime.strptime(last_block_timestamp, time_format)
    last_block_time = last_block_time.replace(tzinfo=pytz.utc)  # Assume the timestamp is in UTC
    
    # Get the current time in UTC
    now = datetime.now(pytz.utc)
    
    # Calculate the time difference in seconds
    time_since_last_block = (now - last_block_time).total_seconds()
    
    # Hashes to find a block at current difficulty
    hashes_to_find_block = network_difficulty  # This is a simplification
    
    # Total hashes by the network in the time since last block
    total_network_hashes = network_hashrate * time_since_last_block
    
    # Pool's share of the total network hashes
    pool_share_of_hashes = (pool_hashrate / network_hashrate) * total_network_hashes
    
    # Effort is the pool's share of hashes divided by the number of hashes to find a block
    effort = pool_share_of_hashes / hashes_to_find_block
    
    return effort

# Example usage:
network_difficulty = 1.83e15  # Example difficulty
network_hashrate = 15.4e12  # Example total network hash rate (1 PH/s)
pool_hashrate = 13e9  # Example pool hash rate (100 TH/s)
last_block_timestamp = "2024-03-31 07:40:29"

effort = calculate_mining_effort(network_difficulty, network_hashrate, pool_hashrate, last_block_timestamp)
print(f"The estimated mining effort for the pool since the last block is: {effort}")
200/4:
from datetime import datetime
import pytz

def calculate_mining_effort(network_difficulty, network_hashrate, pool_hashrate, last_block_timestamp):
    """
    Calculate the mining effort for the pool to find a block on Ergo blockchain based on the given timestamp.
    
    :param network_difficulty: The current difficulty of the Ergo network.
    :param network_hashrate: The total hash rate of the Ergo network (in hashes per second).
    :param pool_hashrate: The hash rate of the mining pool (in hashes per second).
    :param last_block_timestamp: Timestamp of the last block found in ISO 8601 format.
    :return: The estimated mining effort for the pool.
    """
    # Parse the last block timestamp
    time_format = '%Y-%m-%d %H:%M:%S' 
    last_block_time = datetime.strptime(last_block_timestamp, time_format)
    last_block_time = last_block_time.replace(tzinfo=pytz.utc)  # Assume the timestamp is in UTC
    
    # Get the current time in UTC
    now = datetime.now(pytz.utc)
    
    # Calculate the time difference in seconds
    time_since_last_block = (now - last_block_time).total_seconds()
    
    # Hashes to find a block at current difficulty
    hashes_to_find_block = network_difficulty  # This is a simplification
    
    # Total hashes by the network in the time since last block
    total_network_hashes = network_hashrate * time_since_last_block
    
    # Pool's share of the total network hashes
    pool_share_of_hashes = (pool_hashrate / network_hashrate) * total_network_hashes
    
    # Effort is the pool's share of hashes divided by the number of hashes to find a block
    effort = pool_share_of_hashes / hashes_to_find_block
    
    return effort

# Example usage:
network_difficulty = 1.83e15  # Example difficulty
network_hashrate = 15.4e12  # Example total network hash rate (1 PH/s)
pool_hashrate = 13.3e9  # Example pool hash rate (100 TH/s)
last_block_timestamp = "2024-03-31 07:40:29"

effort = calculate_mining_effort(network_difficulty, network_hashrate, pool_hashrate, last_block_timestamp)
print(f"The estimated mining effort for the pool since the last block is: {effort}")
200/5:
from datetime import datetime

date_time_str = '2024-03-19 04:19:20'
format = '%Y-%m-%d %H:%M:%S'  # Added a space between '%d' and '%H'
date_time_obj = datetime.strptime(date_time_str, format)

print(date_time_obj)
200/6: type(date_time_str)
   1: %history -g -f history.txt
